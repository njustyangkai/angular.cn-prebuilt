<!DOCTYPE html><html lang="en" ng-app="angularIOApp" itemscope itemtype="http://schema.org/Framework"><!-- template: public/docs/_layout--><head><title>应用的第一个测试 - ts</title><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="Angular是一个用于构建移动应用和桌面Web应用的开发平台"/><meta name="keywords" content="Angular, 中文, 中文版, AngularJS, AngularDart, Javscript, Dart, Framework, JavaScript MVC, Google"/><meta name="robots" content="all"/><meta name="referrer" content="origin"/><meta name="viewport" id="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Angular 2"/><meta property="og:image" content="/resources/images/logos/standard/shield-large.png"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="184"/><meta property="og:image:height" content="200"/><meta property="og:description" content="Angular是一个用于构建移动应用和桌面Web应用的开发平台"/><meta itemprop="name" content="Angular 2"/><meta itemprop="description" content="Angular是一个用于构建移动应用和桌面Web应用的开发平台"/><meta itemprop="image" content="/resources/images/logos/standard/shield-large.png"/><link rel="icon" type="image/x-icon" href="/resources/images/icons/favicon.ico"/><link rel="stylesheet" href="/resources/css/vendor/angular-material.min.css"/><link href="/resources/fonts/vendor/roboto.css" rel="stylesheet" type="text/css"/><link href="/resources/fonts/vendor/material-icons.css" rel="stylesheet"/><link rel="stylesheet" href="/resources/css/vendor/icomoon/style.css"/><link rel="stylesheet" href="/resources/css/vendor/animate.css"/><link rel="stylesheet" href="/resources/css/main.css"/><!-- MOBILE ICONS -->
<link rel="apple-touch-icon" sizes="57x57" href="/resources/images/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/resources/images/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/resources/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/resources/images/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/resources/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/resources/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/resources/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/resources/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/resources/images/favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-194x194.png" sizes="194x194">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/resources/images/favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/resources/images/favicons/manifest.json"></head><body ng-controller="AppCtrl as appCtrl" class="l-offset-nav l-offset-side-nav"><md-toolbar scroll-y-offset-element="scroll-y-offset-element" class="main-nav background-regal l-pinned-top l-layer-5"><nav><h1><a href="/" md-button>Angular <sup>by Google</sup></a></h1><button aria-label="查看菜单" ng-click="appCtrl.toggleMainMenu($event)" md-button="md-button" class="main-nav-button main-nav-mobile-trigger l-right">网站菜单 <span class="icon icon-arrow-drop-down"></span></button><ul ng-class="appCtrl.showMainNav ? 'is-visible' : ''"><li class="l-left"><a class="main-nav-button" href="/features.html" md-button>特性</a></li><li class="l-left"><a class="main-nav-button" href="/docs/ts/latest/" md-button>文档</a></li><li class="l-left"><a class="main-nav-button" href="/events.html" md-button>会议</a></li><li class="l-left"><a class="main-nav-button" href="/news.html" md-button>新闻</a></li><li class="l-left"><a class="main-nav-button" href="/translate/cn/home.html" md-button>关于中文版</a></li><li class="l-right"><a class="main-nav-button" href="/docs/ts/latest/quickstart.html" md-button>立即开始！</a></li><li class="l-right"><a ng-click="appCtrl.toggleSource($event)" href="href" class="main-nav-button md-button ng-cloak"><span>{{appCtrl.sourceVisible?'Hide English':'Show English'}}</span></a></li></ul></nav></md-toolbar><!-- Include this file ONLY when current.path[2] is defined--><nav class="side-nav l-pinned-left l-layer-4 l-offset-nav"><!-- SEARCH BAR--><header class="side-nav-search st-input-wrapper"><form class="st-input-inner"><label for="search-io" class="is-hidden">搜索文档</label><input type="search" id="search-io" placeholder="搜索文档..."/></form><button aria-label="查看文档菜单" ng-click="appCtrl.toggleDocsMenu($event)" md-button="md-button" class="mobile-trigger button">文档 <span class="icon icon-arrow-drop-down"></span></button></header><div ng-class="appCtrl.showDocsNav ? 'is-visible' : ''" class="side-nav-secondary"><div class="nav-blocks"><a href="/docs/ts/latest/quickstart.html" title="Angular 2快速起步" class="nav-title ">快速起步</a></div><div class="nav-blocks"><a href="/docs/ts/latest/tutorial/" title="英雄指南教程带我们一步步使用TypeScript创建Angular应用。" class="nav-title ">教程<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/" title="英雄指南教程带我们一步步使用TypeScript创建Angular应用。" class="translated-cn">1. 简介</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt1.html" title="我们构建一个简单的英雄编辑器" class="translated-cn">2. 英雄编辑器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt2.html" title="我们构建一个主从结构的页面，用于展现英雄列表" class="translated-cn">3. 主从结构</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt3.html" title="我们把主从结构的页面重构成多个组件" class="translated-cn">4. 多个组件</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt4.html" title="我们创建一个可复用的服务来调用英雄的数据" class="translated-cn">5. 服务</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt5.html" title="我们添加一个Angular组件路由，并且学习在视图之间导航" class="translated-cn">6. 路由</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt6.html" title="把我们的服务和组件改为用Angular的HTTP服务实现" class="translated-cn">7. HTTP</a></li></ul></div></div><div class="nav-blocks"><a href="/docs/ts/latest/guide/" title="如何阅读本文档" class="nav-title ">基础知识<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/" title="如何阅读本文档" class="translated-cn">1. 概览</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/architecture.html" title="Angular 2应用的基本构造块" class="translated-cn">2. 架构</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/displaying-data.html" title="利用插值表达式和其它形式的属性绑定机制，把数据显示到UI上。" class="translated-cn">3. 显示数据</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/user-input.html" title="用户输入触发DOM事件。我们通过事件绑定来监听它们，把更新过的数据导入回我们的组件和model。" class="translated-cn">4. 用户输入</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/forms.html" title="表单创建一个有机、有效、引人注目的数据输入体验。Angular表单协调一组数据绑定控件，跟踪变更，验证输入的有效性，并且显示错误信息。" class="translated-cn">5. 表单</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/dependency-injection.html" title="Angular的依赖注入系统能够JIT(刚好及时)的创建和交付所依赖的服务。" class="translated-cn">6. 依赖注入</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/template-syntax.html" title="学习如何写模板来显示数据，以及在数据绑定的帮助下响应用户事件。" class="translated-cn">7. 模板语法</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/cheatsheet.html" title="一份Angular语法的快速指南" class="translated-cn">8. Angular小抄</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/style-guide.html" title="如何写Angular2风格的程序" class="translated-cn">9. 风格指南</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/glossary.html" title="Angular 2重要词汇的简短定义。" class="translated-cn">10. 词汇表</a></li></ul></div></div><div class="nav-blocks"><a href="/docs/ts/latest/guide/ngmodule.html" title="用@NgModule定义应用中的模块" class="nav-title ">开发指南<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/ngmodule.html" title="用@NgModule定义应用中的模块" class="translated-cn">Angular模块（NgModule）</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/animations.html" title="Angular动画系统指南。" class="translated-cn">动画</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/attribute-directives.html" title="属性型指令把行为添加到现有元素上。" class="translated-cn">属性型指令</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/browser-support.html" title="浏览器支持与填充（Polyfill）指南" class="translated-cn">浏览器支持</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/component-styles.html" title="学习如何给组件应用CSS样式。" class="translated-cn">组件样式</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/hierarchical-dependency-injection.html" title="Angular的多级依赖注入系统支持与组件树并行的嵌套式注入器。" class="translated-cn">多级注入器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/server-communication.html" title="通过HTTP客户端与远程服务器对话。" class="translated-cn">HTTP客户端</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/lifecycle-hooks.html" title="Angular调用指令和组件的生命周期钩子函数，包括它的创建、变更和销毁时。" class="translated-cn">生命周期钩子</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/npm-packages.html" title="推荐的npm包以及如何指定所依赖的包" class="translated-cn">Npm包</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/pipes.html" title="管道可以在模板中转换显示的内容。" class="translated-cn">管道</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/router.html" title="揭示如何通过Angular 2路由进行基本的屏幕导航。" class="translated-cn">路由与导航</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/security.html" title="开发“内容安全”的Angular应用。" class="translated-cn">安全</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/structural-directives.html" title="Angular有一个强力的模板引擎，它能让你轻松维护元素的DOM树结构。" class="translated-cn">结构型指令</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/testing.html" title="Angular 2应用的测试技术与实践。" class="translated-cn">测试</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/typescript-configuration.html" title="Angular 2开发者的TypeScript配置" class="translated-cn">TypeScript配置</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/upgrade.html" title="Angular 1应用可以逐步升级到Angular 2。" class="translated-cn">从1.x升级</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/webpack.html" title="使用基于Webpack的工具创建Angular 2应用" class="translated-cn">Webpack简介</a></li></ul></div></div><div class="nav-blocks"><a href="/docs/ts/latest/cookbook/" title="一组常见Angular应用场景的“烹饪宝典”" class="nav-title ">烹饪宝典<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/" title="一组常见Angular应用场景的“烹饪宝典”" class="translated-cn">概览</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/a1-a2-quick-reference.html" title="学习如何把Angular 1中的概念和技术对应到Angular 2中" class="translated-cn">Angular从1到2快速参考</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ngmodule-faq.html" title="对@NgModule常见问题的解答" class="translated-cn">Angular模块常见问题</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-communication.html" title="在不同的指令和组件之间共享信息" class="translated-cn">组件通讯</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-relative-paths.html" title="为组件的模板和样式指定相对于组件的路径" class="translated-cn">相对于组件的路径</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dependency-injection.html" title="依赖注入技术" class="translated-cn">依赖注入</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dynamic-form.html" title="用FormGroup渲染动态表单" class="translated-cn">动态表单</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/form-validation.html" title="验证用户在表单中的输入" class="translated-cn">表单验证</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/rc4-to-rc5.html" title="分分钟把RC4迁移到RC5" class="translated-cn">如何从RC4迁移到RC5</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/set-document-title.html" title="使用Title服务来设置文档标题或窗口标题" class="translated-cn">设置文档标题</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ts-to-js.html" title="把Angular 2的TypeScript范例转换为ES5 JavaScript" class="translated-cn">从TypeScript到JavaScript</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/visual-studio-2015.html" title="使用Visual Studio 2015快速开始" class="translated-cn">Visual Studio 2015快速开始</a></li></ul></div></div><div class="nav-blocks"><a href="/docs/ts/latest/api/" title="API参考手册" class="translated-cn nav-title ">API参考手册</a></div></div></nav><script>// Could put in appCtrl but only needed here and clear here
(function scrollToSelectedLink() {
  var sideNav = document.getElementsByClassName('side-nav')[0];
  var link = sideNav.getElementsByClassName('is-selected')[0];
  if (link && link.offsetTop > window.innerHeight) {
    sideNav.scrollTop = link.offsetTop - (window.innerHeight / 2);
    //alert("offsetTop: " + link.offsetTop + " side-nav top is " + sideNav.scrollTop);
  }
})()</script><!-- template: public/_includes/_hero--><header style="" class="hero background-sky"><div class="inner-header"><h1 class="hero-title text-display-1 translated-cn ">应用的第一个测试</h1><span class="badges"></span></div><!-- DROPDOWN BUTTON --><nav class="dropdown"><button aria-label="选择Angular版本" md-button="md-button" ng-click="appCtrl.toggleVersionMenu($event)" class="dropdown-button">Angular 2 for TypeScript  <span class="icon icon-arrow-drop-down"></span></button><div ng-click="appCtrl.toggleVersionMenu($event)" ng-show="appCtrl.showMenu" class="overlay ng-hide"></div><!-- DROPDOWN MENU --><div ng-class="appCtrl.showMenu ? 'is-visible' : ''" class="dropdown-menu"><ul><li><a href="/docs/ts/latest/testing/first-app-tests.html" md-button>Angular 2 for TypeScript </a></li></ul><ul><li><a href="/docs/js/latest/testing/first-app-tests.html" md-button>Angular 2 for JavaScript </a></li></ul><ul><li><a href="/docs/dart/latest/testing/first-app-tests.html" md-button>Angular 2 for Dart </a></li></ul></div></nav></header><div class="banner"><p class="text-body translated-cn">首先测试应用中一个简单的、与Angular无关的部分</p></div><article class="l-content-small grid-fluid docs-content"><div class="c10"><div class="showcase"><div class="showcase-content"><script>function why(id, backTo) {
  var id = "#"+id;
  var el = document.querySelector(id);
  el.hidden=el.hidden=!el.hidden;

  if (el.hidden && backTo){
    // the next line is required to work around a bug in WebKit (Chrome / Safari)
    location.href = "#";
    location.href =  "#" + backTo;
  }
}</script><script>function verbose(isVerbose) {
  isVerbose = !! isVerbose;
  var el = document.querySelector('button.verbose.off');
  el.style.display = isVerbose ? 'block' : 'none';
  var el = document.querySelector('button.verbose.on');
  el.style.display = isVerbose ? 'none' : 'block';

  CCSStylesheetRuleStyle('main','.l-verbose-section', 'display',
    isVerbose ? 'block' : 'none');
}
</script><script>function CCSStylesheetRuleStyle(stylesheet, selectorText, style, value){
  /* returns the value of the element style of the rule in the stylesheet
  *  If no value is given, reads the value
  *  If value is given, the value is changed and returned
  *  If '' (empty string) is given, erases the value.
  *  The browser will apply the default one
  *
  * string stylesheet: part of the .css name to be recognized, e.g. 'default'
  * string selectorText: css selector, e.g. '#myId', '.myClass', 'thead td'
  * string style: camelCase element style, e.g. 'fontSize'
  * string value optional : the new value
  */
  var CCSstyle = undefined, rules, sheet;
  for(var m in document.styleSheets){
    sheet = document.styleSheets[m];
    if(sheet.href && sheet.href.indexOf(stylesheet) != -1){
    rules = sheet[document.all ? 'rules' : 'cssRules'];
    for(var n in rules){
      console.log(rules[n].selectorText);
      if(rules[n].selectorText == selectorText){
        CCSstyle = rules[n].style;
        break;
      }
    }
    break;
    }
  }
  if(value == undefined)
    return CCSstyle[style]
  else
    return CCSstyle[style] = value
}
</script><p>In this chapter we&#39;ll setup the environment for testing our sample application and write a few easy Jasmine tests of the app&#39;s simplest parts.</p>
<p>本章中，我们将为范例应用设置测试环境，并针对应用程序中最简单的部分，写几个容易点的Jasmine测试。</p>
<p>We&#39;ll learn:</p>
<p>我们会学到：</p>
<ul>
<li><p>to test one of our application files</p>
</li>
<li><p>测试我们应用程序中的一个文件</p>
</li>
<li><p>why we prefer our test files to be next to their corresponding source files</p>
</li>
<li><p>为什么我们更喜欢把测试文件放在它对应的源码旁边</p>
</li>
<li><p>to run tests with an <code>npm</code> command</p>
</li>
<li><p>用<code>npm</code>命令运行测试</p>
</li>
<li><p>load the test file with SystemJS</p>
</li>
<li><p>使用SystemJs加载测试文件</p>
</li>
</ul>
<div class="callout is-helpful"><header>Prior Knowledge</header><header>预备知识</header><p>The Unit Testing chapters build upon each other. We recommend reading them in order.
We&#39;re also assuming that you&#39;re already comfortable with basic Angular 2 concepts and the tools
we introduced in the <a href="../quickstart.html">QuickStart</a> and
the <a href="../tutorial/">Tour of Heroes</a> tutorial
such as <code>npm</code>, <code>gulp</code>, and <code>lite-server</code>.</p>
<p>这一章单元测试是在其它章节的基础上写的。我们建议你按顺序阅读它们。同时，我们假设你已经对Angular 2的原理、<a href="../quickstart.html">“快速起步”</a>和
<a href="../tutorial">英雄指南</a>中介绍的<code>npm</code>、<code>gulp</code>和<code>lite-server</code>等工具都已经有所了解。</p>
</div><div class="l-main-section"></div><h2 id="create-the-test-runner-html">Create the test-runner HTML</h2>
<h2 id="-test-runner-html">创建测试运行器(test-runner)HTML</h2>
<p>Locate the folder that contains the application <code>index.html</code> for your testing copy of Tour of Heroes.</p>
<p>在《英雄指南》的测试拷贝版里找到含有<code>index.html</code>的目录。</p>
<p>Create a new, sibling HTML file, <strong> <code>unit-tests.html</code> </strong> and copy over the same basic material from the  <code>unit-tests.html</code> in the <a href="./jasmine-testing-101.html">Jasmine 101</a> chapter.</p>
<p>新建一个同级的HTML文件<strong><code>unit-tests.html</code></strong>，从<a href="./jasmine-testing-101.html">Jasmine 101</a>一章中，将<code>unit-tests.html</code>里面的基本素材拷贝进该文件。</p>
<div class="example-title">unit-tests.html</div><code-example language="html" format="linenums">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
  &lt;title&gt;Ng App Unit Tests&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../node_modules/jasmine-core/lib/jasmine-core/jasmine.css&quot;&gt;

  &lt;script src=&quot;../node_modules/jasmine-core/lib/jasmine-core/jasmine.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../node_modules/jasmine-core/lib/jasmine-core/boot.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;/body&gt;

&lt;/html&gt;
</code-example><p>We&#39;re picking up right where we left off. All we&#39;ve done is change the title.</p>
<p>我们把上次的重点作为起点。那时我们只修改完了标题。</p>
<div class="l-main-section"></div><h2 id="update-package-json-for-testing">Update <code>package.json</code> for testing</h2>
<h2 id="-package-json-">为做测试更新<code>package.json</code></h2>
<p>We must install the Jasmine package as well:</p>
<p>我们还必须安装Jasmine包：</p>
<pre class="prettyprint lang-bash"><code>npm install jasmine-core --save-dev --save-exact</code></pre><div class="alert is-important">Be sure to install <code>jasmine-core</code> , not <code>jasmine</code>!</div><div class="alert is-important">请确保安装的是<code>jasmine-core</code>，而不是<code>jasmine</code>！</div><div class="l-main-section"></div><h2 id="configure-lite-server-for-serving-our-test-harness">Configure <code>lite-server</code> for serving our test harness</h2>
<h2 id="-lite-server-">配置<code>lite-server</code>来提供测试环境</h2>
<p>First create a configuration file for serving up our test harness through <code>lite-server</code>.</p>
<p>首先为用来提供测试环境的<code>lite-server</code>创建一个配置文件。</p>
<div class="example-title">liteserver-test-config.json</div><code-example language="json" format="linenums">{
    &quot;startPath&quot;: &quot;unit-tests.html&quot;
}
</code-example><p>Let&#39;s make one more change to the <code>package.json</code> script commands.</p>
<p>让我们在<code>package.json</code>的脚本命令区再做一项修改。</p>
<p><strong>Open the <code>package.json</code> </strong> and scroll to the <code>scripts</code> node and add the following two entries:</p>
<p><strong>打开<code>package.json</code></strong>，滚动到<code>scripts</code>节点，添加下面两行：</p>
<code-example format="">"lite-server-test": "lite-server --config=liteserver-test-config.json",
"test": "tsc && concurrently \"npm run tsc:w\" \"npm run lite-server-test\" "
</code-example><p>The <code>npm test</code> command will launch <code>lite-server</code> and open a browser to the <code>unit-tests.html</code> page we just wrote. It will also take care of recompiling your source code and reloading your browser after any change.</p>
<p>这条<code>npm test</code>命令将启动<code>lite-server</code>，并在浏览器中打开我们刚写的<code>unit-tests.html</code>页面。它还会在做出任何更改之后重新编译源代码，并刷新浏览器。</p>
<div class="l-main-section"></div><h2 id="first-app-tests">First app tests</h2>
<h2 id="-">第一个应用程序测试</h2>
<p>We can start testing <em>some</em> of our app right away. For example, we can test the <code>Hero</code> interface:</p>
<p>我们现在可以开始测试应用程序中的<em>某些</em>代码了。比如，我们可以测试<code>Hero</code>接口：</p>
<code-example language="ts" format="linenums">export class Hero {
  id: number;
  name: string;
}
</code-example><p>Let&#39;s add a couple of simple tests in a new file.</p>
<p>让我们在一个新文件里面添加一些简单的测试。</p>
<code-example language="ts" format="linenums">import { Hero } from &#39;./hero&#39;;

describe(&#39;Hero&#39;, () =&gt; {

  it(&#39;has name&#39;, () =&gt; {
    let hero: Hero = {id: 1, name: &#39;Super Cat&#39;};
    expect(hero.name).toEqual(&#39;Super Cat&#39;);
  });

  it(&#39;has id&#39;, () =&gt; {
    let hero: Hero = {id: 1, name: &#39;Super Cat&#39;};
    expect(hero.id).toEqual(1);
  });
});
</code-example><p>That&#39;s the basic Jasmine we learned back in &quot;Jasmine 101&quot;.</p>
<p>上面是我们在“Jasmine 101”学习的基本Jasmine知识。</p>
<p>Notice that we surrounded our tests with <strong> <code>describe(&#39;Hero&#39;)</code> </strong>.</p>
<p>请注意，我们把这些测试包裹在<strong><code>describe(&#39;Hero&#39;)</code></strong>中了。</p>
<p><strong>By convention, our test always begin with a <code>describe</code> that identifies the application part under test.</strong></p>
<p><strong>按惯例，我们的测试总会以<code>describe</code>开始，它标识出所测的是应用程序的哪个部分。</strong></p>
<p>The description should be sufficient to identify the tested application part and its source file.
Almost any convention will do as long as you and your team follow it consistently and are never confused.</p>
<p>这个说明要足以标识出所测的部件和相关源码。无论采用什么约定，都应该让你和你的团队始终如一的遵循它，并且永不混淆它们。</p>
<p>But we haven&#39;t saved this test yet.</p>
<p>不过，我们现在还没保存这个测试呢。</p>
<div class="l-main-section"></div><h2 id="where-do-tests-go-">Where do tests go?</h2>
<h2 id="-">测试文件放在哪里？</h2>
<p>Some people like to keep their tests in a <code>tests</code> folder parallel to the application source folder.</p>
<p>有人喜欢把他们的测试保存在与应用程序源码平级的<code>tests</code>目录下。</p>
<p>We are not those people. We like our unit tests to be close to the source code that they test. We prefer this approach because</p>
<p>但我们不喜欢。我们更喜欢让这些单元测试放得离它们要测的源码尽可能近一点。我们更喜欢这种方式是因为：</p>
<ul>
<li><p>The tests are easy to find</p>
</li>
<li><p>更容易找到测试</p>
</li>
<li><p>We see at a glance if an application part lacks tests.</p>
</li>
<li><p>我们只要扫一眼就能知道应用程序中哪部分缺少测试</p>
</li>
<li><p>Nearby tests can teach us about how the part works; they express the developers intention and reveal how the developer thinks the part should behave under a variety of circumstances.</p>
</li>
<li><p>附近的测试能告诉我们这部分是如何工作的，它们能表达开发者的意图，并揭示出开发者认为在各种情况下这部分该有怎样的行为。</p>
</li>
<li><p>When we move the source (inevitable), we remember to move the test.</p>
</li>
<li><p>当我们移动源码时(难免的)，总能记得同时移动测试。</p>
</li>
<li><p>When we rename the source file (inevitable), we remember to rename the test file.</p>
</li>
<li><p>当我们重命名源码文件时(难免的)，总能记得同时改名测试文件。</p>
</li>
</ul>
<p>We can&#39;t think of a downside. The server doesn&#39;t care where they are.  They are easy to find and distinguish from application files when named conventionally.</p>
<p>我们想不到有什么负面效果。服务器不在乎它们放在哪里。如果按照约定命名它们，它们也很容易从应用本身的文件中找到和区分出来。</p>
<div class="l-sub-section"><p>You may put your tests elsewhere if you wish.
We&#39;re putting ours inside the app, next to the source files that they test.</p>
<p>如果喜欢，你也可以自己的测试放在其它地方。
反正我们是把它们放进了我们的应用代码中，紧跟着它们所要测试的源码文件。</p>
</div><div class="l-main-section"></div><h2 id="first-spec-file">First spec file</h2>
<h2 id="-">第一个规约文件</h2>
<p><strong>Create</strong> a new file, <strong> <code>hero.spec.ts</code> </strong> in <code>app</code> next to <code>hero.ts</code>.</p>
<p>在<code>app</code>下，紧挨着<code>hero.ts</code>，<strong>创建</strong>一个名叫<code>hero.spec.ts</code>的新文件。</p>
<p>Notice the &quot;.spec&quot; suffix in the test file&#39;s filename, appended to the name of the file holding the application part we&#39;re testing.</p>
<p>注意，测试文件名称中的“.spec”后缀，被追加到了被测试的应用程序部件的基本名后面。</p>
<div class="alert is-important"> <p>All of our unit test files follow this .spec naming pattern.</p>
<p>我们所有的单元测试文件都遵循了这种.spec命名模式。</p>
</div><p>Save the tests we just made in <code>hero.spec.ts</code>:</p>
<p>把测试保存到我们刚新建的<code>hero.spec.ts</code>文件：</p>
<code-example language="ts" format="linenums">import { Hero } from &#39;./hero&#39;;

describe(&#39;Hero&#39;, () =&gt; {

  it(&#39;has name&#39;, () =&gt; {
    let hero: Hero = {id: 1, name: &#39;Super Cat&#39;};
    expect(hero.name).toEqual(&#39;Super Cat&#39;);
  });

  it(&#39;has id&#39;, () =&gt; {
    let hero: Hero = {id: 1, name: &#39;Super Cat&#39;};
    expect(hero.id).toEqual(1);
  });
});
</code-example><h3 id="import-the-part-we-re-testing">Import the part we&#39;re testing</h3>
<h3 id="-">导入我们准备测试的部件</h3>
<p>We have an <code>import {Hero} from &#39;./hero&#39;</code> statement.</p>
<p>这里我们有个<code>import {Hero} from &#39;./hero&#39;</code>语句。</p>
<p>If we forgot this import, a TypeScript-aware editor would warn us, with a squiggly red underline, that it can&#39;t find the definition of the <code>Hero</code> interface.</p>
<p>如果我们忘记了这条导入语句，支持TypeScript的编辑器就会通过一个红色曲线警告我们：它找不到<code>Hero</code>接口的定义。</p>
<h3 id="update-unit-tests-html">Update unit-tests.html</h3>
<h3 id="-unit-tests-html">更新unit-tests.html</h3>
<p>Next we update the <code>unit-tests.html</code> with a reference to our new <code>hero.spec.ts</code> file. Delete the inline test code.  The revised pertinent HTML looks like this:</p>
<p>接下来我们在<code>unit-tests.html</code>中用一个到这个新的<code>hero.spec.ts</code>文件的引用代替原来的内联测试代码。
修改过的HTML看起来是这样的：</p>
<code-example language="html" format="">&lt;script src=&quot;app/hero.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;app/hero.spec.js&quot;&gt;&lt;/script&gt;
</code-example><h3 id="run-and-fail">Run and Fail</h3>
<h3 id="-">运行，并失败</h3>
<p>Look over at the browser (lite-server will have reloaded it).  The browser displays</p>
<p>看看浏览器(lite-server应该已经刷新了它)。其中显示的是：</p>
<figure class="image-display"><img src="/resources/images/devguide/first-app-tests/Jasmine-not-running-tests.png" style="width:400px" alt="Jasmine not running any tests"></figure><p>That&#39;s Jasmine saying &quot;<strong>things are <em>so</em> bad that <em>I&#39;m not running any tests</em>.</strong>&quot;</p>
<p>这是Jasmine在说“<strong>事情<em>很糟</em>，因为<em>我没找到任何测试</em>。</strong>”</p>
<p>Open the browser&#39;s Developer Tools (F12, Ctrl-Shift-i). There&#39;s an error:</p>
<p>打开浏览器开发工具(F12或Ctrl-Shift-I)就会看到一个错误：</p>
<code-example format="" language="html">Uncaught ReferenceError: System is not defined
</code-example><div class="l-main-section"></div><h2 id="load-tests-with-systemjs">Load tests with SystemJS</h2>
<h2 id="-systemjs-">使用SystemJS加载这些测试</h2>
<p>The immediate cause of the error is the <code>export</code> statement in <code>hero.ts</code>.
That error was there all along.
It wasn&#39;t a problem until we tried to <code>import</code> the <code>Hero</code> interface in our tests.</p>
<p>导致这个错误的直接原因，就是<code>hero.ts</code>中的<code>export</code>语句。
那个错误一直都存在。
除非我们尝试把<code>Hero</code>接口<code>import</code>到测试中，否则这个问题会一直存在。</p>
<p>Our test environment lacks support for module loading.
Apparently we can&#39;t simply load our application and test scripts like we do with 3rd party JavaScript libraries.</p>
<p>我们的测试环境中缺少了对模块加载的支持。
显然，我们没法像使用第三方JavaScript库那样简单的加载起应用代码和测试脚本。</p>
<p>We are committed to module loading in our application.
Our app will call <code>import</code>.  Our tests must do so too.</p>
<p>我们得在本应用中引入模块加载机制。
我们在应用代码中要调用<code>import</code>，测试代码中也要如此。</p>
<p>We add module loading support in four steps:</p>
<p>我们要通过四步来添加对模块加载的支持。</p>
<ol>
<li><p>add the <em>SystemJS</em> module management library</p>
</li>
<li><p>添加<em>SystemJS</em>模块管理库</p>
</li>
<li><p>configure <em>SystemJS</em> to look for JavaScript files by default</p>
</li>
<li><p>配置<em>SystemJS</em>来默认查找JavaScript文件</p>
</li>
<li><p>import our test files</p>
</li>
<li><p>导入我们的测试文件</p>
</li>
<li><p>tell Jasmine to run the imported tests</p>
</li>
<li><p>让Jasmine运行已导入的测试</p>
</li>
</ol>
<p>These steps are all clearly visible, in exactly that order, in the following lines that
replace the <code>&lt;body&gt;</code> contents in <code>unit-tests.html</code>:</p>
<p>在<code>unit-tests.html</code>中用于替换<code>&lt;body&gt;</code>内容的那些代码行中，这些步骤清晰可见：</p>
<code-example language="html" format="">&lt;body&gt;
  &lt;!-- #1. add the system.js library --&gt;
  &lt;script src=&quot;../node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;

  &lt;script&gt;
    // #2. Configure systemjs to use the .js extension
    //     for imports from the app folder
    System.config({
      packages: {
        &#39;app&#39;: {defaultExtension: &#39;js&#39;}
      }
    });

    // #3. Import the spec file explicitly
    System.import(&#39;app/hero.spec&#39;)

      // #4. wait for all imports to load ...
      //     then re-execute `window.onload` which
      //     triggers the Jasmine test-runner start
      //     or explain what went wrong.
      .then(window.onload)
      .catch(console.error.bind(console));
  &lt;/script&gt;
&lt;/body&gt;
</code-example><p>Look in the browser window. Our tests pass once again.</p>
<p>到浏览器窗口中看看，我们的测试又一次通过了。</p>
<figure class="image-display"><img src="/resources/images/devguide/first-app-tests/test-passed-once-again.png" style="width:400px" alt="Tests passed once again"></figure><div class="l-main-section"></div><h2 id="observations">Observations</h2>
<h2 id="-">回顾</h2>
<h3 id="system-config">System.config</h3>
<p>System.js demands that we specify a default extension for the filenames that correspond to whatever it is asked to import.
Without that default, it would translate an import statement such as <code>import {Hero} from &#39;./hero&#39;</code> to a request for the file named <code>hero</code>.
Not <code>hero.js</code>. Just plain <code>hero</code>.  Our server error with &quot;404 - not found&quot; because it doesn&#39;t have a file of that name.</p>
<p>System.js强烈要求我们为想import的那些文件指定一个默认扩展名。
如果没有默认扩展名，它就会把import语句翻译成<code>import {Hero} from &#39;./hero&#39;</code>来请求一个名叫<code>hero</code>的文件，而不是<code>hero.js</code>。服务器就会返回一个“404 - not found”，
因为它找不到那个不带扩展名的文件。</p>
<p>Once configured with a default extension of &#39;js&#39;,&nbsp;  SystemJS requests <code>hero.js</code> which <em>does</em> exist and is promptly returned by our server.</p>
<p>一旦把默认扩展名配置为&#39;js&#39;，SystemJS就会请求<code>hero.js</code>，它存在，并且立即被服务器成功返回。</p>
<h3 id="asynchronous-system-import">Asynchronous System.import</h3>
<h3 id="-system-import">异步System.import</h3>
<p>The call to <code>System.import</code> shouldn&#39;t surprise us but its asynchronous nature might.
If we ponder this for a moment, we realize that it must be asynchronous because
System.js may have to fetch the corresponding JavaScript file from the server.
Accordingly, <code>System.import</code> returns a promise and we must wait for that promise to resolve.
Only then can Jasmine start evaluating the imported tests.</p>
<p>对<code>System.import</code>的调用不会让我们感到意外 —— 除了它的异步性。
如果我们仔细考虑一会儿，就会认识到它必须是异步的，因为SystemJS不得不从服务器上取得相应的JavaScript文件。
因此，<code>System.import</code>会返回一个承诺(Promise)，我们得等待这个承诺被解决。
然后，Jasmine才能开始执行这些导入的测试。</p>
<h3 id="window-onload">window.onload</h3>
<p>Jasmine doesn&#39;t have a <code>start</code> method.  It wires its own start to the browser window&#39;s <code>load</code> event.
That makes sense if we&#39;re loading our tests with script tags.
The browser raises the <code>load</code> event when it finishes loading all scripts.</p>
<p>Jasmine没有一个<code>start</code>方法。它把自己的启动代码挂接到了浏览器窗口的<code>load</code>事件上。
如果我们通过<code>script</code>标签来启动测试，这样的设计自然很合理。
当浏览器加载完所有脚本时，它就会触发<code>load</code>事件。</p>
<p>But we&#39;re not loading test scripts inline anymore.
We&#39;re using the SystemJS module loader and it won&#39;t be done until long after the browser raised the <code>load</code> event.
Meanwhile, Jasmine started and ran to completion, with no tests to evaluate, before the import completed.</p>
<p>但我们没有用内联的方式加载测试脚本了。
我们在使用SystemJS模块加载器，除非浏览器触发了<code>load</code>事件，否则它什么也不会做。
同时，在这些import完成之前，Jasmine自己已经启动并且运行结束了，不过一个测试也没有执行。</p>
<p>So we must wait until the import completes and only then call the window <code>onLoad</code> handler.
Jasmine re-starts, this time with our imported test queued up.</p>
<p>所以我们必须等待import执行完，然后才调用window的<code>onLoad</code>处理器。
Jasmine重新启动，但这次它带着我们导入的这个测试队列。</p>
<div class="l-main-section"></div><h2 id="what-s-next-">What&#39;s Next?</h2>
<h2 id="-">下一步呢？</h2>
<p>We are able to test a part of our application with simple Jasmine tests.
The part was a stand-alone interface that made no mention or use of Angular.</p>
<p>我们已经能用简单的Jasmine测试来测试应用的一部分。
这部分是一个独立的接口，它没有引用或使用任何来自Angular的东西。</p>
<p>That&#39;s not rare but it&#39;s not typical either.
Most of our application parts make some use of the Angular framework.
Let&#39;s test a <em>pipe</em> class that does rely on Angular.</p>
<p>这虽然不算罕见，但也不够典型。
我们应用程序中的大部分都会使用到Angular框架的某些东西。
我们再来测试一个<em>管道</em>类，它依赖于Angular。</p></div></div></div></article><div class="main-footer"><nav class="background-blue-grey-900 grid-fluid"><div class="c3 main-footer-branding"><div class="logo-inverse-large"></div></div><div class="c2"><h3 class="text-headline">RESOURCES</h3><h3 class="text-headline">资源库</h3><ul class="text-body"><!-- TODO: (ericjim) make a libraries page to showcase all angular 2 libraries--><!--li <a href="/libraries.html">Libraries</a>--><li><a href="/about/">About</a></li><li><a href="/about/">关于</a></li><li><a href="/resources/">Books & Training</a></li><li><a href="/resources/">书籍与培训</a></li><li><a href="/resources/">Tools & Libraries</a></li><li><a href="/resources/">工具与库</a></li><li><a href="/resources/">Community</a></li><li><a href="/resources/">社区</a></li><li><a href="/presskit.html">Press Kit</a></li><li><a href="/presskit.html">宣传资料</a></li></ul></div><div class="c2"><h3 class="text-headline">HELP</h3><h3 class="text-headline">帮助</h3><ul class="text-body"><li><a href="http://stackoverflow.com/questions/tagged/angular2">Stack Overflow</a></li><li><a href="http://stackoverflow.com/questions/tagged/angular2">Stack Overflow</a></li><li><a href="https://gitter.im/angular/angular">Gitter</a></li><li><a href="https://gitter.im/angular/angular">Gitter</a></li><li><a href="https://groups.google.com/forum/#!forum/angular"> Google Group</a></li><li><a href="https://groups.google.com/forum/#!forum/angular"> Google Group</a></li><li><a href="https://github.com/angular/angular/issues"> Report Issues</a></li><li><a href="https://github.com/angular/angular/issues"> 报告问题</a></li><li><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> Site Feedback</a></li><li><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> 网站反馈</a></li></ul></div><div class="c2"><h3 class="text-headline">COMMUNITY</h3><h3 class="text-headline">社区</h3><ul class="text-body"><li><a href="/events.html">Events</a></li><li><a href="/events.html">会议</a></li><li><a href="http://www.meetup.com/topics/angularjs/">Meetups</a></li><li><a href="http://www.meetup.com/topics/angularjs/">Meetups</a></li><li><a href="https://twitter.com/angularjs"> Twitter</a></li><li><a href="https://twitter.com/angularjs"> Twitter</a></li><li><a href="https://github.com/angular/angular"> GitHub</a></li><li><a href="https://github.com/angular/angular"> GitHub</a></li><li><a href="/contribute.html"> Contribute</a></li><li><a href="/contribute.html"> 做贡献</a></li></ul></div><div class="c2"><h3 class="text-headline">LANGUAGES</h3><h3 class="text-headline">其它语种</h3><ul class="text-body"><li><a href="https://angular.io/" target="_blank">English</a></li></ul></div></nav><footer class="background-steel"><p><small class="text-caption">Powered by Google ©2010-2016. Code licensed under an <a href="/license" class="text-snow">MIT-style License</a>. Documentation licensed under <a class="text-snow" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</small></p><p><small class="text-caption translated-cn">Powered by Google ©2010-2016. 代码授权协议：<a href="/license" class="text-snow">MIT式协议</a>。 文档授权协议：<a class="text-snow" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</small></p><a aria-label="View Style Guide" href="/docs/ts/latest/styleguide.html" title="Style Guide" md-button="md-button" class="styleguide-trigger text-snow"><span class="icon-favorite"></span></a><a aria-label="查看风格指南" href="/docs/ts/latest/styleguide.html" title="风格指南" md-button="md-button" class="styleguide-trigger text-snow translated-cn"><span class="icon-favorite"></span></a><p> <small class="text-caption">本网站由洛阳永欣维护 &nbsp;<a href="http://www.miitbeian.gov.cn/">豫ICP备16019859号-1</a></small></p></footer></div><!-- VENDORS --><script src="/resources/js/vendor/prettify.js"></script><script src="/resources/js/vendor/lang-basic.js"></script><script src="/resources/js/vendor/lang-dart.js"></script><script src="/resources/js/vendor/lodash.js"></script><script src="/resources/js/vendor/clipboard.min.js"></script><!-- Angular Material Dependencies --><script src="/resources/js/vendor/angular.min.js"></script><script src="/resources/js/vendor/angular-animate.min.js"></script><script src="/resources/js/vendor/angular-aria.min.js"></script><script src="/resources/js/vendor/angular-material.min.js"></script><!-- Firebase -->
<script src="/resources/js/vendor/firebase.js"></script>
<!-- AngularFire -->
<script src="/resources/js/vendor/angularfire.min.js"></script>
<!-- Angular.io Site JS --><script src="/translate/cn/translate.js"></script><script src="/resources/js/site.js"></script><script src="/resources/js/util.js"></script><script src="/resources/js/controllers/app-controller.js"></script><script src="/resources/js/controllers/resources-controller.js"></script><script src="/resources/js/directives/cheatsheet.js"></script><script src="/resources/js/directives/api-list.js"></script><script src="/resources/js/directives/bio.js"></script><script src="/resources/js/directives/bold.js"></script><script src="/resources/js/directives/code.js"></script><script src="/resources/js/directives/copy.js"></script><script src="/resources/js/directives/code-tabs.js"></script><script src="/resources/js/directives/code-pane.js"></script><script src="/resources/js/directives/code-example.js"></script><script src="/resources/js/directives/if-docs.js"></script><script src="/resources/js/directives/live-example.js"></script><script src="/resources/js/directives/ngio-ex-path.js"></script><script src="/resources/js/directives/scroll-y-offset-element.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-80456300-1', 'auto');
ga('send', 'pageview');</script></body></html>