<!DOCTYPE html><html lang="en" ng-app="angularIOApp" itemscope itemtype="http://schema.org/Framework"><!-- template: public/docs/_layout--><head><title>测试 - ts - GUIDE</title><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="Angular是用于构建移动应用和桌面Web应用的开发平台"/><meta name="keywords" content="Angular, 中文, 中文版, AngularJS, AngularDart, Javscript, Dart, Framework, JavaScript MVC, Google"/><meta name="robots" content="all"/><meta name="referrer" content="origin"/><meta name="viewport" id="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Angular"/><meta property="og:image" content="/resources/images/logos/standard/shield-large.png"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="184"/><meta property="og:image:height" content="200"/><meta property="og:description" content="Angular是用于构建移动应用和桌面Web应用的开发平台"/><meta itemprop="name" content="Angular"/><meta itemprop="description" content="Angular是用于构建移动应用和桌面Web应用的开发平台"/><meta itemprop="image" content="/resources/images/logos/standard/shield-large.png"/><link rel="icon" type="image/x-icon" href="/resources/images/icons/favicon.ico"/><link rel="stylesheet" href="/resources/css/vendor/angular-material.min.css"/><link href="/resources/fonts/vendor/roboto.css" rel="stylesheet" type="text/css"/><link href="/resources/fonts/vendor/material-icons.css" rel="stylesheet"/><link rel="stylesheet" href="/resources/css/vendor/icomoon/style.css"/><link rel="stylesheet" href="/resources/css/vendor/animate.css"/><link rel="stylesheet" href="/resources/css/main.css"/><!-- MOBILE ICONS -->
<link rel="apple-touch-icon" sizes="57x57" href="/resources/images/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/resources/images/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/resources/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/resources/images/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/resources/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/resources/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/resources/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/resources/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/resources/images/favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-194x194.png" sizes="194x194">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/resources/images/favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/resources/images/favicons/manifest.json"></head><body ng-controller="AppCtrl as appCtrl" class="l-offset-nav l-offset-side-nav"><nav data-swiftype-index="false" scroll-y-offset-element="scroll-y-offset-element" class="main-nav l-pinned-top l-layer-5"><h1><a href="/" md-button>Angular <sup>by Google</sup></a></h1><button aria-label="查看菜单" ng-click="appCtrl.toggleMainMenu($event)" md-button="md-button" class="main-nav-button main-nav-mobile-trigger l-right">网站菜单 <span class="icon icon-arrow-drop-down"></span></button><ul ng-class="appCtrl.showMainNav ? 'is-visible' : ''"><li class="l-left"><a class="main-nav-button" href="/features.html" md-button>特性</a></li><li class="l-left"><a class="main-nav-button" href="/docs/ts/latest/" md-button>文档</a></li><li class="l-left"><a class="main-nav-button" href="/events.html" md-button>会议</a></li><li class="l-left"><a href="http://community.angular.cn/" target="_blank" md-button="md-button" class="main-nav-button">社区</a></li><li class="l-left"><a class="main-nav-button" href="/translate/cn/home.html" md-button>关于中文版</a></li><li class="l-right"><a class="main-nav-button" href="/docs/ts/latest/quickstart.html" md-button>立即开始！</a></li><li class="l-right"><a ng-click="appCtrl.toggleSource($event)" href="href" class="main-nav-button md-button ng-cloak"><span>{{appCtrl.sourceVisible?'Hide English':'Show English'}}</span></a></li></ul></nav><!-- Include this file ONLY when current.path[2] is defined--><nav data-swiftype-index="false" ng-class="appCtrl.showDocsNav ? 'is-visible' : ''" class="sidenav l-pinned-left l-layer-4 l-offset-nav"><!-- SEARCH BAR--><header class="sidenav-search st-input-wrapper"><div class="st-input-inner"><label for="search-io" class="is-hidden">搜索文档</label><input type="text" placeholder="搜索文档..." class="st-default-search-input"/></div><button aria-label="View Docs Menu" ng-click="appCtrl.toggleDocsMenu($event)" md-button="md-button" class="mobile-trigger button">文档 <span class="icon icon-arrow-drop-down"></span></button></header><ul class="sidenav-links"><li class="sidenav-section no-border"><a href="/docs/ts/latest/" class="nav-title">文档首页</a></li><!-- CORE DOCUMENTATION--><li class="sidenav-section-divider"><h3>核心文档</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/quickstart.html" title="快速起步" class="nav-title ">快速起步</a></li><li class="sidenav-section"><a href="/docs/ts/latest/cli-quickstart.html" title="使用 CLI 快速构建 Angular 应用" class="nav-title ">CLI 快速起步</a></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/" title="如何阅读本文档" class="nav-title is-parent ">开发指南<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/" title="如何阅读本文档">1. 概览</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/setup.html" title="安装 Angular 《快速起步》种子，更快更有效地在本地开发应用">2. 开发环境</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/learning-angular.html" title="Angular 初学者的推荐学习路径">3. 学习 Angular</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/architecture.html" title="Angular 应用的基本构造块">4. 架构</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/appmodule.html" title="如何在根 &quot;AppModule&quot; 中构建和启动应用。">5. 根模块</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/displaying-data.html" title="属性绑定机制把数据显示到用户界面上。">6. 显示数据</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/user-input.html" title="用户输入触发 DOM 事件。我们通过事件绑定来监听它们，把更新过的数据导入回我们的组件和 model。">7. 用户输入</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/forms.html" title="表单创建一个有机、有效、引人注目的数据输入体验。Angular 表单协调一组数据绑定控件，跟踪变更，验证输入的有效性，并且显示错误信息。">8. 表单</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/dependency-injection.html" title="Angular 的依赖注入系统能够即时地创建和交付所依赖的服务。">9. 依赖注入</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/template-syntax.html" title="学习如何写模板来显示数据，以及在数据绑定的帮助下响应用户事件。">10. 模板语法</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/cheatsheet.html" title="速查表">11. 速查表</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/style-guide.html" title="如何写 Angular 风格的程序">12. 风格指南</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/glossary.html" title="Angular 中最重要的词汇的简要定义">13. 词汇表</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/change-log.html" title="最新文档更新历史记录。">14. 更新记录</a></li></ul></div></li><li class="sidenav-section no-border"><a href="/docs/ts/latest/api/" title="API 参考手册" class="nav-title ">API参考手册</a></li><!-- ADVANCED DOCUMENATION--><li class="sidenav-section-divider"><h3>附加文档</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/tutorial/" title="英雄指南教程带我们一步步使用 TypeScript 创建 Angular 应用。" class="nav-title is-parent ">教程<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/" title="英雄指南教程带我们一步步使用 TypeScript 创建 Angular 应用。">1. 简介</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt1.html" title="构建一个简单的英雄编辑器">2. 英雄编辑器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt2.html" title="构建一个主从结构的页面，用于展现英雄列表">3. 主从结构</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt3.html" title="把主从结构的页面重构成多个组件">4. 多个组件</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt4.html" title="创建一个可复用的服务来调用英雄的数据">5. 服务</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt5.html" title="添加 Angular 组件路由，并且学习在视图之间导航">6. 路由</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt6.html" title="把服务和组件改为用 Angular 的 HTTP 服务实现">7. HTTP</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/animations.html" title="Angular 动画系统指南。" class="nav-title is-parent is-selected">高级文档<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/animations.html" title="Angular 动画系统指南。" class="translated-cn">动画</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/attribute-directives.html" title="属性型指令把行为添加到现有元素上。" class="translated-cn">属性型指令</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/browser-support.html" title="浏览器支持与填充 (Polyfill) 指南" class="translated-cn">浏览器支持</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/component-styles.html" title="学习如何给组件应用 CSS 样式。" class="translated-cn">组件样式</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/deployment.html" title="如何部署Angular应用。" class="translated-cn">部署</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/hierarchical-dependency-injection.html" title="Angular 的多级依赖注入系统支持与组件树并行的嵌套式注入器。" class="translated-cn">多级注入器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/reactive-forms.html" title="使用FormBuilder、组合数组创建响应式表单。" class="translated-cn">响应式表单</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/server-communication.html" title="通过 HTTP 客户端与远程服务器对话。" class="translated-cn">HTTP 客户端</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/lifecycle-hooks.html" title="Angular 调用指令和组件的生命周期钩子函数，包括它的创建、变更和销毁时。" class="translated-cn">生命周期钩子</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/ngmodule.html" title="用 @NgModule 定义应用中的模块" class="translated-cn">Angular模块 (NgModule)</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/npm-packages.html" title="推荐的 npm 包以及如何指定所依赖的包" class="translated-cn">npm 包</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/pipes.html" title="管道可以在模板中转换显示的内容。" class="translated-cn">管道</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/router.html" title="揭示如何通过 Angular 路由进行基本的屏幕导航。" class="translated-cn">路由与导航</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/security.html" title="开发内容安全的 Angular 应用。" class="translated-cn">安全</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/setup-systemjs-anatomy.html" title="解析 SystemJS 本地开发环境" class="translated-cn">搭建剖析</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/structural-directives.html" title="Angular 有一个强力的模板引擎，它能让你轻松维护元素的DOM树结构。" class="translated-cn">结构型指令</a></li><li class="nav-list-item is-selected"><a href="/docs/ts/latest/guide/testing.html" title="Angular 应用的测试技术与实践。" class="translated-cn">测试</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/typescript-configuration.html" title="Angular 开发者的 TypeScript 配置" class="translated-cn">TypeScript 配置</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/upgrade.html" title="AngularJS 应用可以逐步升级到 Angular。" class="translated-cn">从 AngularJS 升级</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/webpack.html" title="使用基于 Webpack 的工具创建 Angular 应用" class="translated-cn">Webpack 简介</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/cookbook/" title="一组常见 Angular 应用场景的“烹饪宝典”" class="nav-title is-parent ">烹饪宝典<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/" title="一组常见 Angular 应用场景的“烹饪宝典”" class="translated-cn">概览</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/aot-compiler.html" title="学习如何使用预编译器" class="translated-cn">预 (AoT) 编译器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ajs-quick-reference.html" title="学习如何把 AngularJS 中的概念和技术对应到 Angular 中" class="translated-cn">从 AngularJS 到 Angular</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-communication.html" title="在不同的指令和组件之间共享信息" class="translated-cn">组件通讯</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-relative-paths.html" title="为组件的模板和样式指定相对于组件的路径" class="translated-cn">相对于组件的路径</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dependency-injection.html" title="依赖注入技术" class="translated-cn">依赖注入</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dynamic-component-loader.html" title="如何动态加载组件" class="translated-cn">动态组件加载器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dynamic-form.html" title="用 FormGroup 渲染动态表单" class="translated-cn">动态表单</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/form-validation.html" title="验证用户在表单中的输入" class="translated-cn">表单验证</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/i18n.html" title="把应用的模板文本翻译成多种语言。" class="translated-cn">国际化 (i18n)</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ngmodule-faq.html" title="对 @NgModule 常见问题的解答" class="translated-cn">Angular 模块常见问题</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/set-document-title.html" title="使用 Title 服务来设置文档标题或窗口标题" class="translated-cn">设置文档标题</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ts-to-js.html" title="把 Angular 的 TypeScript 范例转换为 ES6 和 ES5 JavaScript." class="translated-cn">从 TypeScript 到 JavaScript</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/visual-studio-2015.html" title="使用 Visual Studio 2015 快速起步" class="translated-cn">Visual Studio 2015 快速起步</a></li></ul></div></li></ul><nav class="dropdown"><button aria-label="选择Angular版本" md-button="md-button" ng-click="appCtrl.toggleVersionMenu($event)" class="dropdown-button">Angular for TypeScript  <span class="icon icon-arrow-drop-down"></span></button><div ng-click="appCtrl.toggleVersionMenu($event)" ng-show="appCtrl.showMenu" class="overlay ng-hide"></div><ul ng-class="appCtrl.showMenu ? 'is-visible' : ''" class="dropdown-menu"><li><a href="/docs/ts/latest/guide/testing.html" md-button>Angular for TypeScript </a></li><li><a href="/docs/js/latest/guide/testing.html" md-button>Angular for JavaScript </a></li><li><a href="/docs/dart/latest/guide/testing.html" md-button>Angular for Dart </a></li></ul></nav></nav><script>// Could put in appCtrl but only needed here and clear here
(function scrollToSelectedLink() {
  var sideNav = document.getElementsByClassName('sidenav')[0];
  var link = sideNav.getElementsByClassName('is-selected')[0];
  if (link && link.offsetTop > window.innerHeight) {
    sideNav.scrollTop = link.offsetTop - (window.innerHeight / 2);
    //alert("offsetTop: " + link.offsetTop + " side-nav top is " + sideNav.scrollTop);
  }
})()</script><header class="hero background-sky"><h1 class="hero-title ">测试 </h1><div class="clear"></div></header><div class="banner"><p class="text-body translated-cn">Angular 应用的测试技术与实践。</p></div><article class="l-content-small grid-fluid docs-content"><script>function why(id, backTo) {
  var id = "#"+id;
  var el = document.querySelector(id);
  el.hidden=el.hidden=!el.hidden;

  if (el.hidden && backTo){
    // the next line is required to work around a bug in WebKit (Chrome / Safari)
    location.href = "#";
    location.href =  "#" + backTo;
  }
}</script><script>function verbose(isVerbose) {
  isVerbose = !! isVerbose;
  var el = document.querySelector('button.verbose.off');
  el.style.display = isVerbose ? 'block' : 'none';
  var el = document.querySelector('button.verbose.on');
  el.style.display = isVerbose ? 'none' : 'block';

  CCSStylesheetRuleStyle('main','.l-verbose-section', 'display',
    isVerbose ? 'block' : 'none');
}
</script><script>function CCSStylesheetRuleStyle(stylesheet, selectorText, style, value){
  /* returns the value of the element style of the rule in the stylesheet
  *  If no value is given, reads the value
  *  If value is given, the value is changed and returned
  *  If '' (empty string) is given, erases the value.
  *  The browser will apply the default one
  *
  * string stylesheet: part of the .css name to be recognized, e.g. 'default'
  * string selectorText: css selector, e.g. '#myId', '.myClass', 'thead td'
  * string style: camelCase element style, e.g. 'fontSize'
  * string value optional : the new value
  */
  var CCSstyle = undefined, rules, sheet;
  for(var m in document.styleSheets){
    sheet = document.styleSheets[m];
    if(sheet.href && sheet.href.indexOf(stylesheet) != -1){
    rules = sheet[document.all ? 'rules' : 'cssRules'];
    for(var n in rules){
      console.log(rules[n].selectorText);
      if(rules[n].selectorText == selectorText){
        CCSstyle = rules[n].style;
        break;
      }
    }
    break;
    }
  }
  if(value == undefined)
    return CCSstyle[style]
  else
    return CCSstyle[style] = value
}
</script><p>This guide offers tips and techniques for testing Angular applications.
Though this page includes some general testing principles and techniques,
the focus is on testing applications written with Angular.</p>
<p>本章提供了一些测试Angular应用的提示和技巧。虽然这里讲述了一些常规测试理念和技巧，但是其重点是测试用Angular编写的应用。</p>
<a id="top"></a><h1 id="contents">Contents</h1>
<h1 id="-">目录</h1>
<ul>
<li><p><a href="#live-examples" title="Live examples of the tests in this guide">Live examples</a></p>
<p><a href="#live-examples" title="本章这些测试的在线例子">在线例子</a></p>
</li>
<li><p><a href="#testing-intro">Introduction to Angular testing</a></p>
<p><a href="#testing-intro">Angular测试简介</a></p>
<ul>
<li><p><a href="#tools-and-tech">Tools and technologies</a></p>
<p><a href="#tools-and-tech">工具与技术</a></p>
</li>
<li><p><a href="#setup">Setup</a></p>
<p><a href="#setup">环境设置</a></p>
</li>
<li><p><a href="#isolated-v-testing-utilities">Isolated unit tests vs. the Angular testing utilities</a></p>
<p><a href="#isolated-v-testing-utilities">独立的单元测试 vs. Angular测试工具集</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#1st-karma-test">The first karma test</a></p>
<p><a href="#1st-karma-test">第一个Karma测试</a></p>
<ul>
<li><p><a href="#run-karma">Run with karma</a></p>
<p><a href="#run-karma">运行Karma</a></p>
</li>
<li><p><a href="#test-debugging">Test debugging</a></p>
<p><a href="#test-debugging">调试测试代码</a></p>
</li>
<li><p><a href="#live-karma-example">Try the live example</a></p>
<p><a href="#live-karma-example">试用在线例子</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#simple-component-test">Test a component</a></p>
<p><a href="#simple-component-test">测试一个组件</a></p>
<ul>
<li><p><a href="#testbed"><code>TestBed</code></a></p>
<p><a href="#testbed"><code>TestBed</code>（测试台）</a></p>
</li>
<li><p><a href="#create-component"><code>createComponent</code></a></p>
</li>
<li><p><a href="#component-fixture"><code>ComponentFixture</code>, <code>DebugElement</code>, and <code>query(By.css)</code></a></p>
<p><a href="#component-fixture"><code>ComponentFixture</code>, <code>DebugElement</code>, 和 <code>query(By.css)</code></a></p>
</li>
<li><p><a href="#the-tests">The tests</a></p>
<p><a href="#the-tests">测试</a></p>
</li>
<li><p><a href="#detect-changes"><code>detectChanges</code>: Angular change detection within a test</a></p>
<p><a href="#detect-changes"><code>detectChanges</code>: 在测试中控制Angular的变更检测</a></p>
</li>
<li><p><a href="#try-example">Try the live example</a></p>
<p><a href="#try-example">试试在线例子</a></p>
</li>
<li><p><a href="#auto-detect-changes">Automatic change detection</a></p>
<p><a href="#auto-detect-changes">自动变更检测</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#component-with-external-template">Test a component with an external template</a></p>
<p><a href="#component-with-external-template">测试带有外部模板的组件</a></p>
<ul>
<li><p><a href="#async-in-before-each">The first asynchronous <code>beforeEach</code></a></p>
<p><a href="#async-in-before-each">第一处异步代码：<code>beforeEach</code></a></p>
</li>
<li><p><a href="#compile-components"><code>compileComponents</code></a></p>
</li>
<li><p><a href="#second-before-each">The second synchronous <code>beforeEach</code></a></p>
<p><a href="#second-before-each">第二处同步代码：<code>beforeEach</code></a></p>
</li>
<li><p><a href="#waiting-compile-components">Waiting for <code>compileComponents</code></a></p>
<p><a href="#waiting-compile-components">等待 <code>compileComponents</code></a></p>
</li>
<li><p><a href="#live-external-template-example">Try the live example</a></p>
<p><a href="#live-external-template-example">试试在线例子</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#component-with-dependency">Test a component with a service dependency</a></p>
<p><a href="#component-with-dependency">测试依赖服务的组件</a></p>
<ul>
<li><p><a href="#service-test-doubles">Provide service test doubles</a></p>
<p><a href="#service-test-doubles">测试替身</a></p>
</li>
<li><p><a href="#get-injected-service">Get injected services</a></p>
<p><a href="#get-injected-service">获取注入的服务</a></p>
</li>
<li><p><a href="#testbed-get"><code>TestBed.get</code></a></p>
</li>
<li><p><a href="#service-from-injector">Always get the service from an injector</a></p>
<p><a href="#service-from-injector">总是从注入器中取得服务</a></p>
</li>
<li><p><a href="#welcome-spec-setup">Final setup and tests</a></p>
<p><a href="#welcome-spec-setup">最终设置与测试</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#component-with-async-service">Test a component with an async service</a></p>
<p><a href="#component-with-async-service">测试带有异步服务的组件</a></p>
<ul>
<li><p><a href="#service-spy">Spying on the real service</a></p>
<p><a href="#service-spy">监听真实的服务</a></p>
</li>
<li><p><a href="#sync-tests">Synchronous tests</a></p>
<p><a href="#sync-tests">同步测试</a></p>
</li>
<li><p><a href="#async">The <code>async</code> funciton in it</a></p>
<p><a href="#async"><code>it</code>中的<code>async</code>函数</a></p>
</li>
<li><p><a href="#when-stable"><code>whenStable</code></a></p>
</li>
<li><p><a href="#fake-async">The <code>fakeAsync</code> function</a></p>
<p><a href="#fake-async"><code>fakeAsync</code> 函数</a></p>
</li>
<li><p><a href="#tick">The <code>tick</code> function</a></p>
<p><a href="#tick"><code>tick</code>函数</a></p>
</li>
<li><p><a href="#jasmine-done"><code>jasmine.done</code></a></p>
</li>
</ul>
</li>
<li><p><a href="#component-with-input-output">Test a component with inputs and outputs</a></p>
<p><a href="#component-with-input-output">测试带有输入属性和输出属性的组件</a></p>
<ul>
<li><p><a href="#dashboard-standalone">Test <code>DashboardHeroComponent</code> stand-alone</a></p>
<p><a href="#dashboard-standalone">单独测试<code>DashboardHeroComponent</code></a></p>
</li>
<li><p><a href="#trigger-event-handler"><code>triggerEventHandler</code></a></p>
</li>
</ul>
</li>
<li><p><a href="#component-inside-test-host">Test a component inside a test host component</a></p>
<p><a href="#component-inside-test-host">在宿主组件中测试组件</a></p>
</li>
<li><p><a href="#routed-component">Test a routed component</a></p>
<p><a href="#routed-component">测试路由组件</a></p>
<ul>
<li><p><a href="#inject">The <code>inject</code> helper function</a></p>
<p><a href="#inject"><code>inject</code>助手函数</a></p>
</li>
<li><p><a href="#routed-component-w-param">Test a routed component with parameters</a></p>
<p><a href="#routed-component-w-param">测试带参数的路由组件</a></p>
</li>
<li><p><a href="#stub-observable">Create an <code>Observable</code> test double</a></p>
<p><a href="#stub-observable">创建<code>Observable</code>测试桩（Stub）</a></p>
</li>
<li><p><a href="#tests-w-observable-double">Testing with the <code>Observable</code> test double</a></p>
<p><a href="#tests-w-observable-double">使用<code>Observable</code>测试桩进行测试</a></p>
</li>
</ul>
</li>
<li><p><a href="#page-object">Use a <code>page</code> object to simplify setup</a></p>
<p><a href="#page-object">使用<code>page</code>对象来简化设置</a></p>
</li>
<li><p><a href="#import-module">Set up with module imports</a></p>
<p><a href="#import-module">设置导入了其它模块的模块</a></p>
</li>
<li><p><a href="#feature-module-import">Import the feature module</a></p>
<p><a href="#feature-module-import">导入特性模块</a></p>
</li>
<li><p><a href="#component-override">Override a component&#39;s providers</a></p>
<p><a href="#component-override">改写（Override）组件的提供商</a></p>
<ul>
<li><p><a href="#override-component-method">The <code>overrideComponent</code> method</a></p>
<p><a href="#override-component-method"><code>overrideComponent</code>方法</a></p>
</li>
<li><p><a href="#spy-stub">Provide a <em>spy-stub (HeroDetailServiceSpy)</em></a></p>
<p><a href="#spy-stub">提供一个 <em>监听桩</em>（<code>HeroDetailServiceSpy</code>）</a></p>
</li>
<li><p><a href="#override-tests">The override tests</a></p>
<p><a href="#override-tests">改写测试</a></p>
</li>
<li><p><a href="#more-overrides">More overrides</a></p>
<p><a href="#more-overrides">更多的改写</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#router-outlet-component">Test a <code>RouterOutlet</code> component</a></p>
<p><a href="#router-outlet-component">测试<code>RouterOutlet</code>组件</a></p>
<ul>
<li><p><a href="#stub-component">Stubbing unneeded components</a></p>
<p><a href="#stub-component">模拟不需要的组件</a></p>
</li>
<li><p><a href="#router-link-stub">Stubbing the <code>RouterLink</code></a></p>
<p><a href="#router-link-stub">模拟<code>RouterLink</code></a></p>
</li>
<li><p><a href="#by-directive"><code>By.directive</code> and injected directives</a></p>
<p><a href="#by-directive"><code>By.directive</code>与注入的指令</a></p>
</li>
<li><p><a href="#why-stubbed-routerlink-tests">What good are these tests?</a></p>
<p><a href="#why-stubbed-routerlink-tests">为什么要这样写测试？</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#shallow-component-test">&quot;Shallow component tests&quot; with  <em>NO_ERRORS_SCHEMA</em></a></p>
<p><a href="#shallow-component-test">使用<code>NO_ERRORS_SCHEMA</code>进行 &quot;浅组件测试&quot; </a></p>
</li>
<li><p><a href="#attribute-directive">Test an attribute directive</a></p>
<p><a href="#attribute-directive">测试属性型指令</a></p>
</li>
<li><p><a href="#isolated-unit-tests" title="Unit testing without the Angular testing utilities">Isolated unit tests</a></p>
<p><a href="#isolated-unit-tests" title="不使用Angular测试工具集的单元测试方式">独立的单元测试</a></p>
<ul>
<li><p><a href="#isolated-service-tests">Services</a></p>
<p><a href="#isolated-service-tests">服务</a></p>
</li>
<li><p><a href="#services-with-dependencies">Services with dependencies</a></p>
<p><a href="#services-with-dependencies">带依赖的服务</a></p>
</li>
<li><p><a href="#isolated-pipe-tests">Pipes</a></p>
<p><a href="#isolated-pipe-tests">管道</a></p>
</li>
<li><p><a href="#write-tests">Write Angular tests too</a></p>
<p><a href="#write-tests">写Angular测试</a></p>
</li>
<li><p><a href="#isolated-component-tests">Components</a></p>
<p><a href="#isolated-component-tests">组件</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#atu-apis">Angular testing utility APIs</a></p>
<p><a href="#atu-apis">Angular单元测试工具类 API </a></p>
<ul>
<li><p><a href="#testbed-class-summary"><code>TestBed</code> class summary</a></p>
<p><a href="#testbed-class-summary"><code>TestBed</code>总结</a></p>
</li>
<li><p><a href="#component-fixture-api-summary">The <code>ComponentFixture</code></a></p>
<p><a href="#component-fixture-api-summary"><code>ComponentFixture</code>总结</a></p>
</li>
<li><p><a href="#component-fixture-properties"><code>ComponentFixture</code> properties</a></p>
<p><a href="#component-fixture-properties"><code>ComponentFixture</code>的属性</a></p>
</li>
<li><p><a href="#component-fixture-methods">The <code>ComponentFixture</code> methods</a></p>
<p><a href="#component-fixture-methods"><code>ComponentFixture</code>方法</a></p>
</li>
<li><p><a href="#debug-element-details"><code>DebugElement</code></a></p>
<p><a href="#debug-element-details"><code>DebugElement</code>详情</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#setup-files">Test environment setup files</a></p>
<p><a href="#setup-files">测试环境设置所需的文件</a></p>
<ul>
<li><p><a href="#npm-packages">npm packages</a></p>
<p><a href="#npm-packages">npm包</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="#faq" title="Frequently asked questions">FAQ: Frequently asked questions</a></p>
<p><a href="#faq" title="常见问题">常见问题（FAQ）</a></p>
</li>
</ul>
<p>It’s a big agenda. Fortunately, you can learn a little bit at a time and put each lesson to use.</p>
<p>以上主题繁多。幸运的是，你可以慢慢地阅读并立刻应用每一个主题。</p>
<h2 id="live-examples">Live examples</h2>
<h2 id="-">在线例子</h2>
<p>This guide presents tests of a sample application that is much like the <a href="../tutorial"><em>Tour of Heroes</em> tutorial</a>.
The sample application and all tests in this guide are available as live examples for inspection, experiment, and download:</p>
<p>这篇指南会展示一个范例应用的所有测试，这个范例应用和<a href="../tutorial">《英雄指南》教程</a>非常像。
本章中的这个范例应用及其所有测试都有在线例子，以供查看、试验和下载。</p>
<ul>
<li><p><live-example plnkr="1st-specs" embedded-style>A spec to verify the test environment</live-example>.</p>
<p> <live-example plnkr="1st-specs" embedded-style>用于验证测试环境的规约</live-example>。</p>
</li>
<li><p><live-example plnkr="banner-inline-specs" embedded-style>The first component spec with inline template</live-example>.</p>
<p> <live-example plnkr="banner-inline-specs" embedded-style>第一个带内联模板的组件规约</live-example>。</p>
</li>
<li><p><live-example plnkr="banner-specs" embedded-style>A component spec with external template</live-example>.</p>
<p> <live-example plnkr="banner-specs" embedded-style>带外部模板的组件规约</live-example>。</p>
</li>
<li><p><live-example name="setup" plnkr="quickstart-specs" embedded-style>The QuickStart seed&#39;s AppComponent spec</live-example>.</p>
<p> <live-example name="setup" plnkr="quickstart-specs" embedded-style>快速起步种子工程的<code>AppComponent</code>规约</live-example>。</p>
</li>
<li><p><live-example embedded-style>The sample application to be tested</live-example>.</p>
<p> <live-example embedded-style>所要测试的范例应用</live-example>。</p>
</li>
<li><p><live-example plnkr="app-specs" embedded-style>All specs that test the sample application</live-example>.</p>
<p> <live-example plnkr="app-specs" embedded-style>本范例应用的所有规约</live-example>。</p>
</li>
<li><p><live-example plnkr="bag-specs" embedded-style>A grab bag of additional specs</live-example>.</p>
<p> <live-example plnkr="bag-specs" embedded-style>其它规约汇总</live-example>。</p>
</li>
</ul>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="testing-intro"></a><h2 id="introduction-to-angular-testing">Introduction to Angular Testing</h2>
<h2 id="angular-">Angular测试入门</h2>
<p>This page guides you through writing tests to explore
and confirm the behavior of the application. Testing
does the following:</p>
<p>本章教你如何编写测试程序来探索和确认应用的行为。测试的作用有：</p>
<ol>
<li><p>Guards against changes that break existing code (“regressions”).</p>
<p>测试<strong>守护</strong>由于代码变化而打破已有代码(“回归”)的情况。</p>
</li>
<li><p>Clarifies what the code does both when used as intended and when faced with deviant conditions.</p>
<p>不管代码被正确使用还是错误使用，测试程序起到<strong>澄清</strong>代码的作用。</p>
</li>
<li><p>Reveals mistakes in design and implementation.
Tests shine a harsh light on the code from many angles.
When a part of the application seems hard to test, the root cause is often a design flaw,
something to cure now rather than later when it becomes expensive to fix.</p>
<p>测试程序<strong>暴露</strong>设计和实现可能出现的错误。测试程序从很多角度为代码亮出警报灯。当应用程序很难被测试时，
其根本原因一般都是设计缺陷，这种缺陷最好立刻被修正，不要等到它变得很难被修复的时候才行动。</p>
</li>
</ol>
<p>This chapter assumes that you know something about testing. Don&#39;t worry if you don&#39;t.
There are plenty of books and online resources to get up to speed.</p>
<p>本章假设你熟悉测试。但是如果你不熟悉也没有关系。有很多书本和在线资源可以帮助你。</p>
<!-- TODO
:marked
### Learn more
Learn more about basic Jasmine testing here
[Resources TBD](./#)
-->
<a id="tools-and-tech"></a><h3 id="tools-and-technologies">Tools and technologies</h3>
<h3 id="-">工具与技术</h3>
<p>You can write and run Angular tests with a variety of tools and technologies.
This guide describes specific choices that are known to work well.</p>
<p>你可以用多种工具和技术来编写和运行Angular测试程序。本章介绍了一些大家已经知道能良好工作的选择。</p>
<table width="100%"><col width="20%"><col width="80%"><tr><th><p>Technology</p><p>技术</p></th><th><p>Purpose</p><p>目的</p></th></tr><tr><td style="vertical-align: top">Jasmine</td><td><p>The <a href="http://jasmine.github.io/2.4/introduction.html">Jasmine test framework</a>
provides everything needed to write basic tests.
It ships with an HTML test runner that executes tests in the browser.</p>
<p><a href="http://jasmine.github.io/2.4/introduction.html">Jasmine测试框架</a>提供了所有编写基本测试的工具。
它自带HTML测试运行器，用来在浏览器中执行测试程序。</p>
</td></tr><tr><td style="vertical-align: top"><p>Angular testing utilities</p><p>Angular测试工具</p></td><td><p>Angular testing utilities create a test environment
for the Angular application code under test.
Use them to condition and control parts of the application as they
interact <em>within</em> the Angular environment.</p>
<p>Angular测试工具为被测试的Angular应用代码创建测试环境。在应用代码与Angular环境互动时，使用Angular测试工具来限制和控制应用的部分代码。</p>
</td></tr><tr><td style="vertical-align: top">Karma</td><td><p>The <a href="https://karma-runner.github.io/1.0/index.html">karma test runner</a>
is ideal for writing and running unit tests while developing the application.
It can be an integral part of the project&#39;s development and continuous integration processes.
This guide describes how to set up and run tests with karma.</p>
<p><a href="https://karma-runner.github.io/1.0/index.html">karma测试运行器</a>是在开发应用的过程中
编写和运行单元测试的理想工具。
它能成为项目开发和连续一体化进程的不可分割的一部分。本章讲述了如何用Karma设置和运行测试程序。</p>
</td></tr><tr><td style="vertical-align: top">Protractor</td><td><p>Use protractor to write and run <em>end-to-end</em> (e2e) tests.
End-to-end tests explore the application <em>as users experience it</em>.
In e2e testing, one process runs the real application
and a second process runs protractor tests that simulate user behavior
and assert that the application respond in the browser as expected.</p>
<p>使用<code>Protractor</code>来编写和运行<em>端对端(e2e)</em>测试程序。端对端测试程序<strong>像用户体验应用程序那样</strong>探索它。
在端对端测试中，一条进程运行真正的应用，另一条进程运行Protractor测试程序，模拟用户行为，判断应用在浏览器中的反应是否正确。</p>
</td></tr></table><a id="setup"></a><h3 id="setup">Setup</h3>
<h3 id="-">环境设置</h3>
<p>There are two fast paths to getting started with unit testing.</p>
<p>要开始单元测试，有两条捷径：</p>
<ol>
<li><p>Start a new project following the instructions in <a href="setup.html" title="Setup">Setup</a>.</p>
<p> 遵循<a href="setup.html" title="环境设置">环境设置</a>中给出的步骤开始一个新项目。</p>
</li>
<li><p>Start a new project with the
<a href="https://github.com/angular/angular-cli/blob/master/README.md" target="_blank" title="Angular CLI">Angular CLI</a>.</p>
<p> 使用<a href="https://github.com/angular/angular-cli/blob/master/README.md">Angular CLI</a>创建新的项目。</p>
</li>
</ol>
<p>Both approaches install npm packages, files, and scripts pre-configured for applications
built in their respective modalities.
Their artifacts and procedures differ slightly but their essentials are the same
and there are no differences in the test code.</p>
<p>以上两种方法都安装在各自的模式下为应用预先配置的<strong>npm包、文件和脚本</strong>。它们的文件和规程有一点不同，但是它们的核心部分是一样的，并且在测试代码方面没有任何区别。</p>
<p>In this guide, the application and its tests are based on the <a href="setup.html" title="Setup">setup instructions</a>.
For a discussion of the unit testing setup files, <a href="#setup-files">see below</a>.</p>
<p>本章中，该应用及其测试都是基于<a href="setup.html" title="Setup">环境设置步骤</a>的。
对单元测试的环境设置文件的讨论，<a href="#setup-files">参见后面</a>。</p>
<a id="isolated-v-testing-utilities"></a><h3 id="isolated-unit-tests-vs-the-angular-testing-utilites">Isolated unit tests vs. the Angular testing utilites</h3>
<h3 id="-vs-angular-">独立单元测试 vs. Angular测试工具集</h3>
<p><a href="#isolated-unit-tests" title="Unit testing without the Angular testing utilities">Isolated unit tests</a>
examine an instance of a class all by itself without any dependence on Angular or any injected values.
The tester creates a test instance of the class with <code>new</code>, supplying test doubles for the constructor parameters as needed, and
then probes the test instance API surface.</p>
<p><a href="#isolated-unit-tests" title="不使用Angular测试工具集的单元测试">独立单元测试</a>用于测试那些完全不依赖Angular或不需要注入值的类实例。
测试程序是所有<code>new</code>创建该类的实例，为构造函数参数提供所需的测试替身，然后测试该实例的API接口。</p>
<p><em>You should write isolated unit tests for pipes and services.</em></p>
<p><em>我们应该为管道和服务书写独立单元测试。</em></p>
<p>You can test components in isolation as well.
However, isolated unit tests don&#39;t reveal how components interact with Angular.
In particular, they can&#39;t reveal how a component class interacts with its own template or with other components.</p>
<p>我们也同样可以对组件写独立单元测试。
不过，独立单元测试无法体现组件与Angular的交互。
具体来说，就是不能发现组件类如何与它的模板或其它组件交互。</p>
<p>Such tests require the <strong>Angular testing utilities</strong>.
The  Angular testing utilities include the <code>TestBed</code> class and several helper functions from <code>@angular/core/testing</code>.
They are the main focus of this guide and you&#39;ll learn about them
when you write your <a href="#simple-component-test">first component test</a>.
A comprehensive review of the Angular testing utilities appears <a href="#atu-apis">later in this guide</a>.</p>
<p>这时你需要<em>Angular测试工具集</em>。
Angular测试工具集包括<code>TestBed</code>类和一些来自<code>@angular/core/testing</code>的助手函数。
本章将会重点讲解它们，通过<a href="#simple-component-test">第一个组件测试</a>来讲解。
<a href="#atu-apis">本章稍后的部分</a>将展示Angular测试工具集的全貌。</p>
<p>But first you should write a dummy test to verify that your test environment is set up properly
and to lock in a few basic testing skills.</p>
<p>但首先，我们要先随便写一个测试来验证测试环境是否已经就绪了，并掌握一些基础的测试技术。</p>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="1st-karma-test"></a><h2 id="the-first-karma-test">The first karma test</h2>
<h2 id="-karma-">第一个<code>karma</code>测试</h2>
<p>Start with a simple test to make sure that the setup works properly.</p>
<p>编写简单的测试程序，来确认以上的配置是否工作正常。</p>
<p>Create a new file called <code>1st.spec.ts</code> in the application root folder, <code>src/app/</code></p>
<p>在应用的根目录<code>app/</code>创建新文件，名叫<code>1st.spec.ts</code>。</p>
<div class="alert is-important"><p>Tests written in Jasmine are called <em>specs</em> .
<strong>The filename extension must be <code>.spec.ts</code></strong>,
the convention adhered to by  <code>karma.conf.js</code> and other tooling.</p>
<p>用Jasmine编写的测试程序都被叫做<strong>specs</strong>。<strong>文件名后缀必须是<code>.spec.ts</code></strong>，这是<code>karma.conf.js</code>和其它工具所坚持和遵守的规约。</p>
</div><p><strong>Put spec files somewhere within the <code>src/app/</code> folder.</strong>
The <code>karma.conf.js</code> tells karma to look for spec files there,
for reasons explained <a href="#q-spec-file-location">below</a>.</p>
<p><strong>将测试程序spec放到<code>app/</code>文件夹下的任何位置。</strong>
<code>karma.conf.js</code>告诉<code>Karma</code>在这个文件夹中寻找测试程序spec文件，原因在 <a href="#spec-file-location">这里</a> 有所解释。</p>
<p>Add the following code to <code>src/app/1st.spec.ts</code>.</p>
<p>添加下面的代码到<code>app/1st.spec.ts</code>。</p>
<div class="code-example"><header><h4>src/app/1st.spec.ts</h4></header><code-example language="ts" format="">describe(&#39;1st tests&#39;, () =&gt; {
  it(&#39;true is true&#39;, () =&gt; expect(true).toBe(true));
});
</code-example></div><a id="run-karma"></a><h3 id="run-with-karma">Run with karma</h3>
<h3 id="-karma">运行Karma</h3>
<p>Compile and run it in karma from the command line using the following command:</p>
<p>使用下面的命令从命令行中编译并在<code>Karma</code>中运行上面的测试程序。</p>
<code-example format="." language="bash">npm test</code-example><p>The command compiles the application and test code and starts karma.
Both processes watch pertinent files, write messages to the console, and re-run when they detect changes.</p>
<p>该命令编译应用及其测试代码，并启动Karma。
两个进程都监视相关文件，往控制台输入信息和检测到变化时自动重新运行。</p>
<div class="l-sub-section"><p>The documentation setup defines the <code>test</code> command in the <code>scripts</code> section of npm&#39;s <code>package.json</code>.
The Angular CLI has different commands to do the same thing. Adjust accordingly.</p>
<p>《快速起步》在npm的<code>package.json</code>中的<code>scripts</code>里定义了<code>test</code>命令。
Angular CLI使用不同的命令来做同样的事情。对不同的环境采取不同的方案。</p>
</div><p>After a few moments, karma opens a browser and starts writing to the console.</p>
<p>等一小段时间后，Karma便打开浏览器并开始向控制台输出。</p>
<figure class="image-display"><img src="/resources/images/devguide/testing/karma-browser.png" style="width:400px" alt="Karma browser"></figure><p>Hide (don&#39;t close!) the browser and focus on the console output, which
should look something like this:</p>
<p>隐藏（不要关闭）浏览器，查看控制台的输出，应该是这样的：</p>
<code-example format="." language="bash">> npm test
...
[0] 1:37:03 PM - Compilation complete. Watching for file changes.
...
[1] Chrome 51.0.2704: Executed 0 of 0 SUCCESS
    Chrome 51.0.2704: Executed 1 of 1 SUCCESS
SUCCESS (0.005 secs / 0.005 secs)
</code-example><p>Both the compiler and karma continue to run. The compiler output is preceded by <code>[0]</code>;
the karma output by <code>[1]</code>.</p>
<p>编译器和<code>Karma</code>都会持续运行。编译器的输入信息前面有<code>[0]</code>，<code>Karma</code>的输出前面有<code>[1]</code>。</p>
<p>Change the expectation from <code>true</code> to <code>false</code>.</p>
<p>将期望从<code>true</code>变换为<code>false</code>。</p>
<p>The <em>compiler</em> watcher detects the change and recompiles.</p>
<p><strong>编译器</strong>监视器检测到这个变化并重新编译。</p>
<code-example format="." language="bash">[0] 1:49:21 PM - File change detected. Starting incremental compilation...
[0] 1:49:25 PM - Compilation complete. Watching for file changes.
</code-example><p>The <em>karma</em> watcher detects the change to the compilation output and re-runs the test.</p>
<p><strong><code>Karma</code></strong>监视器检测到编译器输出的变化，并重新运行测试。</p>
<code-example format="." language="bash">[1] Chrome 51.0.2704 1st tests true is true FAILED
[1] Expected false to equal true.
[1] Chrome 51.0.2704: Executed 1 of 1 (1 FAILED) (0.005 secs / 0.005 secs)
</code-example><p>It fails of course.</p>
<p>正如所料，测试结果是<strong>失败</strong>。</p>
<p>Restore the expectation from <code>false</code> back to <code>true</code>.
Both processes detect the change, re-run, and karma reports complete success.</p>
<p>将期望从<code>false</code>恢复为<code>true</code>。两个进程都检测到这个变化，自动重新运行，<code>Karma</code>报告测试成功。</p>
<div class="alert is-helpful"><p>The console log can be quite long. Keep your eye on the last line.
When all is well, it reads <code>SUCCESS</code>.</p>
<p>控制台的日志可能会非常长。注意最后一样。当一切正常时，它会显示<code>SUCCESS</code>。</p>
</div><a id="test-debugging"></a><h3 id="test-debugging">Test debugging</h3>
<h3 id="-">调试测试程序</h3>
<p>Debug specs in the browser in the same way thatyou debug an application.</p>
<p>在浏览器中，像调试应用一样调试测试程序spec。</p>
<ol>
<li><p>Reveal the karma browser window (hidden earlier).</p>
<p>显示<code>Karma</code>的浏览器窗口（之前被隐藏了）。</p>
</li>
<li><p>Click the <strong>DEBUG</strong> button; it opens a new browser tab and re-runs the tests.</p>
<p>点击“DEBUG”按钮；它打开一页新浏览器标签并重新开始运行测试程序</p>
</li>
<li><p>Open the browser&#39;s “Developer Tools” (<code>Ctrl-Shift-I</code> on windows; <code>Command-Option-I</code> in OSX).</p>
<p>打开浏览器的“Developer Tools”(Windows上的Ctrl-Shift-I或者OSX上的`Command-Option-I)。</p>
</li>
<li><p>Pick the &quot;sources&quot; section.</p>
<p>选择“sources”页</p>
</li>
<li><p>Open the <code>1st.spec.ts</code> test file (Control/Command-P, then start typing the name of the file).</p>
<p>打开<code>1st.spec.ts</code>测试文件（Control/Command-P, 然后输入文件名字）。</p>
</li>
<li><p>Set a breakpoint in the test.</p>
<p>在测试程序中设置断点。</p>
</li>
<li><p>Refresh the browser, and it stops at the breakpoint.</p>
<p>刷新浏览器...然后它就会停在断点上。</p>
</li>
</ol>
<figure class="image-display"><img src="/resources/images/devguide/testing/karma-1st-spec-debug.png" style="width:700px" alt="Karma debugging"></figure><a id="live-karma-example"></a><h3 id="try-the-live-example">Try the live example</h3>
<h3 id="-">试试这个在线例子</h3>
<p>You can also try this test as a <live-example plnkr="1st-specs" title="First spec" embedded-style></live-example> in plunker.
All of the tests in this guide are available as <a href="#live-examples" title="Live examples of these tests">live examples</a>.</p>
<p>你还可以在plunker的<live-example plnkr="1st-specs" title="First spec" embedded-style></live-example>中试运行这个测试。
本章的所有测试都有相应的<a href="#live-examples" title="Live examples of these tests">在线例子</a>。</p>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="simple-component-test"></a><h2 id="test-a-component">Test a component</h2>
<h2 id="-">测试一个组件</h2>
<p>An Angular component is the first thing most developers want to test.
The <code>BannerComponent</code> in <code>src/app/banner-inline.component.ts</code> is the simplest component in this application and
a good place to start.
It presents the application title at the top of the screen within an <code>&lt;h1&gt;</code> tag.</p>
<p>大多数开发人员首先要测试的就是Angular组件。
<code>src/app/banner-inline.component.ts</code>中的<code>BannerComponent</code>是这个应用中最简单的组件，也是一个好的起点。
它所表示的是屏幕顶部<code>&lt;h1&gt;</code>标签中的应用标题。</p>
<div class="code-example"><header><h4>src/app/banner-inline.component.ts</h4></header><code-example language="ts" format="">import { Component } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-banner&#39;,
  template: &#39;&lt;h1&gt;{{title}}&lt;/h1&gt;&#39;
})
export class BannerComponent {
  title = &#39;Test Tour of Heroes&#39;;
}
</code-example></div><p>This version of the <code>BannerComponent</code> has an inline template and an interpolation binding.
The component is probably too simple to be worth testing in real life but
it&#39;s perfect for a first encounter with the Angular testing utilities.</p>
<p>这个版本的<code>BannerComponent</code>有一个内联模板和一个插值表达式绑定。
这个组件可能太简单，以至于在真实的项目中都不值得测试，但它却是首次接触Angular测试工具集时的完美例子。</p>
<p>The corresponding <code>src/app/banner-inline.component.spec.ts</code> sits in the same folder as the component,
for reasons explained in the <a href="#faq">FAQ</a> answer to
<a href="#q-spec-file-location">&quot;Why put specs next to the things they test?&quot;</a>.</p>
<p>组件对应的<code>src/app/banner-inline.component.spec.ts</code>文件与该组件位于同一个目录中，原因详见<a href="#faq">FAQ</a>中的
<a href="#q-spec-file-location">为什么要把测试规约文件放在被测试对象旁边？</a></p>
<p>Start with ES6 import statements to get access to symbols referenced in the spec.</p>
<p>在测试文件中，我们先用ES6的<code>import</code>语句来引入测试所需的符号。</p>
<div class="code-example"><header><h4>src/app/banner-inline.component.spec.ts (imports)</h4></header><code-example language="ts" format="">import { ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;
import { By }              from &#39;@angular/platform-browser&#39;;
import { DebugElement }    from &#39;@angular/core&#39;;

import { BannerComponent } from &#39;./banner-inline.component&#39;;
</code-example></div><a id="configure-testing-module"></a><p>Here&#39;s the <code>describe</code> and the <code>beforeEach</code> that precedes the tests:</p>
<p>测试前面的<code>describe</code>和<code>beforeEach</code>如下：</p>
<div class="code-example"><header><h4>src/app/banner-inline.component.spec.ts (beforeEach)</h4></header><code-example language="ts" format="">describe(&#39;BannerComponent (inline template)&#39;, () =&gt; {

  let comp:    BannerComponent;
  let fixture: ComponentFixture&lt;BannerComponent&gt;;
  let de:      DebugElement;
  let el:      HTMLElement;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ BannerComponent ], // declare the test component
    });

    fixture = TestBed.createComponent(BannerComponent);

    comp = fixture.componentInstance; // BannerComponent test instance

    // query for the title &lt;h1&gt; by CSS element selector
    de = fixture.debugElement.query(By.css(&#39;h1&#39;));
    el = de.nativeElement;
  });
});
</code-example></div><a id="testbed"></a><h3 id="_testbed_"><em>TestBed</em></h3>
<p><code>TestBed</code> is the first and most important of the  Angular testing utilities.
It creates an Angular testing module&mdash;an <code>@NgModule</code> class&mdash;that
you configure with the <code>configureTestingModule</code> method to produce the module environment for the class you want to test.
In effect, you detach the tested component from its own application module
and re-attach it to a dynamically-constructed Angular test module
tailored specifically for this battery of tests.</p>
<p><code>TestBed</code>（测试台）是Angular测试工具集中的首要概念。
它创建Angular测试模块（一个<code>@NgModule</code>类），我们可以通过调用它的<code>configureTestingModule</code>方法来为要测试的类生成模块环境。
其效果是，你可以把被测试的组件从原有的应用模块中剥离出来，把它附加到一个动态生成的Angular测试模块上，而该测试模块可以为这些测试进行特殊裁剪。</p>
<p>The <code>configureTestingModule</code> method takes an <code>@NgModule</code>-like metadata object.
The metadata object can have most of the properties of a normal <a href="ngmodule.html">Angular module</a>.</p>
<p><code>configureTestingModule</code>方法接受一个类似<code>@NgModule</code>的元数据对象。这个元数据对象具有标准<a href="ngmodule.html">Angular模块</a>的大多数属性。</p>
<p><em>This metadata object</em> simply declares the component to test, <code>BannerComponent</code>.
The metadata lack <code>imports</code> because (a) the default testing module configuration already has what <code>BannerComponent</code> needs
and (b) <code>BannerComponent</code> doesn&#39;t interact with any other components.</p>
<p><em>这里的元数据对象</em>只是声明了要测试的组件<code>BannerComponent</code>。
这个元数据中没有<code>imports</code>属性，这是因为：(a) 默认的测试模块配置中已经有了<code>BannerComponent</code>所需的一切，(b) <code>BannerComponent</code>不需要与任何其它组件交互。</p>
<p>Call <code>configureTestingModule</code> within a <code>beforeEach</code> so that
<code>TestBed</code> can reset itself to a base state before each test runs.</p>
<p>在<code>beforeEach</code>中调用<code>configureTestingModule</code>，以便<code>TestBed</code>可以在运行每个测试之前都把自己重置回它的基础状态。</p>
<p>The base state includes a default testing module configuration consisting of the
declarables (components, directives, and pipes) and providers (some of them mocked)
that almost everyone needs.</p>
<p>基础状态中包含一个默认的测试模块配置，它包含每个测试都需要的那些声明（组件、指令和管道）以及服务提供商（有些是Mock版）。</p>
<div class="l-sub-section"><p>The testing shims mentioned <a href="#testbed-methods">later</a> initialize the testing module configuration
to something like the <code>BrowserModule</code> from <code>@angular/platform-browser</code>.</p>
<p><a href="#setup">之前</a>提到的测试垫片初始化测试模块配置到一个模块，这个模块和<code>@angular/platform-browser</code>中的<code>BrowserModule</code>类似。</p>
</div><p>This default configuration is merely a <em>foundation</em> for testing an app.
Later you&#39;ll call <code>TestBed.configureTestingModule</code> with more metadata that define additional
imports, declarations, providers, and schemas to fit your application tests.
Optional <code>override</code> methods can fine-tune aspects of the configuration.</p>
<p>这个默认的配置只是测试的<em>基础性</em>工作。稍后我们会调用<code>TestBed.configureTestingModule</code>来传入更多元数据，这些元数据定义了额外的
<code>imports</code>、<code>declarations</code>、<code>providers</code>和试用于这些测试的概要（Schema）。
可选的<code>override</code>方法可以微调配置的各个方面。</p>
<a id="create-component"></a><h3 id="_createcomponent_"><em>createComponent</em></h3>
<p>After configuring <code>TestBed</code>, you tell it to create an instance of the <em>component-under-test</em>.
In this example, <code>TestBed.createComponent</code> creates an instance of <code>BannerComponent</code> and
returns a <a href="#component-fixture"><em>component test fixture</em></a>.</p>
<p>在配置好<code>TestBed</code>之后，我们可以告诉它创建一个<em>待测组件</em>的实例。
在这个例子中，<code>TestBed.createComponent</code>创建了一个<code>BannerComponent</code>的实例，并返回一个<a href="#component-fixture"><em>组件测试夹具</em></a>。</p>
<div class="alert is-important"><p>Do not re-configure <code>TestBed</code> after calling <code>createComponent</code>.</p>
<p>在调用了<code>createComponent</code>之后就不要再重新配置<code>TestBed</code>了。</p>
</div><p>The <code>createComponent</code> method closes the current <code>TestBed</code> instance to further configuration.
You cannot call any more <code>TestBed</code> configuration methods, not <code>configureTestingModule</code>
nor any of the <code>override...</code> methods. If you try, <code>TestBed</code> throws an error.</p>
<p><code>createComponent</code>方法封闭了当前的<code>TestBed</code>实例，以免将来再配置它。
我们不能再调用任何<code>TestBed</code>的方法修改配置：不能调用<code>configureTestingModule</code>或任何<code>override...</code>方法。如果这么做，<code>TestBed</code>就会抛出错误。</p>
<a id="component-fixture"></a><h3 id="_componentfixture_-_debugelement_-and-_query-by-css-_"><em>ComponentFixture</em>, <em>DebugElement</em>, and <em>query(By.css)</em></h3>
<h3 id="-componentfixture-debugelement-query-by-css-"><code>ComponentFixture</code>、<code>DebugElement</code> 和 <code>query(By.css)</code></h3>
<p>The <code>createComponent</code> method returns a <strong><code>ComponentFixture</code></strong>, a handle on the test environment surrounding the created component.
The fixture provides access to the component instance itself and
to the <strong><code>DebugElement</code></strong>, which is a handle on the component&#39;s DOM element.</p>
<p><code>createComponent</code>方法返回<strong><code>ComponentFixture</code></strong>，用来控制和访问已创建的组件所在的测试环境。
 这个fixture提供了对组件实例自身的访问，同时还提供了用来访问组件的DOM元素的<strong><code>DebugElement</code></strong>对象。</p>
<p>The <code>title</code> property value is interpolated into the DOM within <code>&lt;h1&gt;</code> tags.
Use the fixture&#39;s <code>DebugElement</code> to <code>query</code> for the <code>&lt;h1&gt;</code> element by CSS selector.</p>
<p><code>title</code>属性被插值到DOM的<code>&lt;h1&gt;</code>标签中。
用CSS选择器从fixture的<code>DebugElement</code>中<code>query``&lt;h1&gt;</code>元素。</p>
<p>The <strong><code>query</code></strong> method takes a predicate function and searches the fixture&#39;s entire DOM tree for the 
<em>first</em> element that satisfies the predicate. 
The result is a <em>different</em> <code>DebugElement</code>, one associated with the matching DOM element.</p>
<p><strong><code>query</code></strong>方法接受predicate函数，并搜索fixture的整个DOM树，试图寻找<strong>第一个</strong>满足predicate函数的元素。</p>
<div class="l-sub-section"><p>The <code>queryAll</code> method returns an array of <em>all</em> <code>DebugElements</code> that satisfy the predicate.</p>
<p><code>queryAll</code>方法返回一列数组，包含所有<code>DebugElement</code>中满足predicate的元素。</p>
<p>A <em>predicate</em> is a function that returns a boolean. 
A query predicate receives a <code>DebugElement</code> and returns <code>true</code> if the element meets the selection criteria.</p>
<p><strong>predicate</strong>是返回布尔值的函数。
predicate查询接受<code>DebugElement</code>参数，如果元素符合选择条件便返回<code>true</code>。</p>
</div><p>The <strong><code>By</code></strong> class is an Angular testing utility that produces useful predicates.
Its <code>By.css</code> static method produces a
<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors" target="_blank">standard CSS selector</a>
predicate that filters the same way as a jQuery selector.</p>
<p><strong><code>By</code></strong>类是Angular测试工具之一，它生成有用的predicate。
它的<code>By.css</code>静态方法产生<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors" target="_blank">标准CSS选择器</a>
predicate，与JQuery选择器相同的方式过滤。</p>
<p>Finally, the setup assigns the DOM element from the <code>DebugElement</code> <strong><code>nativeElement</code></strong> property to <code>el</code>.
The tests assert that <code>el</code> contains the expected title text.</p>
<p>最后，这个配置把<code>DebugElement</code>中的<strong><code>nativeElement</code></strong>DOM元素赋值给<code>el</code>属性。
测试程序将判断<code>el</code>是否包含期待的标题文本。</p>
<a id="the-tests"></a><h3 id="the-tests">The tests</h3>
<h3 id="-">测试程序</h3>
<p>Jasmine runs the <code>beforeEach</code> function before each of these tests</p>
<p>再每个测试程序之前，Jasmin都一次运行<code>beforeEach</code>函数：</p>
<div class="code-example"><header><h4>src/app/banner-inline.component.spec.ts (tests)</h4></header><code-example language="ts" format="">it(&#39;should display original title&#39;, () =&gt; {
  fixture.detectChanges();
  expect(el.textContent).toContain(comp.title);
});

it(&#39;should display a different test title&#39;, () =&gt; {
  comp.title = &#39;Test Title&#39;;
  fixture.detectChanges();
  expect(el.textContent).toContain(&#39;Test Title&#39;);
});
</code-example></div><p>These tests ask the <code>DebugElement</code> for the native HTML element to satisfy their expectations.</p>
<p>这些测试程序向<code>DebugElement</code>获取原生HTML元素，来满足自己的期望。</p>
<a id="detect-changes"></a><h3 id="_detectchanges_-angular-change-detection-within-a-test"><em>detectChanges</em>: Angular change detection within a test</h3>
<h3 id="-detectchanges-angular-"><strong>detectChanges</strong>：在测试中的Angular变更检测</h3>
<p>Each test tells Angular when to perform change detection by calling <code>fixture.detectChanges()</code>.
The first test does so immediately, triggering data binding and propagation of the <code>title</code> property
to the DOM element.</p>
<p>每个测试程序都通过调用<code>fixture.detectChanges()</code>来通知Angular执行变更检测。第一个测试程序立刻这么做，触发数据绑定和并将<code>title</code>属性发送到DOM元素中。</p>
<p>The second test changes the component&#39;s <code>title</code> property <em>and only then</em> calls <code>fixture.detectChanges()</code>;
the new value appears in the DOM element.</p>
<p>第二个测试程序在更改组件的<code>title</code>属性<strong>之后</strong>才调用<code>fixture.detectChanges()</code>。新值出现在DOM元素中。</p>
<p>In production, change detection kicks in automatically
when Angular creates a component or the user enters a keystroke or
an asynchronous activity (e.g., AJAX) completes.</p>
<p>在产品阶段，当Angular创建组件、用户输入或者异步动作（比如AJAX）完成时，自动触发变更检测。</p>
<p>The <code>TestBed.createComponent</code> does <em>not</em> trigger change detection.
The fixture does not automatically push the component&#39;s <code>title</code> property value into the data bound element,
a fact demonstrated in the following test:</p>
<p><code>TestBed.createComponent</code><strong>不会</strong>触发变更检测。该工具不会自动将组件的<code>title</code>属性值推送到数据绑定的元素，下面的测试程序展示了这个事实：</p>
<div class="code-example"><header><h4>src/app/banner-inline.component.spec.ts (no detectChanges)</h4></header><code-example language="ts" format="">it(&#39;no title in the DOM until manually call `detectChanges`&#39;, () =&gt; {
  expect(el.textContent).toEqual(&#39;&#39;);
});
</code-example></div><p>This behavior (or lack of it) is intentional.
It gives the tester an opportunity to inspect or change the state of
the component <em>before Angular initiates data binding or calls lifecycle hooks</em>.</p>
<p>这种行为（或者缺乏的行为）是有意为之。<strong>在Angular初始化数据绑定或者调用生命周期钩子</strong>之前，它给测试者机会来查看或者改变组件的状态。</p>
<a id="try-example"></a><h3 id="try-the-live-example">Try the live example</h3>
<h3 id="-">试试在线例子</h3>
<p>Take a moment to explore this component spec as a <live-example plnkr="banner-inline-specs" title="Spec for component with inline template" embedded-style></live-example> and
lock in these fundamentals of component unit testing.</p>
<p>花点时间来浏览一下该组件的规约，比如<live-example plnkr="banner-inline-specs" title="Spec for component with inline template" embedded-style></live-example>，深入理解组件单元测试的这些基本原理。</p>
<a id="auto-detect-changes"></a><h3 id="automatic-change-detection">Automatic change detection</h3>
<h3 id="-">自动变更检测</h3>
<p>The <code>BannerComponent</code> tests frequently call <code>detectChanges</code>.
Some testers prefer that the Angular test environment run change detection automatically.
That&#39;s possible by configuring the <code>TestBed</code> with the <code>ComponentFixtureAutoDetect</code> provider .
First import it from the testing utility library :</p>
<p><code>BannerComponent</code>的测试频繁调用<code>detectChanges</code>。
有些测试人员更希望Angular的测试环境自动进行变更检测。
这可以通过为<code>TestBed</code>配置上<code>ComponentFixtureAutoDetect</code>提供商来做到。首先从测试工具库中导入它：</p>
<div class="code-example"><header><h4>src/app/banner.component.detect-changes.spec.ts (import)</h4></header><code-example language="ts" format="">import { ComponentFixtureAutoDetect } from &#39;@angular/core/testing&#39;;
</code-example></div><p>Then add it to the <code>providers</code> array of the testing module configuration:</p>
<p>然后把它添加到测试模块配置的<code>providers</code>数组中：</p>
<div class="code-example"><header><h4>src/app/banner.component.detect-changes.spec.ts (AutoDetect)</h4></header><code-example language="ts" format="">TestBed.configureTestingModule({
  declarations: [ BannerComponent ],
  providers: [
    { provide: ComponentFixtureAutoDetect, useValue: true }
  ]
})
</code-example></div><p>Here are three tests that illustrate how automatic change detection works.</p>
<p>下列测试阐明了自动变更检测的工作原理。</p>
<div class="code-example"><header><h4>src/app/banner.component.detect-changes.spec.ts (AutoDetect Tests)</h4></header><code-example language="ts" format="">it(&#39;should display original title&#39;, () =&gt; {
  // Hooray! No `fixture.detectChanges()` needed
  expect(el.textContent).toContain(comp.title);
});

it(&#39;should still see original title after comp.title change&#39;, () =&gt; {
  const oldTitle = comp.title;
  comp.title = &#39;Test Title&#39;;
  // Displayed title is old because Angular didn&#39;t hear the change :(
  expect(el.textContent).toContain(oldTitle);
});

it(&#39;should display updated title after detectChanges&#39;, () =&gt; {
  comp.title = &#39;Test Title&#39;;
  fixture.detectChanges(); // detect changes explicitly
  expect(el.textContent).toContain(comp.title);
});
</code-example></div><p>The first test shows the benefit of automatic change detection.</p>
<p>第一个测试程序展示了自动检测的好处。</p>
<p>The second and third test reveal an important limitation.
The Angular testing environment does <em>not</em> know that the test changed the component&#39;s <code>title</code>.
The <code>ComponentFixtureAutoDetect</code> service responds to <em>asynchronous activities</em> such as promise resolution, timers, and DOM events.
But a direct, synchronous update of the component property is invisible.
The test must call <code>fixture.detectChanges()</code> manually to trigger another cycle of change detection.</p>
<p>第二和第三个测试程序显示了一个重要的局限性。
Angular测试环境<strong>不会</strong>知道测试程序改变了组件的<code>title</code>属性。
自动检测只对异步行为比如承诺的解析、计时器和DOM时间作出反应。
但是直接修改组件属性值的这种同步更新是不会触发<strong>自动检测</strong>的。
测试程序必须手动调用<code>fixture.detectChange()</code>，来触发新一轮的变更检测周期。</p>
<div class="alert is-helpful"><p>Rather than wonder when the test fixture will or won&#39;t perform change detection,
the samples in this guide <em>always call</em> <code>detectChanges()</code> <em>explicitly</em>.
There is no harm in calling <code>detectChanges()</code> more often than is strictly necessary.</p>
<p>与其怀疑测试工具会不会执行变更检测，本章中的例子<strong>总是显式</strong>调用<code>detectChanges()</code>。
即使是在不需要的时候，频繁调用<code>detectChanges()</code>没有任何什么坏处。</p>
</div><a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="component-with-external-template"></a><h2 id="test-a-component-with-an-external-template">Test a component with an external template</h2>
<h2 id="-">测试带有外部模板的组件</h2>
<p>The application&#39;s actual <code>BannerComponent</code> behaves the same as the version above but is implemented differently.
It has <em>external</em> template and css files, specified in <code>templateUrl</code> and <code>styleUrls</code> properties.</p>
<p>在实际应用中，<code>BannerComponent</code>的行为和刚才的版本相同，但是实现方式不同。
它有一个<em>外部</em>模板和CSS文件，通过<code>templateUrl</code>和<code>styleUrls</code>属性来指定。</p>
<div class="code-example"><header><h4>src/app/banner.component.ts</h4></header><code-example language="ts" format="">import { Component } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-banner&#39;,
  templateUrl: &#39;./banner.component.html&#39;,
  styleUrls:  [&#39;./banner.component.css&#39;]
})
export class BannerComponent {
  title = &#39;Test Tour of Heroes&#39;;
}
</code-example></div><p>That&#39;s a problem for the tests.
The <code>TestBed.createComponent</code> method is synchronous.
But the Angular template compiler must read the external files from the file system before it can create a component instance.
That&#39;s an asynchronous activity.
The previous setup for testing the inline component won&#39;t work for a component with an external template.</p>
<p>这些测试有一个问题。
<code>TestBed.createComponent</code>方法是同步的。
但是Angular模板编译器必须在创建组件实例之前先从文件系统中读取这些值，而这是异步的。
以前测试内联模板时使用的设置方式不适用于外部模板。</p>
<div id="async-in-before-each"></div><h3 id="the-first-asynchronous-_beforeeach_">The first asynchronous <em>beforeEach</em></h3>
<h3 id="-beforeeach-">第一个异步的<code>beforeEach</code></h3>
<p>The test setup for <code>BannerComponent</code> must give the Angular template compiler time to read the files.
The logic in the <code>beforeEach</code> of the previous spec is split into two <code>beforeEach</code> calls.
The first <code>beforeEach</code> handles asynchronous compilation.</p>
<p><code>BannerComponent</code>测试的设置方式必须给Angular模板编译器一些时间来读取文件。
以前放在<code>beforeEach</code>中的逻辑被拆分成了两个<code>beforeEach</code>调用。
第一个<code>beforeEach</code>处理异步编译工作。</p>
<div class="code-example"><header><h4>src/app/banner.component.spec.ts (first beforeEach)</h4></header><code-example language="ts" format="">// async beforeEach
beforeEach(async(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ BannerComponent ], // declare the test component
  })
  .compileComponents();  // compile template and css
}));
</code-example></div><p>Notice the <code>async</code> function called as the argument to <code>beforeEach</code>.
The <code>async</code> function is one of the Angular testing utilities and
has to be imported.</p>
<p>注意<code>async</code>函数被用作调用<code>beforeEach</code>的参数。
<code>async</code>函数是Angular测试工具集的一部分，这里必须引入它。</p>
<div class="code-example"><code-example language="ts" format="">import { async } from &#39;@angular/core/testing&#39;;
</code-example></div><p>It takes a parameterless function and <em>returns a function</em>
which becomes the true argument to the  <code>beforeEach</code>.</p>
<p>它接收一个无参数的函数，并<em>返回一个函数</em>，这个函数会作为实参传给<code>beforeEach</code>。</p>
<p>The body of the <code>async</code> argument looks much like the body of a synchronous <code>beforeEach</code>.
There is nothing obviously asynchronous about it.
For example, it doesn&#39;t return a promise and
there is no <code>done</code> function to call as there would be in standard Jasmine asynchronous tests.
Internally, <code>async</code> arranges for the body of the <code>beforeEach</code> to run in a special <em>async test zone</em>
that hides the mechanics of asynchronous execution.</p>
<p><code>async</code>参数的内容看起来非常像同步版<code>beforeEach</code>的函数体。
它并不能很明显的看出来这是异步函数。
比如它不返回承诺（Promise），并且也没有标准Jasmine异步测试时常用的<code>done</code>函数作为参数。
内部实现上，<code>async</code>会把<code>beforeEach</code>的函数体放进一个特殊的<em>异步测试区（async test zone）</em>，它隐藏了异步执行的内部机制。</p>
<p>All this is necessary in order to call the asynchronous <code>TestBed.compileComponents</code> method.</p>
<p>这就是为了调用异步的<code>TestBed.compileComponents</code>方法所要做的一切。</p>
<a id="compile-components"></a><h3 id="_compilecomponents_"><em>compileComponents</em></h3>
<p>The <code>TestBed.configureTestingModule</code> method returns the <code>TestBed</code> class so you can chain
calls to other <code>TestBed</code> static methods such as <code>compileComponents</code>.</p>
<p><code>TestBed.configureTestingModule</code>方法返回<code>TestBed</code>类，以便你可以链式调用<code>TestBed</code>的其它静态方法，比如<code>compileComponents</code>。</p>
<p>The <code>TestBed.compileComponents</code> method asynchronously compiles all the components configured in the testing module.
In this example, the <code>BannerComponent</code> is the only component to compile.
When <code>compileComponents</code> completes, the external templates and css files have been &quot;inlined&quot;
and <code>TestBed.createComponent</code> can create new instances of <code>BannerComponent</code> synchronously.</p>
<p><code>TestBed.compileComponents</code>方法会异步编译这个测试模块中配置的所有组件。
在这个例子中，<code>BannerComponent</code>是唯一要编译的组件。
当<code>compileComponents</code>完成时，外部组件和css文件会被“内联”，而<code>TestBed.createComponent</code>会用同步的方式创建一个<code>BannerComponent</code>的新实例。</p>
<div class="l-sub-section"><p>WebPack developers need not call <code>compileComponents</code> because it inlines templates and css
as part of the automated build process that precedes running the test.</p>
<p>WebPack用户不用调用<code>compileComponents</code>，因为它会在构建过程中自动内联模板和css，然后执行测试</p>
</div><p>In this example, <code>TestBed.compileComponents</code> only compiles the <code>BannerComponent</code>.
Tests later in the guide declare multiple components and
a few specs import entire application modules that hold yet more components.
Any of these components might have external templates and css files.
<code>TestBed.compileComponents</code> compiles all of the declared components asynchronously at one time.</p>
<p>在这个例子中，<code>TestBed.compileComponents</code>只会编译<code>BannerComponent</code>。
本章稍后的测试中会声明多个组件，并且少量规约中会导入包含多个组件的应用模块。所有这些组件都可能含有外部模板和css文件。
<code>TestBed.compileComponents</code>会同时异步编译所有这些声明的组件。</p>
<div class="alert is-important"><p>Do not configure the <code>TestBed</code> after calling <code>compileComponents</code>.
Make <code>compileComponents</code> the last step
before calling <code>TestBed.createComponent</code> to instantiate the <em>component-under-test</em>.</p>
<p>调用了<code>compileComponents</code>之后就不能再配置<code>TestBed</code>了。
务必确保<code>compileComponents</code>是调用<code>TestBed.createComponent</code>来实例化<em>待测组件</em>之前的最后一步。</p>
</div><p>Calling <code>compileComponents</code> closes the current <code>TestBed</code> instance is further configuration.
You cannot call any more <code>TestBed</code> configuration methods, not <code>configureTestingModule</code>
nor any of the <code>override...</code> methods. The <code>TestBed</code> throws an error if you try.</p>
<p><code>compileComponents</code>方法封闭了当前的<code>TestBed</code>实例，以免将来再配置它。
我们不能再调用任何<code>TestBed</code>的方法修改配置：不能调用<code>configureTestingModule</code>或任何<code>override...</code>方法。如果这么做，<code>TestBed</code>就会抛出错误。</p>
<a id="second-before-each"></a><h3 id="the-second-synchronous-_beforeeach_">The second synchronous <em>beforeEach</em></h3>
<h3 id="-beforeeach-">第二个同步<code>beforeEach</code></h3>
<p>A <em>synchronous</em> <code>beforeEach</code> containing the remaining setup steps follows the asynchronous <code>beforeEach</code>.</p>
<p>这个同步的<code>beforeEach</code>包含异步<code>beforeEach</code>之后的其余步骤。</p>
<div class="code-example"><header><h4>src/app/banner.component.spec.ts (second beforeEach)</h4></header><code-example language="ts" format="">// synchronous beforeEach
beforeEach(() =&gt; {
  fixture = TestBed.createComponent(BannerComponent);

  comp = fixture.componentInstance; // BannerComponent test instance

  // query for the title &lt;h1&gt; by CSS element selector
  de = fixture.debugElement.query(By.css(&#39;h1&#39;));
  el = de.nativeElement;
});
</code-example></div><p>These are the same steps as in the original <code>beforeEach</code>.
They include creating an instance of the <code>BannerComponent</code> and querying for the elements to inspect.</p>
<p>这些步骤和原来的<code>beforeEach</code>中相同。
包括创建<code>BannerComponent</code>实例和查询要审查的元素。</p>
<p>You can count on the test runner to wait for the first asynchronous <code>beforeEach</code> to finish before calling the second.</p>
<p>测试运行器（runner）会先等待第一个异步<code>beforeEach</code>函数执行完再调用第二个。</p>
<a id="waiting-compile-components"></a><h3 id="waiting-for-_compilecomponents_">Waiting for <em>compileComponents</em></h3>
<h3 id="-compilecomponents-">等待<code>compileComponents</code></h3>
<p>The <code>compileComponents</code> method returns a promise so you can perform additional tasks <em>immediately after</em> it finishes.
For example, you could move the synchronous code in the second <code>beforeEach</code>
into a <code>compileComponents().then(...)</code> callback and write only one <code>beforeEach</code>.</p>
<p><code>compileComponents</code>方法返回一个承诺，来让我们可以在它完成之后<em>立即</em>执行额外的任务。
比如，我们可以把第二个<code>beforeEach</code>中的同步代码移到一个<code>compileComponents().then(...)</code>回调中，从而只需要写一个<code>beforeEach</code>。</p>
<p>Most developers find that hard to read.
The two <code>beforeEach</code> calls are widely preferred.</p>
<p>大多数开发人员会觉得这样不易读，因此，更多采用的还是写两个<code>beforeEach</code>调用的方式。</p>
<h3 id="try-the-live-example">Try the live example</h3>
<h3 id="-">试试在线例子</h3>
<p>Take a moment to explore this component spec as a <live-example plnkr="banner-specs" title="Spec for component with external template" embedded-style></live-example>.</p>
<p>稍微花点时间，在<live-example plnkr="banner-specs" title="Spec for component with external template" embedded-style></live-example>中看看该组件的规约。</p>
<div class="l-sub-section"><p>The <a href="setup.html">Quickstart seed</a> provides a similar test of its <code>AppComponent</code>
as you can see in <em>this</em> <live-example name="setup" plnkr="quickstart-specs" title="QuickStart seed spec" embedded-style></live-example>.
It too calls <code>compileComponents</code> although it doesn&#39;t have to because the <code>AppComponent</code>&#39;s template is inline.</p>
<p><a href="setup.html">“快速起步” 种子工程</a>为其<code>AppComponent</code>提供了简单的测试，在<live-example name="setup" plnkr="quickstart-specs" title="QuickStart seed spec" embedded-style></live-example>中可以看到。
它也调用了<code>compileComponents</code>，不过它并不是必须这么做，因为<code>AppComponent</code>的模板是内联的。</p>
<p>There&#39;s no harm in it and you might call <code>compileComponents</code> anyway
in case you decide later to re-factor the template into a separate file.
The tests in this guide only call <code>compileComponents</code> when necessary.</p>
<p>这样做也没坏处，如果你将来可能会把模板重构到独立的文件中去，那就可以调用<code>compileComponents</code>。
不过本章中的这些测试只会在必要时才调用<code>compileComponents</code>。</p>
</div><a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="component-with-dependency"></a><h2 id="test-a-component-with-a-dependency">Test a component with a dependency</h2>
<h2 id="-">测试有依赖的组件</h2>
<p>Components often have service dependencies.</p>
<p>组件经常依赖其他服务。</p>
<p>The <code>WelcomeComponent</code> displays a welcome message to the logged in user.
It knows who the user is based on a property of the injected <code>UserService</code>:</p>
<p><code>WelcomeComponent</code>为登陆的用户显示一条欢迎信息。它从注入的<code>UserService</code>的属性得知用户的身份：</p>
<div class="code-example"><header><h4>src/app/welcome.component.ts</h4></header><code-example language="ts" format="">import { Component, OnInit } from &#39;@angular/core&#39;;
import { UserService }       from &#39;./model&#39;;

@Component({
  selector: &#39;app-welcome&#39;,
  template: &#39;&lt;h3 class=&quot;welcome&quot; &gt;&lt;i&gt;{{welcome}}&lt;/i&gt;&lt;/h3&gt;&#39;
})
export class WelcomeComponent  implements OnInit {
  welcome = &#39;-- not initialized yet --&#39;;
  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.welcome = this.userService.isLoggedIn ?
      &#39;Welcome, &#39; + this.userService.user.name :
      &#39;Please log in.&#39;;
  }
}
</code-example></div><p>The <code>WelcomeComponent</code> has decision logic that interacts with the service, logic that makes this component worth testing.
Here&#39;s the testing module configuration for the spec file, <code>src/app/welcome.component.spec.ts</code>:</p>
<p><code>WelcomeComponent</code>有与服务进行交互的决策逻辑，这样的逻辑让这个组件值得测试。下面是spec文件的测试模块配置，<code>src/app/welcome.component.spec.ts</code>：</p>
<div class="code-example"><header><h4>src/app/welcome.component.spec.ts</h4></header><code-example language="ts" format="">    TestBed.configureTestingModule({
       declarations: [ WelcomeComponent ],
    // providers:    [ UserService ]  // NO! Don&#39;t provide the real service!
                                      // Provide a test-double instead
       providers:    [ {provide: UserService, useValue: userServiceStub } ]
    });
</code-example></div><p>This time, in addition to declaring the <em>component-under-test</em>,
the configuration adds a <code>UserService</code> provider to the <code>providers</code> list.
But not the real <code>UserService</code>.</p>
<p>这次，在测试配置里不但声明了被测试的组件，而且在<code>providers</code>数组中添加了<code>UserService</code>依赖。但不是真实的<code>UserService</code>。</p>
<a id="service-test-doubles"> </a><h3 id="provide-service-test-doubles">Provide service test doubles</h3>
<h3 id="-">提供服务替身</h3>
<p>A <em>component-under-test</em> doesn&#39;t have to be injected with real services.
In fact, it is usually better if they are test doubles (stubs, fakes, spies, or mocks).
The purpose of the spec is to test the component, not the service,
and real services can be trouble.</p>
<p>被测试的组件不一定要注入真正的服务。实际上，服务的替身（stubs, fakes, spies或者mocks）通常会更加合适。
spec的主要目的是测试组件，而不是服务。真实的服务可能自身有问题。</p>
<p>Injecting the real <code>UserService</code> could be a nightmare.
The real service might ask the user for login credentials and
attempt to reach an authentication server.
These behaviors can be hard to intercept.
It is far easier and safer to create and register a test double in place of the real <code>UserService</code>.</p>
<p>注入真实的<code>UserService</code>有可能很麻烦。真实的服务可能询问用户登录凭据，也可能试图连接认证服务器。
可能很难处理这些行为。所以在真实的<code>UserService</code>的位置创建和注册<code>UserService</code>替身，会让测试更加容易和安全。</p>
<p>This particular test suite supplies a minimal <code>UserService</code> stub that satisfies the needs of the <code>WelcomeComponent</code>
and its tests:</p>
<p>这个测试套件提供了最小化的<code>UserService</code>stub类，用来满足<code>WelcomeComponent</code>和它的测试的需求：</p>
<div class="code-example"><code-example language="ts" format="">userServiceStub = {
  isLoggedIn: true,
  user: { name: &#39;Test User&#39;}
};
</code-example></div><a id="get-injected-service"></a><h3 id="get-injected-services">Get injected services</h3>
<h3 id="-">获取注入的服务</h3>
<p>The tests need access to the (stub) <code>UserService</code> injected into the <code>WelcomeComponent</code>.</p>
<p>测试程序需要访问被注入到<code>WelcomeComponent</code>中的<code>UserService</code>（stub类）。</p>
<p>Angular has a hierarchical injection system.
There can be injectors at multiple levels, from the root injector created by the <code>TestBed</code>
down through the component tree.</p>
<p>Angular的注入系统是层次化的。
可以有很多层注入器，从根<code>TestBed</code>创建的注入器下来贯穿整个组件树。</p>
<p>The safest way to get the injected service, the way that <strong><em>always works</em></strong>,
is to <strong>get it from the injector of the <em>component-under-test</em></strong>.
The component injector is a property of the fixture&#39;s <code>DebugElement</code>.</p>
<p>最安全并总是有效的获取注入服务的方法，是从被测试的组件的注入器获取。
组件注入器是fixture的<code>DebugElement</code>的属性。</p>
<div class="code-example"><header><h4>WelcomeComponent's injector</h4></header><code-example language="ts" format="">// UserService actually injected into the component
userService = fixture.debugElement.injector.get(UserService);
</code-example></div><a id="testbed-get"></a><h3 id="_testbed-get_"><em>TestBed.get</em></h3>
<p>You <em>may</em> also be able to get the service from the root injector via <code>TestBed.get</code>.
This is easier to remember and less verbose.
But it only works when Angular injects the component with the service instance in the test&#39;s root injector.
Fortunately, in this test suite, the <em>only</em> provider of <code>UserService</code> is the root testing module,
so it is safe to call <code>TestBed.get</code> as follows:</p>
<p>你<strong>可以</strong>通过<code>TestBed.get</code>方法来从根注入器中获取服务。
它更容易被记住，也更加简介。
但是只有在Angular使用测试的根注入器中的那个服务实例来注入到组件时，它才有效。
幸运的是，在这个测试套件中，<strong>唯一</strong>的<code>UserService</code>提供商就是根测试模块，所以像下面这样调用<code>TestBed.get</code>很安全：</p>
<div class="code-example"><header><h4>TestBed injector</h4></header><code-example language="ts" format="">// UserService from the root injector
userService = TestBed.get(UserService);
</code-example></div><div class="l-sub-section"><p>The <a href="#inject"><code>inject</code></a>  utility function is another way to get one or more services from the test root injector.</p>
<p><a href="#inject"><code>inject</code></a>辅助函数方法是另外一种从测试的根注入器注入一个或多个服务到测试的方法。</p>
<p>For a use case in which <code>inject</code> and <code>TestBed.get</code> do not work,
see the section <a href="#component-override"><em>Override a component&#39;s providers</em></a>, which
explains why you must get the service from the component&#39;s injector instead.</p>
<p>如果遇到了<code>inject</code>和<code>TestBed.get</code>无效，的情况，请到“<a href="#component-override"><strong>重载组件提供商</strong></a>”一节。那里会解释为什么要改用组件的注入器来获取服务。</p>
</div><a id="service-from-injector"></a><h3 id="always-get-the-service-from-an-injector">Always get the service from an injector</h3>
<h3 id="-">总是从注入器获取服务</h3>
<p>Do <em>not</em> reference the <code>userServiceStub</code> object
that&#39;s provided to the testing module in the body of your test.
<strong>It does not work!</strong>
The <code>userService</code> instance injected into the component is a completely <em>different</em> object,
a clone of the provided <code>userServiceStub</code>.</p>
<p>请不要引用测试代码里提供给测试模块的<code>userServiceStub</code>对象。<strong>这样不行！</strong>
被注入组件的<code>userService</code>实例是完全<strong>不一样</strong>的对象，它提供的是<code>userServiceStub</code>的克隆。</p>
<div class="code-example"><code-example language="ts" format="">it(&#39;stub object and injected UserService should not be the same&#39;, () =&gt; {
  expect(userServiceStub === userService).toBe(false);

  // Changing the stub object has no effect on the injected service
  userServiceStub.isLoggedIn = false;
  expect(userService.isLoggedIn).toBe(true);
});
</code-example></div><a id="welcome-spec-setup"></a><h3 id="final-setup-and-tests">Final setup and tests</h3>
<h3 id="-">最后的设置和测试程序</h3>
<p>Here&#39;s the complete <code>beforeEach</code> using <code>TestBed.get</code>:</p>
<p>这里是使用<code>TestBed.get</code>的完整<code>beforeEach</code>：</p>
<div class="code-example"><header><h4>src/app/welcome.component.spec.ts</h4></header><code-example language="ts" format="">  beforeEach(() =&gt; {
    // stub UserService for test purposes
    userServiceStub = {
      isLoggedIn: true,
      user: { name: &#39;Test User&#39;}
    };

    TestBed.configureTestingModule({
       declarations: [ WelcomeComponent ],
       providers:    [ {provide: UserService, useValue: userServiceStub } ]
    });

    fixture = TestBed.createComponent(WelcomeComponent);
    comp    = fixture.componentInstance;

    // UserService from the root injector
    userService = TestBed.get(UserService);

    //  get the &quot;welcome&quot; element by CSS selector (e.g., by class name)
    de = fixture.debugElement.query(By.css(&#39;.welcome&#39;));
    el = de.nativeElement;
  });
</code-example></div><p>And here are some tests:</p>
<p>下面是一些测试程序:</p>
<div class="code-example"><header><h4>src/app/welcome.component.spec.ts</h4></header><code-example language="ts" format="">it(&#39;should welcome the user&#39;, () =&gt; {
  fixture.detectChanges();
  const content = el.textContent;
  expect(content).toContain(&#39;Welcome&#39;, &#39;&quot;Welcome ...&quot;&#39;);
  expect(content).toContain(&#39;Test User&#39;, &#39;expected name&#39;);
});

it(&#39;should welcome &quot;Bubba&quot;&#39;, () =&gt; {
  userService.user.name = &#39;Bubba&#39;; // welcome message hasn&#39;t been shown yet
  fixture.detectChanges();
  expect(el.textContent).toContain(&#39;Bubba&#39;);
});

it(&#39;should request login if not logged in&#39;, () =&gt; {
  userService.isLoggedIn = false; // welcome message hasn&#39;t been shown yet
  fixture.detectChanges();
  const content = el.textContent;
  expect(content).not.toContain(&#39;Welcome&#39;, &#39;not welcomed&#39;);
  expect(content).toMatch(/log in/i, &#39;&quot;log in&quot;&#39;);
});
</code-example></div><p>The first is a sanity test; it confirms that the stubbed <code>UserService</code> is called and working.</p>
<p>第一个测试程序是合法测试程序，它确认这个被模拟的<code>UserService</code>是否被调用和工作正常。</p>
<div class="l-sub-section"><p>The second parameter to the Jasmine <code>it</code> (e.g., <code>&#39;expected name&#39;</code>) is an optional addendum.
If the expectation fails, Jasmine displays this addendum after the expectation failure message.
In a spec with multiple expectations, it can help clarify what went wrong and which expectation failed . </p>
<p>Jasmine的<code>it</code>方法的第二个参数（比如<code>&#39;expected name&#39;</code>）是可选附加参数。
如果这个期待失败了，Jasmine在期待失败信息后面显示这个附加参数。
在拥有多个期待的spec中，它可以帮助澄清发生了什么错误，哪个期待失败了。</p>
</div><p>The remaining tests confirm the logic of the component when the service returns different values.
The second test validates the effect of changing the user name.
The third test checks that the component displays the proper message when there is no logged-in user.</p>
<p>接下来的测试程序确认当服务返回不同的值时组件的逻辑是否工作正常。
第二个测试程序验证变换用户名字的效果。
第三个测试程序检查如果用户没有登录，组件是否显示正确消息。</p>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="component-with-async-service"></a><h2 id="test-a-component-with-an-async-service">Test a component with an async service</h2>
<h2 id="-">测试有异步服务的组件</h2>
<p>Many services return values asynchronously.
Most data services make an HTTP request to a remote server and the response is necessarily asynchronous.</p>
<p>许多服务异步返回值。大部分数据服务向远程服务器发起HTTP请求，响应必然是异步的。</p>
<p>The &quot;About&quot; view in this sample displays Mark Twain quotes.
The <code>TwainComponent</code> handles the display, delegating the server request to the <code>TwainService</code>.</p>
<p>本例的<code>About</code>视图显示马克吐温的名言。
<code>TwainComponent</code>组件处理视图，并委派<code>TwainService</code>向服务器发起请求。</p>
<p>Both are in the <code>src/app/shared</code> folder because the author intends to display Twain quotes on other pages someday.
Here is the <code>TwainComponent</code>.</p>
<p>两者都在<code>app/shared</code>目录里，因为作者计划将来在其它页面也显示马克吐温的名言。
下面是<code>TwainComponent</code>：</p>
<div class="code-example"><header><h4>src/app/shared/twain.component.ts</h4></header><code-example language="ts" format="">@Component({
  selector: &#39;twain-quote&#39;,
  template: &#39;&lt;p class=&quot;twain&quot;&gt;&lt;i&gt;{{quote}}&lt;/i&gt;&lt;/p&gt;&#39;
})
export class TwainComponent  implements OnInit {
  intervalId: number;
  quote = &#39;...&#39;;
  constructor(private twainService: TwainService) { }

  ngOnInit(): void {
    this.twainService.getQuote().then(quote =&gt; this.quote = quote);
  }
}
</code-example></div><p>The <code>TwainService</code> implementation is irrelevant for this particular test.
It is sufficient to see within <code>ngOnInit</code> that <code>twainService.getQuote</code> returns a promise, which means it is asynchronous.</p>
<p><code>TwainService</code>的实现细节现在并不重要。
<code>ngOnInit</code>的<code>twainService.getQuote</code>返回承诺，所以显然它是异步的。</p>
<p>In general, tests should not make calls to remote servers. 
They should emulate such calls. The setup in this <code>src/app/shared/twain.component.spec.ts</code> shows one way to do that: </p>
<p>一般来讲，测试程序不应该向远程服务器发请求。
它们应该仿真这样的请求。<code>src/app/shared/twain.component.spec.ts</code>里的配置是其中一种伪造方法：</p>
<div class="code-example"><header><h4>src/app/shared/twain.component.spec.ts (setup)</h4></header><code-example language="ts" format="">  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
       declarations: [ TwainComponent ],
       providers:    [ TwainService ],
    });

    fixture = TestBed.createComponent(TwainComponent);
    comp    = fixture.componentInstance;

    // TwainService actually injected into the component
    twainService = fixture.debugElement.injector.get(TwainService);

    // Setup spy on the `getQuote` method
    spy = spyOn(twainService, &#39;getQuote&#39;)
          .and.returnValue(Promise.resolve(testQuote));

    // Get the Twain quote element by CSS selector (e.g., by class name)
    de = fixture.debugElement.query(By.css(&#39;.twain&#39;));
    el = de.nativeElement;
  });
</code-example></div><a id="service-spy"></a><h3 id="spying-on-the-real-service">Spying on the real service</h3>
<h3 id="-spy-">刺探(Spy)真实服务</h3>
<p>This setup is similar to the <a href="#welcome-spec-setup"><code>welcome.component.spec</code> setup</a>.
But instead of creating a stubbed service object, it injects the <em>real</em> service (see the testing module <code>providers</code>) and
replaces the critical <code>getQuote</code> method with a Jasmine spy.</p>
<p>本配置与<a href="#welcome-spec-setup"><code>welcome.component.spec</code>配置</a>类似。
但是与其伪造服务对象，它注入了真实的服务（参见测试模块的<code>providers</code>），并用Jasmine的<code>spy</code>替换关键的<code>getQuote</code>方法。</p>
<div class="code-example"><code-example language="ts" format="">spy = spyOn(twainService, &#39;getQuote&#39;)
      .and.returnValue(Promise.resolve(testQuote));
</code-example></div><p>The spy is designed such that any call to <code>getQuote</code> receives an immediately resolved promise with a test quote.
The spy bypasses the actual <code>getQuote</code> method and therefore does not contact the server.</p>
<p>这个Spy的设计是，所有调用<code>getQuote</code>的方法都会收到立刻解析的承诺，得到一条预设的名言。Spy拦截了实际<code>getQuote</code>方法，所有它不会联系服务。</p>
<div class="l-sub-section"><p>Faking a service instance and spying on the real service are <em>both</em> great options.
Pick the one that seems easiest for the current test suite.
Don&#39;t be afraid to change your mind.</p>
<p>伪造服务实例和刺探真实服务都是好方法。挑选一种对当前测试套件最简单的方法。你可以随时改变主意。</p>
<p>Spying on the real service isn&#39;t always easy, especially when the real service has injected dependencies.
You can <em>stub and spy</em> at the same time, as shown in <a href="#spy-stub">an example below</a>.</p>
<p>刺探真实的服务往往并不容易，特别是真实的服务依赖其它服务时。
我们可以同时<em>打桩和刺探</em>，就像<a href="#spy-stub">后面的例子</a>那样。</p>
</div><p>Here are the tests with commentary to follow:</p>
<p>下面是接下来带有注解的测试程序：</p>
<div class="code-example"><header><h4>src/app/shared/twain.component.spec.ts (tests)</h4></header><code-example language="ts" format="linenums">  it(&#39;should not show quote before OnInit&#39;, () =&gt; {
    expect(el.textContent).toBe(&#39;&#39;, &#39;nothing displayed&#39;);
    expect(spy.calls.any()).toBe(false, &#39;getQuote not yet called&#39;);
  });

  it(&#39;should still not show quote after component initialized&#39;, () =&gt; {
    fixture.detectChanges();
    // getQuote service is async =&gt; still has not returned with quote
    expect(el.textContent).toBe(&#39;...&#39;, &#39;no quote yet&#39;);
    expect(spy.calls.any()).toBe(true, &#39;getQuote called&#39;);
  });

  it(&#39;should show quote after getQuote promise (async)&#39;, async(() =&gt; {
    fixture.detectChanges();

    fixture.whenStable().then(() =&gt; { // wait for async getQuote
      fixture.detectChanges();        // update view with quote
      expect(el.textContent).toBe(testQuote);
    });
  }));

  it(&#39;should show quote after getQuote promise (fakeAsync)&#39;, fakeAsync(() =&gt; {
    fixture.detectChanges();
    tick();                  // wait for async getQuote
    fixture.detectChanges(); // update view with quote
    expect(el.textContent).toBe(testQuote);
  }));
</code-example></div><a id="sync-tests"></a><h3 id="synchronous-tests">Synchronous tests</h3>
<h3 id="-">同步测试程序</h3>
<p>The first two tests are synchronous.
Thanks to the spy, they verify that <code>getQuote</code> is called <em>after</em>
the first change detection cycle during which Angular calls <code>ngOnInit</code>.</p>
<p>前两个测试程序是同步的。
在Spy的帮助下，它们验证了在Angular调用<code>ngOnInit</code>期间发生的第一次变更检测后，<code>getQuote</code>被调用了。</p>
<p>Neither test can prove that a value from the service is displayed.
The quote itself has not arrived, despite the fact that the spy returns a resolved promise.</p>
<p>两者都不能证明被显示的值是服务提供的。
虽然spy返回了解析的承诺，名言本身还没有到来。</p>
<p>This test must wait at least one full turn of the JavaScript engine before the
value becomes available. The test must become <em>asynchronous</em>.</p>
<p>这个测试程序必须等待JavaScript引擎一整个回合，返回值才会有效。该测试程序必须要变成<strong>异步的</strong>。</p>
<a id="async"></a><h3 id="the-_async_-function-in-_it_">The <em>async</em> function in <em>it</em></h3>
<h3 id="-it-async-"><strong>it</strong>里的<strong>async</strong>函数方法</h3>
<p>Notice the <code>async</code> in the third test.</p>
<p>注意第三个测试程序的<code>async</code>方法。</p>
<div class="code-example"><header><h4>src/app/shared/twain.component.spec.ts (async test)</h4></header><code-example language="ts" format="">it(&#39;should show quote after getQuote promise (async)&#39;, async(() =&gt; {
  fixture.detectChanges();

  fixture.whenStable().then(() =&gt; { // wait for async getQuote
    fixture.detectChanges();        // update view with quote
    expect(el.textContent).toBe(testQuote);
  });
}));
</code-example></div><p>The <code>async</code> function is one of the Angular testing utilities.
It simplifies coding of asynchronous tests by arranging for the tester&#39;s code to run in a special <em>async test zone</em>
as <a href="#async-in-before-each">discussed earlier</a> when it was called in a <code>beforeEach</code>.</p>
<p><code>async</code>函数是<strong>Angular TestBed</strong>的一部分。通过将测试代码放到特殊的<strong>异步测试区域</strong>来运行，<code>async</code>函数简化了异步测试程序的代码。就像<a href="#async-in-before-each">以前讨论过的</a>，它会在<code>beforeEach</code>中被调用。</p>
<p>Although <code>async</code> does a great job of hiding asynchronous boilerplate,
some functions called within a test (such as <code>fixture.whenStable</code>) continue to reveal their asynchronous behavior.</p>
<p>虽然<code>async</code>做了很多工作来尽量隐藏异步特性，但在测试程序（比如<code>fixture.whenStable</code>）里面调用函数时，有时还是会体现它们的异步行为。</p>
<div class="l-sub-section"><p>The <code>fakeAsync</code> alternative, <a href="#fake-async">covered below</a>, removes this artifact and affords a more linear coding experience.</p>
<p><code>fakeAsync</code>可选方法，<a href="#fake-async">正如下面解释的</a>，进一步移除了异步行为，提供了更加直观的代码经验。</p>
</div><a id="when-stable"></a><h3 id="_whenstable_"><em>whenStable</em></h3>
<p>The test must wait for the <code>getQuote</code> promise to resolve in the next turn of the JavaScript engine.</p>
<p>测试程序必须等待<code>getQuote</code>在JavaScript引擎的下一回合中被解析。</p>
<p>This test has no direct access to the promise returned by the call to <code>twainService.getQuote</code>
because it is buried inside <code>TwainComponent.ngOnInit</code> and therefore inaccessible to a test that
probes only the component API surface.</p>
<p>本测试对<code>twainService.getQuote</code>返回的承诺没有直接的访问，因为它被埋没在<code>TwainComponent.ngOnInit</code>里，
所以对于只测试组件API表面的测试来说，它是无法被访问的。</p>
<p>Fortunately, the <code>getQuote</code> promise is accessible to the <em>async test zone</em> ,
which intercepts all promises issued within the <em>async</em> method call <em>no matter where they occur</em>.</p>
<p>幸运的是，<strong>异步测试区域</strong>可以访问<code>getQuote</code>承诺，因为它拦截所有调用<strong>异步</strong>方法所发出的承诺，不管它们在哪儿。</p>
<p>The <code>ComponentFixture.whenStable</code> method returns its own promise, which resolves when the <code>getQuote</code> promise finishes.
In fact, the <em>whenStable</em> promise resolves when <em>all pending asynchronous activities within this test</em> complete &mdash; the definition of &quot;stable.&quot;</p>
<p><code>ComponentFixture.whenStable</code>方法返回它自己的承诺，它在<code>getQuote</code>承诺完成时被解析。实际上，“stable”的意思是当<strong>所有待处理异步行为</strong>完成时的状态，在“stable”后<strong>whenStable</strong>承诺被解析。</p>
<p>Then the test resumes and kicks off another round of change detection (<code>fixture.detectChanges</code>),
which tells Angular to update the DOM with the quote.
The <code>getQuote</code> helper method extracts the display element text and the expectation confirms that the text matches the test quote.</p>
<p>然后测试程序继续运行，并开始另一轮的变更检测（<code>fixture.detectChanges</code>）,通知Angular使用名言来更新DOM。
<code>getQuote</code>辅助方法提取出显示元素文本，然后expect语句确认这个文本与预备的名言相符。</p>
<a id="fakeAsync"></a><a id="fake-async"></a><h3 id="the-_fakeasync_-function">The <em>fakeAsync</em> function</h3>
<h3 id="-fakeasync-"><strong>fakeAsync</strong>函数方法</h3>
<p>The fourth test verifies the same component behavior in a different way.</p>
<p>第四个测试程序用不同的方法验证同样的组件行为。</p>
<div class="code-example"><header><h4>src/app/shared/twain.component.spec.ts (fakeAsync test)</h4></header><code-example language="ts" format="">it(&#39;should show quote after getQuote promise (fakeAsync)&#39;, fakeAsync(() =&gt; {
  fixture.detectChanges();
  tick();                  // wait for async getQuote
  fixture.detectChanges(); // update view with quote
  expect(el.textContent).toBe(testQuote);
}));
</code-example></div><p>Notice that <code>fakeAsync</code> replaces <code>async</code> as the <code>it</code> argument.
The <code>fakeAsync</code> function is another of the Angular testing utilities.</p>
<p>注意，在<code>it</code>的参数中，<code>async</code>被<code>faceAsync</code>替换。
<code>fakeAsync</code>是另一种Angular测试工具。</p>
<p>Like <a href="#async">async</a>, it <em>takes</em> a parameterless function and <em>returns</em> a function
that becomes the argument to the  Jasmine <code>it</code> call.</p>
<p>和<a href="#async">async</a>一样，它也<strong>接受</strong>无参数函数并<strong>返回</strong>一个函数，变成Jasmine的<code>it</code>函数的参数。</p>
<p>The <code>fakeAsync</code> function enables a linear coding style by running the test body in a special <em>fakeAsync test zone</em>.</p>
<p><code>fakeAsync</code>函数通过在特殊的<strong>fakeAsync测试区域</strong>运行测试程序，让测试代码更加简单直观。</p>
<p>The principle advantage of <code>fakeAsync</code> over <code>async</code> is that the test appears to be synchronous.
There is no <code>then(...)</code> to disrupt the visible flow of control.
The promise-returning <code>fixture.whenStable</code> is gone, replaced by <code>tick()</code>.</p>
<p>对于<code>async</code>来说，<code>fakeAsync</code>最重要的好处是测试程序看起来像同步的。里面没有任何承诺。
没有<code>then(...)</code>链来打断控制流。</p>
<div class="l-sub-section"><p>There <em>are</em> limitations. For example, you cannot make an XHR call from within a <code>fakeAsync</code>.</p>
<p>但是<code>fakeAsync</code>有局限性。比如，你不能从<code>fakeAsync</code>发起XHR请求。</p>
</div><a id="tick"></a><h3 id="the-_tick_-function">The <em>tick</em> function</h3>
<h3 id="-tick-"><strong>tick</strong>函数</h3>
<p>The <code>tick</code> function is one of the Angular testing utilities and a companion to <code>fakeAsync</code>.
You can only call it within a <code>fakeAsync</code> body.</p>
<p><code>tick</code>函数是Angular测试工具之一，是<code>fakeAsync</code>的同伴。
它只能在<code>fakeAsync</code>的主体中被调用。</p>
<p>Calling <code>tick()</code> simulates the passage of time until all pending asynchronous activities finish,
including the resolution of the <code>getQuote</code> promise in this test case.</p>
<p>调用<code>tick()</code>模拟时间的推移，直到全部待处理的异步任务都已完成，在这个测试案例中，包含<code>getQuote</code>承诺的解析。</p>
<p>It returns nothing. There is no promise to wait for.
Proceed with the same test code that appeared in the <code>whenStable.then()</code> callback.</p>
<p>它不返回任何结果。没有任何承诺需要等待。
直接执行与之前在<code>whenStable.then()</code>的回调函数里相同的代码。</p>
<p>Even this simple example is easier to read than the third test.
To more fully appreciate the improvement, imagine a succession of asynchronous operations,
chained in a long sequence of promise callbacks.</p>
<p>虽然这个例子非常简单，但是它已经比第三个测试程序更易阅读。
为了更充分的体会<code>fakeAsync</code>的好处，试想一下一连串的异步操作，被一长串的承诺回调链在一起。</p>
<a id="jasmine-done"></a><h3 id="_jasmine-done_"><em>jasmine.done</em></h3>
<p>While the <code>async</code> and <code>fakeAsync</code> functions greatly
simplify Angular asynchronous testing,
you can still fall back to the traditional Jasmine asynchronous testing technique.</p>
<p>虽然<code>async</code>和<code>fakeAsync</code>函数大大的简化了异步测试，你仍然可以回退到传统的Jasmine异步测试技术上。</p>
<p>You can still pass <code>it</code> a function that takes a
<a href="http://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support"><code>done</code> callback</a>.
Now you are responsible for chaining promises, handling errors, and calling <code>done</code> at the appropriate moment.</p>
<p>你仍然可以将接受 <a href="http://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support"><code>done</code>回调</a>的函数传给<code>it</code>。
但是，你必须链接承诺、处理错误，并在适当的时候调用<code>done</code>。</p>
<p>Here is a <code>done</code> version of the previous two tests:</p>
<p>下面是上面两个测试程序的<code>done</code>版本：</p>
<div class="code-example"><header><h4>src/app/shared/twain.component.spec.ts (done test)</h4></header><code-example language="ts" format="">it(&#39;should show quote after getQuote promise (done)&#39;, (done: any) =&gt; {
  fixture.detectChanges();

  // get the spy promise and wait for it to resolve
  spy.calls.mostRecent().returnValue.then(() =&gt; {
    fixture.detectChanges(); // update view with quote
    expect(el.textContent).toBe(testQuote);
    done();
  });
});
</code-example></div><p>Although there is no direct access to the <code>getQuote</code> promise inside <code>TwainComponent</code>,
the spy has direct access, which makes it possible to wait for <code>getQuote</code> to finish.</p>
<p>虽然我们对<code>TwainComponent</code>里的<code>getQuote</code>承诺没有直接访问，但是Spy有，所以才可能等待<code>getQuote</code>完成。</p>
<p>Writing test functions with <code>done</code>, while more cumbersome than <code>async</code>
and <code>fakeAsync</code>, is a viable and occasionally necessary technique.
For example, you can&#39;t call <code>async</code> or <code>fakeAsync</code> when testing
code that involves the <code>intervalTimer</code>, as is common when
testing async <code>Observable</code> methods.</p>
<p>写带有<code>done</code>回调的测试函数，虽然比<code>async</code>和<code>fakeAsync</code>函数笨拙，但是在少数偶然情况下却是很有必要的技巧。比如，当测试涉及<code>intervalTimer</code>的代码时，你就没法调用<code>async</code>和<code>fakeAsync</code>函数，在测试异步<code>Observable</code>函数时也一样。</p>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="component-with-input-output"></a><h2 id="test-a-component-with-inputs-and-outputs">Test a component with inputs and outputs</h2>
<h2 id="-inputs-outputs-">测试带有导入inputs和导出outputs的组件</h2>
<p>A component with inputs and outputs typically appears inside the view template of a host component.
The host uses a property binding to set the input property and an event binding to
listen to events raised by the output property.</p>
<p>带有导入和导出的组件通常出现在宿主组件的视图模板中。
宿主使用属性绑定来设置输入属性，使用事件绑定来监听输出属性触发的事件。</p>
<p>The testing goal is to verify that such bindings work as expected.
The tests should set input values and listen for output events.</p>
<p>测试的目的是验证这样的绑定和期待的那样正常工作。
测试程序应该设置导入值并监听导出事件。</p>
<p>The <code>DashboardHeroComponent</code> is a tiny example of a component in this role.
It displays an individual hero provided by the <code>DashboardComponent</code>.
Clicking that hero tells the <code>DashboardComponent</code> that the user has selected the hero.</p>
<p><code>DashboardHeroComponent</code>是非常小的这种类型的例子组件。
它显示由<code>DashboardCompoent</code>提供的英雄个体。
点击英雄告诉<code>DashbaordComponent</code>用户已经选择了这个英雄。</p>
<p>The <code>DashboardHeroComponent</code> is embedded in the <code>DashboardComponent</code> template like this:</p>
<p><code>DashboardHeroComponent</code>是这样内嵌在<code>DashboardCompoent</code>的模板中的：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard.component.html (excerpt)</h4></header><code-example language="html" format="">&lt;dashboard-hero *ngFor=&quot;let hero of heroes&quot;  class=&quot;col-1-4&quot;
  [hero]=hero  (selected)=&quot;gotoDetail($event)&quot; &gt;
&lt;/dashboard-hero&gt;
</code-example></div><p>The <code>DashboardHeroComponent</code> appears in an <code>*ngFor</code> repeater, which sets each component&#39;s <code>hero</code> input property
to the looping value and listens for the component&#39;s <code>selected</code> event.</p>
<p><code>DashboardHeroComponent</code>在<code>*ngFor</code>循环中出现，设置每个组件的<code>hero</code>input属性到迭代的值，并监听组件的<code>selected</code>事件。</p>
<p>Here&#39;s the component&#39;s definition:</p>
<p>下面是组件的定义：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard-hero.component.ts (component)</h4></header><code-example language="ts" format="">@Component({
  selector:    &#39;dashboard-hero&#39;,
  templateUrl: &#39;./dashboard-hero.component.html&#39;,
  styleUrls: [ &#39;./dashboard-hero.component.css&#39; ]
})
export class DashboardHeroComponent {
  @Input() hero: Hero;
  @Output() selected = new EventEmitter&lt;Hero&gt;();
  click() { this.selected.emit(this.hero); }
}
</code-example></div><p>While testing a component this simple has little intrinsic value, it&#39;s worth knowing how.
You can use one of these approaches:</p>
<p>虽然测试这么简单的组件没有什么内在价值，但是它的测试程序是值得学习的。
  有下列候选测试方案：</p>
<ul>
<li><p>Test it as used by <code>DashboardComponent</code>.</p>
<p>把它当作被<code>DashbaordComponent</code>使用的组件来测试</p>
</li>
<li><p>Test it as a stand-alone component.</p>
<p>把它当作独立的组件来测试</p>
</li>
<li><p>Test it as used by a substitute for <code>DashboardComponent</code>.</p>
<p>把它当作被<code>DashbaordComponent</code>的替代组件使用的组件来测试</p>
</li>
</ul>
<p>A quick look at the <code>DashboardComponent</code> constructor discourages the first approach:</p>
<p>简单看看<code>DashbaordComponent</code>的构造函数就否决了第一种方案：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard.component.ts (constructor)</h4></header><code-example language="ts" format="">constructor(
  private router: Router,
  private heroService: HeroService) {
}
</code-example></div><p>The <code>DashboardComponent</code> depends on the Angular router and the <code>HeroService</code>.
You&#39;d probably have to replace them both with test doubles, which is a lot of work.
The router seems particularly challenging.</p>
<p><code>DashbaordComponent</code>依赖Angular路由器和<code>HeroService</code>服务。
你必须使用测试替身替换它们两个，似乎过于复杂了。
路由器尤其具有挑战性。</p>
<div class="l-sub-section"><p>The <a href="#routed-component">discussion below</a> covers testing components that require the router.</p>
<p><a href="#routed-component">下面</a> 覆盖了如何测试带有路由器的组件。</p>
</div><p>The immediate goal is to test the <code>DashboardHeroComponent</code>, not the <code>DashboardComponent</code>,
so, try the second and third options.</p>
<p>当前的任务是测试<code>DashboardHeroComponent</code>组件，而非<code>DashbaordComponent</code>，所以无需做不必要的努力。
让我们尝试第二和第三种方案。</p>
<a id="dashboard-standalone"></a><h3 id="test-_dashboardherocomponent_-stand-alone">Test <em>DashboardHeroComponent</em> stand-alone</h3>
<h3 id="-_dashboardherocomponent_">独立测试<em>DashboardHeroComponent</em></h3>
<p>Here&#39;s the spec file setup.</p>
<p>下面是spec文件的设置。</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard-hero.component.spec.ts (setup)</h4></header><code-example language="ts" format="">  // async beforeEach
  beforeEach( async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ DashboardHeroComponent ],
    })
    .compileComponents(); // compile template and css
  }));

  // synchronous beforeEach
  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(DashboardHeroComponent);
    comp    = fixture.componentInstance;
    heroEl  = fixture.debugElement.query(By.css(&#39;.hero&#39;)); // find hero element

    // pretend that it was wired to something that supplied a hero
    expectedHero = new Hero(42, &#39;Test Name&#39;);
    comp.hero = expectedHero;
    fixture.detectChanges(); // trigger initial data binding
  });
</code-example></div><p>The async <code>beforeEach</code> was discussed <a href="#component-with-external-template">above</a>.
Having compiled the components asynchronously with <code>compileComponents</code>, the rest of the setup
proceeds <em>synchronously</em> in a <em>second</em> <code>beforeEach</code>, using the basic techniques described <a href="#simple-component-test">earlier</a>.</p>
<p>异步<code>beforeEach</code>已经在<a href="#component-with-external-template">上面</a>讨论过。
在使用<code>compileComponents</code>异步编译完组件后，接下来的设置执行另一个<strong>同步</strong>的<code>beforeEach</code>，使用<a href="#simple-component-test">之前</a>解释过的基本知识。</p>
<p>Note how the setup code assigns a test hero (<code>expectedHero</code>) to the component&#39;s <code>hero</code> property, emulating
the way the <code>DashboardComponent</code> would set it via the property binding in its repeater.</p>
<p>注意代码是如何将模拟英雄（<code>expectedHero</code>）赋值给组件的<code>hero</code>属性的，模拟了<code>DashbaordComponent</code>在它的迭代器中通过属性绑定的赋值方式。</p>
<p>The first test follows:</p>
<p>紧接着第一个测试程序：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard-hero.component.spec.ts (name test)</h4></header><code-example language="ts" format="">it(&#39;should display hero name&#39;, () =&gt; {
  const expectedPipedName = expectedHero.name.toUpperCase();
  expect(heroEl.nativeElement.textContent).toContain(expectedPipedName);
});
</code-example></div><p>It verifies that the hero name is propagated to template with a binding.
Because the template passes the hero name through the Angular <code>UpperCasePipe</code>,
the test must match the element value with the uppercased name:</p>
<p>它验证了英雄名字通过绑定被传递到模板了。这里有个额外步骤。模板将英雄名字传给Angular的<code>UpperCasePipe</code>，
所以测试程序必须使用大写名字来匹配元素的值：</p>
<div class="code-example"><code-example language="html" format="">&lt;div (click)=&quot;click()&quot; class=&quot;hero&quot;&gt;
  {{hero.name | uppercase}}
&lt;/div&gt;
</code-example></div><div class="alert is-helpful"><p>This small test demonstrates how Angular tests can verify a component&#39;s visual
representation&mdash;something not possible with
<a href="#isolated-component-tests">isolated unit tests</a>&mdash;at
low cost and without resorting to much slower and more complicated end-to-end tests.</p>
<p>这个小测试演示了Angular测试是如何验证组件的视图表现的 —— 这是<a href="#isolated-component-tests">孤立的单元测试</a>无法实现的
—— 它成本低，而且无需依靠更慢、更复杂的端对端测试。</p>
</div><p>The second test verifies click behavior. Clicking the hero should raise a <code>selected</code> event that the
host component (<code>DashboardComponent</code> presumably) can hear:</p>
<p>第二个测试程序验证点击行为。点击英雄应该出发<code>selected</code>事件，可供宿主组件(<code>DashbaordComponent</code>)监听：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard-hero.component.spec.ts (click test)</h4></header><code-example language="ts" format="">  it(&#39;should raise selected event when clicked&#39;, () =&gt; {
    let selectedHero: Hero;
    comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);

    heroEl.triggerEventHandler(&#39;click&#39;, null);
    expect(selectedHero).toBe(expectedHero);
  });
</code-example></div><p>The component exposes an <code>EventEmitter</code> property. The test subscribes to it just as the host component would do.</p>
<p>这个组件公开<code>EventEmitter</code>属性。测试程序像宿主组件那样来描述它。</p>
<p>The <code>heroEl</code> is a <code>DebugElement</code> that represents the hero <code>&lt;div&gt;</code>.
The test calls <code>triggerEventHandler</code> with the &quot;click&quot; event name.
The &quot;click&quot; event binding responds by calling <code>DashboardHeroComponent.click()</code>. </p>
<p><code>heroEl</code>是个<code>DebugElement</code>，它代表了英雄所在的<code>&lt;div&gt;</code>。
测试程序用“click”事件名字来调用<code>triggerEventHandler</code>。
调用<code>DashboardHeroComponent.click()</code>时，“click”事件绑定作出响应。</p>
<p>If the component behaves as expected, <code>click()</code> tells the component&#39;s <code>selected</code> property to emit the <code>hero</code> object,
the test detects that value through its subscription to <code>selected</code>, and the test should pass.</p>
<p>如果组件像期待的那样工作，<code>click()</code>通知组件的<code>selected</code>属性就会发出<code>hero</code>对象，测试程序通过订阅<code>selected</code>事件而检测到这个值，所以测试应该成功。</p>
<a id="trigger-event-handler"></a><h3 id="_triggereventhandler_"><em>triggerEventHandler</em></h3>
<p>The Angular <code>DebugElement.triggerEventHandler</code> can raise <em>any data-bound event</em> by its <em>event name</em>.
The second parameter is the event object passed to the handler.</p>
<p>Angular的<code>DebugElement.triggerEventHandler</code>可以用<strong>事件的名字</strong>触发<strong>任何数据绑定事件</strong>。
第二个参数是传递给事件处理器的事件对象。</p>
<p>In this example, the test triggers a &quot;click&quot; event with a null event object.</p>
<p>本例中，测试程序用null事件对象触发“click”事件。</p>
<div class="code-example"><code-example language="ts" format="">heroEl.triggerEventHandler(&#39;click&#39;, null);
</code-example></div><p>The test assumes (correctly in this case) that the runtime
event handler&mdash;the component&#39;s <code>click()</code> method&mdash;doesn&#39;t
care about the event object.</p>
<p>测试程序假设（在这里应该这样)运行时间的事件处理器——组件的<code>click()</code>方法——不关心事件对象。</p>
<p>Other handlers are less forgiving. For example, the <code>RouterLink</code>
directive expects an object with a <code>button</code> property
that identifies which mouse button was pressed.
This directive throws an error if the event object doesn&#39;t do this correctly.</p>
<p>其它处理器将会更加严格。
比如，<code>RouterLink</code>指令期待事件对象，并且该对象具有<code>button</code>属性，代表了已被按下的鼠标按钮。
如果该事件对象不具备上面的条件，指令便会抛出错误。</p>
<a id="click-helper"></a><p>Clicking a button, an anchor, or an arbitrary HTML element is a common test task.</p>
<p>点击按钮、链接或者任意HTML元素是很常见的测试任务。</p>
<p>Make that easy by encapsulating the <em>click-triggering</em> process in a helper such as the <code>click</code> function below:</p>
<p>把<strong>click触发</strong>过程封装到辅助方法中可以简化这个任务，比如下面的<code>click</code>辅助方法：</p>
<div class="code-example"><header><h4>testing/index.ts (click helper)</h4></header><code-example language="ts" format="">/** Button events to pass to `DebugElement.triggerEventHandler` for RouterLink event handler */
export const ButtonClickEvents = {
   left:  { button: 0 },
   right: { button: 2 }
};

/** Simulate element click. Defaults to mouse left-button click event. */
export function click(el: DebugElement | HTMLElement, eventObj: any = ButtonClickEvents.left): void {
  if (el instanceof HTMLElement) {
    el.click();
  } else {
    el.triggerEventHandler(&#39;click&#39;, eventObj);
  }
}
</code-example></div><p>The first parameter is the <em>element-to-click</em>. If you wish, you can pass a
custom event object as the second parameter. The default is a (partial)
<a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button" target="_blank">left-button mouse event object</a>
accepted by many handlers including the <code>RouterLink</code> directive.</p>
<p>第一个参数是<strong>用来点击的元素</strong>。如果你愿意，可以将自定义的事件对象传递给第二个参数。
默认的是（局部的）<a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button" target="_blank">鼠标左键事件对象</a>，
它被许多事件处理器接受，包括<code>RouterLink</code>指令。</p>
<div class="callout is-critical"><header>click() is not an Angular testing utility</header><header>click()不是Angular测试工具</header><p>The <code>click()</code> helper function is <strong>not</strong> one of the Angular testing utilities.
It&#39;s a function defined in <em>this guide&#39;s sample code</em>.
All of the sample tests use it.
If you like it, add it to your own collection of helpers.</p>
<p><code>click()</code>辅助函数<strong>不是</strong>Angular测试工具之一。
它是在<strong>本章的例子代码</strong>中定义的函数方法，被所有测试例子所用。
如果你喜欢它，将它添加到你自己的辅助函数集。</p>
</div><p>Here&#39;s the previous test, rewritten using this click helper.</p>
<p>下面是使用了click辅助函数重新编写的上一个测试程序：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard-hero.component.spec.ts (click test revised)</h4></header><code-example language="ts" format="">it(&#39;should raise selected event when clicked&#39;, () =&gt; {
  let selectedHero: Hero;
  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);

  click(heroEl);   // triggerEventHandler helper
  expect(selectedHero).toBe(expectedHero);
});
</code-example></div><div class="l-hr"></div><a id="component-inside-test-host"></a><h2 id="test-a-component-inside-a-test-host-component">Test a component inside a test host component</h2>
<h2 id="-">在测试宿主组件中测试组件</h2>
<h1 id="-">在测试宿主组件中测试组件</h1>
<p>In the previous approach, the tests themselves played the role of the host <code>DashboardComponent</code>.
But does the <code>DashboardHeroComponent</code> work correctly when properly data-bound to a host component?</p>
<p>在前面的方法中，测试本身扮演了宿主组件<code>DashbaordComponent</code>的角色。
一种挥之不去的疑虑仍然存在：当正常数据绑定到宿主组件时，<code>DashboardHeroComponent</code>还会正常工作吗？</p>
<p>Testing with the actual <code>DashboardComponent</code> host is doable but seems more trouble than its worth.
It&#39;s easier to emulate the <code>DashboardComponent</code> host with a <em>test host</em> like this one:</p>
<p>使用实际的<code>DashbaordComponent</code>宿主来测试是可行的，但是这么做似乎不合算。
像下面这样使用<strong>测试宿主组件</strong>来模拟<code>DashbaordComponent</code>显得更加容易：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard-hero.component.spec.ts (test host)</h4></header><code-example language="ts" format="">@Component({
  template: `
    &lt;dashboard-hero  [hero]=&quot;hero&quot;  (selected)=&quot;onSelected($event)&quot;&gt;&lt;/dashboard-hero&gt;`
})
class TestHostComponent {
  hero = new Hero(42, &#39;Test Name&#39;);
  selectedHero: Hero;
  onSelected(hero: Hero) { this.selectedHero = hero; }
}
</code-example></div><p>The test host binds to <code>DashboardHeroComponent</code> as the <code>DashboardComponent</code> would but without
the distraction of the <code>Router</code>, the <code>HeroService</code>, or even the <code>*ngFor</code> repeater.</p>
<p>测试宿主组件和<code>DashboardComponent</code>一样绑定<code>DashboardHeroComponent</code>，但是不用理会<code>Router</code>、<code>HeroService</code>服务，甚至<code>*ngFor</code>循环。</p>
<p>The test host sets the component&#39;s <code>hero</code> input property with its test hero.
It binds the component&#39;s <code>selected</code> event with its <code>onSelected</code> handler,
which records the emitted hero
in its <code>selectedHero</code> property. Later, the tests check that property to verify that the
<code>DashboardHeroComponent.selected</code> event emitted the right hero.</p>
<p>测试宿主将组件的<code>hero</code>导入属性设置为它的模拟英雄。
它将组件的<code>selected</code>事件绑定到它的<code>onSelected</code>处理器，使用<code>selectedHero</code>属性来记录发送来的英雄。
然后测试检查这个属性来验证<code>DashboardHeroComponent.selected</code>事件确实发送了正确的英雄。</p>
<p>The setup for the test-host tests is similar to the setup for the stand-alone tests:</p>
<p>配置使用测试宿主的测试程序与配置孤立测试相似：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard-hero.component.spec.ts (test host setup)</h4></header><code-example language="ts" format="">beforeEach( async(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ DashboardHeroComponent, TestHostComponent ], // declare both
  }).compileComponents();
}));

beforeEach(() =&gt; {
  // create TestHostComponent instead of DashboardHeroComponent
  fixture  = TestBed.createComponent(TestHostComponent);
  testHost = fixture.componentInstance;
  heroEl   = fixture.debugElement.query(By.css(&#39;.hero&#39;)); // find hero
  fixture.detectChanges(); // trigger initial data binding
});
</code-example></div><p>This testing module configuration shows two important differences:</p>
<p>这个测试模块配置展示了两个非常重要的区别：</p>
<ol>
<li><p>It <em>declares</em> both the <code>DashboardHeroComponent</code> and the <code>TestHostComponent</code>.</p>
<p>它同时<strong>声明</strong>了<code>DashboardHeroComponent</code>和<code>TestHostComponent</code>。</p>
</li>
<li><p>It <em>creates</em> the <code>TestHostComponent</code> instead of the <code>DashboardHeroComponent</code>.</p>
<p>它<strong>创建</strong>了<code>TestHostComponent</code>，而非<code>DashboardHeroComponent</code>。</p>
</li>
</ol>
<p>The <code>createComponent</code> returns a <code>fixture</code> that holds an instance of <code>TestHostComponent</code> instead of an instance of <code>DashboardHeroComponent</code>.</p>
<p><code>createComponent</code>返回的<code>fixture</code>里有<code>TestHostComponent</code>实例，而非<code>DashboardHeroComponent</code>组件实例。</p>
<p>Creating the <code>TestHostComponent</code> has the side-effect of creating a <code>DashboardHeroComponent</code>
because the latter appears within the template of the former.
The query for the hero element (<code>heroEl</code>) still finds it in the test DOM,
albeit at greater depth in the element tree than before.</p>
<p>当然，创建<code>TestHostComponent</code>有创建<code>DashboardHeroComponent</code>的副作用，因为后者出现在前者的模板中。
英雄元素（<code>heroEl</code>)的查询语句仍然可以在测试DOM中找到它，尽管元素树比以前更深。</p>
<p>The tests themselves are almost identical to the stand-alone version:</p>
<p>这些测试本身和它们的孤立版本几乎相同：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard-hero.component.spec.ts (test-host)</h4></header><code-example language="ts" format="">it(&#39;should display hero name&#39;, () =&gt; {
  const expectedPipedName = testHost.hero.name.toUpperCase();
  expect(heroEl.nativeElement.textContent).toContain(expectedPipedName);
});

it(&#39;should raise selected event when clicked&#39;, () =&gt; {
  click(heroEl);
  // selected hero should be the same data bound hero
  expect(testHost.selectedHero).toBe(testHost.hero);
});
</code-example></div><p>Only the selected event test differs. It confirms that the selected <code>DashboardHeroComponent</code> hero
really does find its way up through the event binding to the host component.</p>
<p>只有selected事件的测试不一样。它确保被选择的<code>DashboardHeroComponent</code>英雄确实通过事件绑定被传递到宿主组件。</p>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="routed-component"></a><h2 id="test-a-routed-component">Test a routed component</h2>
<h2 id="-">测试带路由器的组件</h2>
<p>Testing the actual <code>DashboardComponent</code> seemed daunting because it injects the <code>Router</code>.</p>
<p>测试实际的<code>DashbaordComponent</code>似乎令人生畏，因为它注入了<code>Router</code>。</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard.component.ts (constructor)</h4></header><code-example language="ts" format="">constructor(
  private router: Router,
  private heroService: HeroService) {
}
</code-example></div><p>It also injects the <code>HeroService</code>, but faking that is a <a href="#component-with-async-service">familiar story</a>.
The <code>Router</code> has a complicated API and is entwined with other services and application preconditions.</p>
<p>它同时还注入了<code>HeroService</code>，但是我们已经知道如何<a href="#component-with-async-servic">伪造</a>它。
<code>Router</code>的API非常复杂，并且它缠绕了其它服务和许多应用的先决条件。</p>
<p>Fortunately, the <code>DashboardComponent</code> isn&#39;t doing much with the <code>Router</code></p>
<p>幸运的是，<code>DashbaordComponent</code>没有使用<code>Router</code>做很多事情。</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard.component.ts (goToDetail)</h4></header><code-example language="ts" format="">gotoDetail(hero: Hero) {
  let url = `/heroes/${hero.id}`;
  this.router.navigateByUrl(url);
}
</code-example></div><p>This is often the case.
As a rule you test the component, not the router,
and care only if the component navigates with the right address under the given conditions.
Stubbing the router with a test implementation is an easy option. This should do the trick:</p>
<p>通常都是这样的。原则上，你测试的是组件，不是路由器，应该只关心在指定的条件下，组件是否导航到正确的地址。
用模拟类来替换路由器是一种简单的方案。下面的代码应该可以：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard.component.spec.ts (Router Stub)</h4></header><code-example language="ts" format="">class RouterStub {
  navigateByUrl(url: string) { return url; }
}
</code-example></div><p>Now set up the testing module with the test stubs for the <code>Router</code> and <code>HeroService</code>, and
create a test instance of the <code>DashboardComponent</code> for subsequent testing.</p>
<p>现在我们来利用<code>Router</code>和<code>HeroService</code>的测试stub类来配置测试模块，并为接下来的测试创建<code>DashboardComponent</code>的测试实例。</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard.component.spec.ts (compile and create)</h4></header><code-example language="ts" format="">beforeEach( async(() =&gt; {
  TestBed.configureTestingModule({
    providers: [
      { provide: HeroService, useClass: FakeHeroService },
      { provide: Router,      useClass: RouterStub }
    ]
  })
  .compileComponents().then(() =&gt; {
    fixture = TestBed.createComponent(DashboardComponent);
    comp = fixture.componentInstance;
  });
</code-example></div><p>The following test clicks the displayed hero and confirms (with the help of a spy) that <code>Router.navigateByUrl</code> is called with the expected url.</p>
<p>下面的测试程序点击显示的英雄，并利用spy来确认<code>Router.navigateByUrl</code>被调用了，而且传进的url是所期待的值。</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard.component.spec.ts (navigate test)</h4></header><code-example language="ts" format="">    it(&#39;should tell ROUTER to navigate when hero clicked&#39;,
      inject([Router], (router: Router) =&gt; { // ...

      const spy = spyOn(router, &#39;navigateByUrl&#39;);

      heroClick(); // trigger click on first inner &lt;div class=&quot;hero&quot;&gt;

      // args passed to router.navigateByUrl()
      const navArgs = spy.calls.first().args[0];

      // expecting to navigate to id of the component&#39;s first hero
      const id = comp.heroes[0].id;
      expect(navArgs).toBe(&#39;/heroes/&#39; + id,
        &#39;should nav to HeroDetail for first hero&#39;);
    }));
</code-example></div><a id="inject"></a><h3 id="the-_inject_-function">The <em>inject</em> function</h3>
<h3 id="_inject_-"><em>inject</em>函数</h3>
<p>Notice the <code>inject</code> function in the second <code>it</code> argument.</p>
<p>注意第二个<code>it</code>参数里面的<code>inject</code>函数。</p>
<div class="code-example"><code-example language="ts" format="">it(&#39;should tell ROUTER to navigate when hero clicked&#39;,
  inject([Router], (router: Router) =&gt; { // ...
}));
</code-example></div><p>The <code>inject</code> function is one of the Angular testing utilities.
It injects services into the test function where you can alter, spy on, and manipulate them.</p>
<p><code>inject</code>函数是Angular测试工具之一。
它注入服务到测试函数，以供修改、监视和操纵。</p>
<p>The <code>inject</code> function has two parameters:</p>
<p><code>inject</code>函数有两个参数：</p>
<ol>
<li><p>An array of Angular dependency injection tokens.</p>
<p>一列数组，包含了Angular依赖注入令牌</p>
</li>
<li><p>A test function whose parameters correspond exactly to each item in the injection token array.</p>
<p>一个测试函数，它的参数与注入令牌数组里的每个项目严格的一一对应。</p>
</li>
</ol>
<div class="callout is-important"><header>inject uses the TestBed Injector</header><header>使用TestBed注入器来注入</header><p>The <code>inject</code> function uses the current <code>TestBed</code> injector and can only return services provided at that level.
It does not return services from component providers.</p>
<p><code>inject</code>函数使用当前<code>TestBed</code>注入器，并且只返回这个级别提供的服务。
它不会返回组件提供商提供的服务。</p>
</div><p>This example injects the <code>Router</code> from the current <code>TestBed</code> injector.
That&#39;s fine for this test because the <code>Router</code> is, and must be, provided by the application root injector.</p>
<p>这个例子通过当前的<code>TestBed</code>注入器来注入<code>Router</code>。
对这个测试程序来说，这是没问题的，因为<code>Router</code>是（也必须是）由应用的根注入器来提供。</p>
<p>If you need a service provided by the component&#39;s <em>own</em> injector,  call <code>fixture.debugElement.injector.get</code> instead:</p>
<p>如果你需要组件自己的注入器提供的服务，调用<code>fixture.debugElement.injector.get</code>：</p>
<div class="code-example"><header><h4>Component's injector</h4></header><code-example language="ts" format="">// UserService actually injected into the component
userService = fixture.debugElement.injector.get(UserService);
</code-example></div><div class="alert is-important"><p>Use the component&#39;s own injector to get the service actually injected into the component.</p>
<p>使用组件自己的注入器来获取实际注入到组件的服务。</p>
</div><p>The <code>inject</code> function closes the current <code>TestBed</code> instance to further configuration.
You cannot call any more <code>TestBed</code> configuration methods, not <code>configureTestingModule</code>
nor any of the <code>override...</code> methods. The <code>TestBed</code> throws an error if you try.</p>
<p><code>inject</code>函数关闭当前<code>TestBed</code>实例，使它无法再被配置。
你不能再调用任何<code>TestBed</code>配置方法、<code>configureTestModule</code>或者任何<code>override...</code>方法，否则<code>TestBed</code>将抛出错误。</p>
<div class="alert is-important"><p>Do not configure the <code>TestBed</code> after calling <code>inject</code>.</p>
<p>不要在调用<code>inject</code>以后再试图配置<code>TestBed</code>。</p>
</div><a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><a id="routed-component-w-param"></a><h3 id="test-a-routed-component-with-parameters">Test a routed component with parameters</h3>
<h3 id="-">测试带有路由和路由参数的组件</h3>
<p>Clicking a <em>Dashboard</em> hero triggers navigation to <code>heroes/:id</code>, where <code>:id</code>
is a route parameter whose value is the <code>id</code> of the hero to edit. 
That URL matches a route to the <code>HeroDetailComponent</code>.</p>
<p>点击<strong>Dashboard</strong>英雄触发导航到<code>heros/:id</code>，其中<code>:id</code>是路由参数，它的值是进行编辑的英雄的<code>id</code>。
这个URL匹配到<code>HeroDetailComponent</code>的路由。</p>
<p>The router pushes the <code>:id</code> token value into the <code>ActivatedRoute.params</code> <em>Observable</em> property,
Angular injects the <code>ActivatedRoute</code> into the <code>HeroDetailComponent</code>,
and the component extracts the <code>id</code> so it can fetch the corresponding hero via the <code>HeroDetailService</code>.
Here&#39;s the <code>HeroDetailComponent</code> constructor:</p>
<p>路由器将<code>:id</code>令牌的值推送到<code>ActivatedRoute.params</code><strong>可观察</strong>属性里，
Angular注入<code>ActivatedRoute</code>到<code>HeroDetailComponent</code>中，
然后组件提取<code>id</code>，这样它就可以通过<code>HeroDetailService</code>获取相应的英雄。
下面是<code>HeroDetailComponent</code>的构造函数：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.ts (constructor)</h4></header><code-example language="ts" format="">constructor(
  private heroDetailService: HeroDetailService,
  private route:  ActivatedRoute,
  private router: Router) {
}
</code-example></div><p><code>HeroDetailComponent</code>  subscribes to <code>ActivatedRoute.params</code> changes in its <code>ngOnInit</code> method.</p>
<p><code>HeroDetailComponent</code>在它的<code>ngOnInit</code>方法中监听<code>ActivatedRoute.params</code>的变化。</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.ts (ngOnInit)</h4></header><code-example language="ts" format="">ngOnInit(): void {
  // get hero when `id` param changes
  this.route.params.subscribe(p =&gt; this.getHero(p &amp;&amp; p[&#39;id&#39;]));
}
</code-example></div><div class="l-sub-section"><p>The expression after <code>route.params</code> chains an <em>Observable</em> operator that <em>plucks</em> the <code>id</code> from the <code>params</code>
and then chains a <code>forEach</code> operator to subscribe to <code>id</code>-changing events.
The <code>id</code> changes every time the user navigates to a different hero.</p>
<p><code>route.params</code>之后的表达式链接了<strong>可观察</strong>操作符，它从<code>params</code>中提取<code>id</code>，然后链接<code>forEach</code>操作符来订阅<code>id</code>变化事件。
每次<code>id</code>变化时，用户被导航到不同的英雄。</p>
<p>The <code>forEach</code> passes the new <code>id</code> value to the component&#39;s <code>getHero</code> method (not shown)
which fetches a hero and sets the component&#39;s <code>hero</code> property.
If the<code>id</code> parameter is missing, the <code>pluck</code> operator fails and the <code>catch</code> treats failure as a request to edit a new hero.</p>
<p><code>forEach</code>将新的<code>id</code>值传递到组件的<code>getHero</code>方法（这里没有列出来），它获取英雄并将它赋值到组件的<code>hero</code>属性。
如果<code>id</code>参数无效，<code>pluck</code>操作符就会失败，<code>catch</code>将失败当作创建新英雄来处理。</p>
<p>The <a href="router.html#route-parameters">Router</a> guide covers <code>ActivatedRoute.params</code> in more detail.</p>
<p><a href="router.html#route-parameters">路由器</a>章更详尽的讲述了<code>ActivatedRoute.params</code>。</p>
</div><p>A test can explore how the <code>HeroDetailComponent</code> responds to different <code>id</code> parameter values
by manipulating the <code>ActivatedRoute</code> injected into the component&#39;s constructor.</p>
<p>通过操纵被注入到组件构造函数的<code>ActivatedRoute</code>服务，测试程序可以探索<code>HeroDetailComponent</code>是如何对不同的<code>id</code>参数值作出响应的。</p>
<p>By now you know how to stub the <code>Router</code> and a data service.
Stubbing the <code>ActivatedRoute</code> follows the same pattern except for a complication:
the <code>ActivatedRoute.params</code> is an <em>Observable</em>.</p>
<p>现在，你已经知道如何模拟<code>Router</code>和数据服务。
模拟<code>ActivatedRoute</code>遵循类似的模式，但是有个额外枝节：<code>ActivatedRoute.params</code>是<strong>可观察对象</strong>。</p>
<a id="stub-observable"></a><h3 id="create-an-_observable_-test-double">Create an <em>Observable</em> test double</h3>
<h3 id="-"><strong>可观察对象</strong>的测试替身</h3>
<p>The <code>hero-detail.component.spec.ts</code> relies on an <code>ActivatedRouteStub</code> to set <code>ActivatedRoute.params</code> values for each test.
This is a cross-application, re-usable <em>test helper class</em>.
Consider placing such helpers in a <code>testing</code> folder sibling to the <code>app</code> folder.
This sample keeps <code>ActivatedRouteStub</code> in <code>testing/router-stubs.ts</code>:</p>
<p><code>hero-detail.component.spec.ts</code>依赖<code>ActivatedRouteStub</code>来为每个测试程序设置<code>ActivatedRoute.params</code>值。
它是跨应用、可复用的<strong>测试辅助类</strong>。
我们建议将这样的辅助类放到<code>app</code>目录下的名为<code>testing</code>的目录。
本例把<code>ActivatedRouteStub</code>放到<code>testing/router-stubs.ts</code>：</p>
<div class="code-example"><header><h4>testing/router-stubs.ts (ActivatedRouteStub)</h4></header><code-example language="ts" format="">import { BehaviorSubject } from &#39;rxjs/BehaviorSubject&#39;;

@Injectable()
export class ActivatedRouteStub {

  // ActivatedRoute.params is Observable
  private subject = new BehaviorSubject(this.testParams);
  params = this.subject.asObservable();

  // Test parameters
  private _testParams: {};
  get testParams() { return this._testParams; }
  set testParams(params: {}) {
    this._testParams = params;
    this.subject.next(params);
  }

  // ActivatedRoute.snapshot.params
  get snapshot() {
    return { params: this.testParams };
  }
}
</code-example></div><p>Notable features of this stub are:</p>
<p>这个stub类有下列值得注意的特征：</p>
<ul>
<li><p>The stub implements only two of the <code>ActivatedRoute</code> capabilities: <code>params</code> and <code>snapshot.params</code>.</p>
<p>这个stub类只实现<code>ActivatedRoute</code>的两个功能：<code>params</code>和<code>snapshot.params</code>。</p>
</li>
<li><p><a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md" target="_blank"><em>BehaviorSubject</em></a>
drives the stub&#39;s <code>params</code> <em>Observable</em> and returns the same value to every <code>params</code> subscriber until it&#39;s given a new value.</p>
<p><a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md" target="_blank"><em>BehaviorSubject</em></a>驱使这个stub类的<code>params</code>可观察对象，并为每个<code>params</code>的订阅者返回同样的值，直到它接受到新值。</p>
</li>
<li><p>The <code>HeroDetailComponent</code> chains its expressions to this stub <code>params</code> <em>Observable</em> which is now under the tester&#39;s control.</p>
<p><code>HeroDetailComponent</code>链接它的表达式到这个stub类的<code>params</code>可观察对象，该对象现在被测试者的控制之下。</p>
</li>
<li><p>Setting the <code>testParams</code> property causes the <code>subject</code> to push the assigned value into <code>params</code>.
That triggers the <code>HeroDetailComponent</code> <em>params</em> subscription, described above, in the same way that navigation does.</p>
<p>设置<code>testParams</code>属性导致<code>subject</code>将指定的值推送进<code>params</code>。它触发上面描述过的<code>HeroDetailComponent</code>的<code>params</code>订阅，和导航的方式一样。</p>
</li>
<li><p>Setting the <code>testParams</code> property also updates the stub&#39;s internal value for the <code>snapshot</code> property to return.</p>
<p>设置<code>testParams</code>属性同时更新这个stub类内部值，用于<code>snapshot</code>属性的返回。</p>
</li>
</ul>
<div style="margin-left:30px" class="l-sub-section"><p>The <a href="router.html#snapshot" title="Router guide: snapshot"><em>snapshot</em></a> is another popular way for components to consume route parameters.</p>
<p><a href="router.html#snapshot" title="Router Chapter: snapshot"><em>snapshot</em></a>是组件使用路由参数的另一种流行的方法。</p>
</div><div class="callout is-helpful"><p>The router stubs in this guide are meant to inspire you. Create your own stubs to fit your testing needs.</p>
<p>本章的路由器stub类是为了给你灵感。创建你自己的stub类，以适合你的测试需求。</p>
</div><a id="tests-w-observable-double"></a><h3 id="testing-with-the-_observable_-test-double">Testing with the <em>Observable</em> test double</h3>
<h3 id="-">测试<strong>可观察对象</strong>的替身</h3>
<p>Here&#39;s a test demonstrating the component&#39;s behavior when the observed <code>id</code> refers to an existing hero:</p>
<p>下面的测试程序是演示组件在被观察的<code>id</code>指向现有英雄时的行为：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (existing id)</h4></header><code-example language="ts" format="">  describe(&#39;when navigate to existing hero&#39;, () =&gt; {
    let expectedHero: Hero;

    beforeEach( async(() =&gt; {
      expectedHero = firstHero;
      activatedRoute.testParams = { id: expectedHero.id };
      createComponent();
    }));

    it(&#39;should display that hero\&#39;s name&#39;, () =&gt; {
      expect(page.nameDisplay.textContent).toBe(expectedHero.name);
    });
  });
</code-example></div><div class="l-sub-section"><p>The <code>createComponent</code> method and <code>page</code> object are discussed <a href="#page-object">in the next section</a>.
Rely on your intuition for now.</p>
<p><a href="#page-object">下一节</a>将解释<code>createComponent</code>方法和<code>page</code>对象，现在暂时跟着自己的直觉走。</p>
</div><p>When the <code>id</code> cannot be found, the component should re-route to the <code>HeroListComponent</code>.
The test suite setup provided the same <code>RouterStub</code> <a href="#routed-component">described above</a> which spies on the router without actually navigating.
This test supplies a &quot;bad&quot; id and expects the component to try to navigate.</p>
<p>当无法找到<code>id</code>时，组件应该重新导航到<code>HeroListComponent</code>。
该测试套件配置与<a href="#routed-component">上面描述</a>的<code>RouterStub</code>一样，它在不实际导航的情况下刺探路由器。
该测试程序提供了“坏”的id，期望组件尝试导航。</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (bad id)</h4></header><code-example language="ts" format="">describe(&#39;when navigate to non-existant hero id&#39;, () =&gt; {
  beforeEach( async(() =&gt; {
    activatedRoute.testParams = { id: 99999 };
    createComponent();
  }));

  it(&#39;should try to navigate back to hero list&#39;, () =&gt; {
    expect(page.gotoSpy.calls.any()).toBe(true, &#39;comp.gotoList called&#39;);
    expect(page.navSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);
  });
});
</code-example></div><p>While this app doesn&#39;t have a route to the <code>HeroDetailComponent</code> that omits the <code>id</code> parameter, it might add such a route someday.
The component should do something reasonable when there is no <code>id</code>.</p>
<p>虽然本应用没有在缺少<code>id</code>参数的时候，继续导航到<code>HeroDetailComponent</code>的路由，但是，将来它可能会添加这样的路由。
当没有<code>id</code>时，该组件应该作出合理的反应。</p>
<p>In this implementation, the component should create and display a new hero.
New heroes have <code>id=0</code> and a blank <code>name</code>. This test confirms that the component behaves as expected:</p>
<p>在本例中，组件应该创建和显示新英雄。
新英雄的<code>id</code>为零，<code>name</code>为空。本测试程序确认组件是按照预期的这样做的：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (no id)</h4></header><code-example language="ts" format="">describe(&#39;when navigate with no hero id&#39;, () =&gt; {
  beforeEach( async( createComponent ));

  it(&#39;should have hero.id === 0&#39;, () =&gt; {
    expect(comp.hero.id).toBe(0);
  });

  it(&#39;should display empty hero name&#39;, () =&gt; {
    expect(page.nameDisplay.textContent).toBe(&#39;&#39;);
  });
});
</code-example></div><div class="callout is-helpful"><p>Inspect and download <em>all</em> of the guide&#39;s application test code with this <live-example plnkr="app-specs" embedded-style>live example</live-example>.</p>
<p>到<live-example plnkr="app-specs">在线例子</live-example>查看和下载<strong>所有</strong>本章应用程序测试代码。</p>
</div><a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="page-object"></a><h2 id="use-a-_page_-object-to-simplify-setup">Use a <em>page</em> object to simplify setup</h2>
<h2 id="-page-">使用<strong>page</strong>对象来简化配置</h2>
<p>The <code>HeroDetailComponent</code> is a simple view with a title, two hero fields, and two buttons.</p>
<p><code>HeroDetailComponent</code>是带有标题、两个英雄字段和两个按钮的简单视图。</p>
<figure class="image-display"><img src="/resources/images/devguide/testing/hero-detail.component.png" alt="HeroDetailComponent in action"></figure><p>But there&#39;s already plenty of template complexity.</p>
<p>但是它已经有很多模板复杂性。</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.html</h4></header><code-example language="html" format="">&lt;div *ngIf=&quot;hero&quot;&gt;
  &lt;h2&gt;&lt;span&gt;{{hero.name | titlecase}}&lt;/span&gt; Details&lt;/h2&gt;
  &lt;div&gt;
    &lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;name&quot;&gt;name: &lt;/label&gt;
    &lt;input id=&quot;name&quot; [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot; /&gt;
  &lt;/div&gt;
  &lt;button (click)=&quot;save()&quot;&gt;Save&lt;/button&gt;
  &lt;button (click)=&quot;cancel()&quot;&gt;Cancel&lt;/button&gt;
&lt;/div&gt;
</code-example></div><p>To fully exercise the component, the test needs a lot of setup:</p>
<p>要彻底测试该组件，测试程序需要一系列设置：</p>
<ul>
<li><p>It must wait until a hero arrives before <code>*ngIf</code> allows any element in DOM.</p>
<p>它必须在<code>*ngIf</code>允许元素进入DOM之前，等待<code>hero</code>的到来</p>
</li>
<li><p>It needs references to the title <code>&lt;span&gt;</code> and the name <code>&lt;input&gt;</code> so it can inspect their values.</p>
<p>它需要标题名字span和名字输入框元素的引用，用来检查它们的值</p>
</li>
<li><p>It needs references to the two buttons so it can click them.</p>
<p>它需要两个按钮的引用，以便点击它们</p>
</li>
<li><p>It needs spies for some of the component and router methods.</p>
<p>刺探（spy）组件和路由器的方法</p>
</li>
</ul>
<p>Even a small form such as this one can produce a mess of tortured conditional setup and CSS element selection.</p>
<p>即使是像这样一个很小的表单，也能产生令人疯狂的错综复杂的条件设置和CSS元素选择。</p>
<p>Tame the madness with a <code>Page</code> class that simplifies access to component properties and encapsulates the logic that sets them.
Here&#39;s the <code>Page</code> class for the <code>hero-detail.component.spec.ts</code></p>
<p>通过简化组件属性的访问和封装设置属性的逻辑，<code>Page</code>类可以轻松解决这个令人抓狂的难题。
下面是为<code>hero-detail.component.spec.ts</code>准备的<code>page</code>类：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (Page)</h4></header><code-example language="ts" format="">class Page {
  gotoSpy:      jasmine.Spy;
  navSpy:       jasmine.Spy;

  saveBtn:      DebugElement;
  cancelBtn:    DebugElement;
  nameDisplay:  HTMLElement;
  nameInput:    HTMLInputElement;

  constructor() {
    const router = TestBed.get(Router); // get router from root injector
    this.gotoSpy = spyOn(comp, &#39;gotoList&#39;).and.callThrough();
    this.navSpy  = spyOn(router, &#39;navigate&#39;);
  }

  /** Add page elements after hero arrives */
  addPageElements() {
    if (comp.hero) {
      // have a hero so these elements are now in the DOM
      const buttons    = fixture.debugElement.queryAll(By.css(&#39;button&#39;));
      this.saveBtn     = buttons[0];
      this.cancelBtn   = buttons[1];
      this.nameDisplay = fixture.debugElement.query(By.css(&#39;span&#39;)).nativeElement;
      this.nameInput   = fixture.debugElement.query(By.css(&#39;input&#39;)).nativeElement;
    }
  }
}
</code-example></div><p>Now the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of <code>Page</code>.</p>
<p>现在，用来操作和检查组件的重要钩子都被井然有序的组织起来了，可以通过<code>page</code>实例来使用它们。  </p>
<p>A <code>createComponent</code> method creates a <code>page</code> objectand fills in the blanks once the <code>hero</code> arrives.</p>
<p><code>createComponent</code>方法创建<code>page</code>，在<code>hero</code>到来时，自动填补空白。</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (createComponent)</h4></header><code-example language="ts" format="">/** Create the HeroDetailComponent, initialize it, set test variables  */
function createComponent() {
  fixture = TestBed.createComponent(HeroDetailComponent);
  comp    = fixture.componentInstance;
  page    = new Page();

  // 1st change detection triggers ngOnInit which gets a hero
  fixture.detectChanges();
  return fixture.whenStable().then(() =&gt; {
    // 2nd change detection displays the async-fetched hero
    fixture.detectChanges();
    page.addPageElements();
  });
}
</code-example></div><p>The <a href="#tests-w-observable-double">observable tests</a> in the previous section demonstrate how <code>createComponent</code> and <code>page</code>
keep the tests short and <em>on message</em>.
There are no distractions: no waiting for promises to resolve and no searching the DOM for element values to compare.</p>
<p>上一节的<a href="#tests-w-observable-double">可观察对象测试</a>展示了<code>createComponent</code>和<code>page</code>如何让测试程序简短和即时。
没有任何干扰：无需等待承诺的解析，也没有搜索DOM元素值进行比较。</p>
<p>Here are a few more <code>HeroDetailComponent</code> tests to drive the point home.</p>
<p>这里是一些更多的<code>HeroDetailComponent</code>测试程序，进一步的展示了这一点。</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (selected tests)</h4></header><code-example language="ts" format="">    it(&#39;should display that hero\&#39;s name&#39;, () =&gt; {
      expect(page.nameDisplay.textContent).toBe(expectedHero.name);
    });

    it(&#39;should navigate when click cancel&#39;, () =&gt; {
      click(page.cancelBtn);
      expect(page.navSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);
    });

    it(&#39;should save when click save but not navigate immediately&#39;, () =&gt; {
      // Get service injected into component and spy on its`saveHero` method.
      // It delegates to fake `HeroService.updateHero` which delivers a safe test result.
      const hds = fixture.debugElement.injector.get(HeroDetailService);
      const saveSpy = spyOn(hds, &#39;saveHero&#39;).and.callThrough();

      click(page.saveBtn);
      expect(saveSpy.calls.any()).toBe(true, &#39;HeroDetailService.save called&#39;);
      expect(page.navSpy.calls.any()).toBe(false, &#39;router.navigate not called&#39;);
    });

    it(&#39;should navigate when click save and save resolves&#39;, fakeAsync(() =&gt; {
      click(page.saveBtn);
      tick(); // wait for async save to complete
      expect(page.navSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);
    }));

    it(&#39;should convert hero name to Title Case&#39;, () =&gt; {
      const inputName = &#39;quick BROWN  fox&#39;;
      const titleCaseName = &#39;Quick Brown  Fox&#39;;

      // simulate user entering new name into the input box
      page.nameInput.value = inputName;

      // dispatch a DOM event so that Angular learns of input value change.
      page.nameInput.dispatchEvent(newEvent(&#39;input&#39;));

      // Tell Angular to update the output span through the title pipe
      fixture.detectChanges();

      expect(page.nameDisplay.textContent).toBe(titleCaseName);
    });
</code-example></div><a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="import-module"></a><h2 id="setup-with-module-imports">Setup with module imports</h2>
<h2 id="-imports-">模块导入imports的配置</h2>
<p>Earlier component tests configured the testing module with a few <code>declarations</code> like this:</p>
<p>此前的组件测试程序使用了一些<code>declarations</code>来配置模块，就像这样：</p>
<div class="code-example"><header><h4>src/app/dashboard/dashboard-hero.component.spec.ts (config)</h4></header><code-example language="ts" format="">// async beforeEach
beforeEach( async(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ DashboardHeroComponent ],
  })
  .compileComponents(); // compile template and css
}));
</code-example></div><p>The <code>DashboardComponent</code> is simple. It needs no help.
But more complex components often depend on other components, directives, pipes, and providers
and these must be added to the testing module too.</p>
<p><code>DashbaordComponent</code>非常简单。它不需要帮助。
但是更加复杂的组件通常依赖其它组件、指令、管道和提供商，
所以这些必须也被添加到测试模块中。</p>
<p>Fortunately, the <code>TestBed.configureTestingModule</code> parameter parallels
the metadata passed to the <code>@NgModule</code> decorator
which means you can also specify <code>providers</code> and <code>imports</code>.</p>
<p>幸运的是，<code>TestBed.configureTestingModule</code>参数与传入<code>@NgModule</code>装饰器的元数据一样，也就是所你也可以指定<code>providers</code>和<code>imports</code>.</p>
<p>The <code>HeroDetailComponent</code> requires a lot of help despite its small size and simple construction.
In addition to the support it receives from the default testing module <code>CommonModule</code>, it needs:</p>
<p>虽然<code>HeroDetailComponent</code>很小，结构也很简单，但是它需要很多帮助。
  除了从默认测试模块<code>CommonModule</code>中获得的支持，它还需要：</p>
<ul>
<li><p><code>NgModel</code> and friends in the <code>FormsModule</code> to enable two-way data binding.</p>
<p><code>FormsModule</code>里的<code>NgModel</code>和其它，来进行双向数据绑定</p>
</li>
<li><p>The <code>TitleCasePipe</code> from the <code>shared</code> folder.</p>
<p><code>shared</code>目录里的<code>TitleCasePipe</code></p>
</li>
<li><p>Router services (which these tests are stubbing).</p>
<p>一些路由器服务（测试程序将stub伪造它们）</p>
</li>
<li><p>Hero data access services (also stubbed).</p>
<p>英雄数据访问服务（同样被stub伪造了）</p>
</li>
</ul>
<p>One approach is to configure the testing module from the individual pieces as in this example:</p>
<p>一种方法是在测试模块中一一配置，就像这样：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (FormsModule setup)</h4></header><code-example language="ts" format="">beforeEach( async(() =&gt; {
   TestBed.configureTestingModule({
    imports:      [ FormsModule ],
    declarations: [ HeroDetailComponent, TitleCasePipe ],
    providers: [
      { provide: ActivatedRoute, useValue: activatedRoute },
      { provide: HeroService,    useClass: FakeHeroService },
      { provide: Router,         useClass: RouterStub},
    ]
  })
  .compileComponents();
}));
</code-example></div><p>Because many app components need the <code>FormsModule</code> and the <code>TitleCasePipe</code>, the developer created
a <code>SharedModule</code> to combine these and other frequently requested parts.
The test configuration can use the <code>SharedModule</code> too as seen in this alternative setup:</p>
<p>因为许多应用组件需要<code>FormsModule</code>和<code>TitleCasePipe</code>，所以开发者创建了<code>SharedModule</code>来合并它们和一些频繁需要的部件。
测试配置也可以使用<code>SharedModule</code>，请看下面另一种配置：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (SharedModule setup)</h4></header><code-example language="ts" format="">beforeEach( async(() =&gt; {
  TestBed.configureTestingModule({
    imports:      [ SharedModule ],
    declarations: [ HeroDetailComponent ],
    providers: [
      { provide: ActivatedRoute, useValue: activatedRoute },
      { provide: HeroService,    useClass: FakeHeroService },
      { provide: Router,         useClass: RouterStub},
    ]
  })
  .compileComponents();
}));
</code-example></div><p>It&#39;s a bit tighter and smaller, with fewer import statements (not shown).</p>
<p>它的导入声明少一些（未显示），稍微干净一些，小一些。</p>
<a id="feature-module-import"></a><h3 id="import-the-feature-module">Import the feature module</h3>
<h3 id="-">导入特性模块</h3>
<p>The <code>HeroDetailComponent</code> is part of the <code>HeroModule</code> <a href="ngmodule.html#feature-modules">Feature Module</a> that aggregates more of the interdependent pieces
including the <code>SharedModule</code>.
Try a test configuration that imports the <code>HeroModule</code> like this one:</p>
<p><code>HeroDetailComponent</code>是<code>HeroModule</code><a href="ngmodule.html#feature-modules">特性模块</a>的一部分，它组合了更多互相依赖的部件，包括<code>SharedModule</code>。
试试下面这个导入<code>HeroModule</code>的测试配置：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (HeroModule setup)</h4></header><code-example language="ts" format="">beforeEach( async(() =&gt; {
   TestBed.configureTestingModule({
    imports:   [ HeroModule ],
    providers: [
      { provide: ActivatedRoute, useValue: activatedRoute },
      { provide: HeroService,    useClass: FakeHeroService },
      { provide: Router,         useClass: RouterStub},
    ]
  })
  .compileComponents();
}));
</code-example></div><p>That&#39;s <em>really</em> crisp. Only the <em>test doubles</em> in the <code>providers</code> remain. Even the <code>HeroDetailComponent</code> declaration is gone.</p>
<p>这样特别清爽。只有<code>providers</code>里面的测试替身被保留。连<code>HeroDetailComponent</code>声明都消失了。</p>
<div class="l-sub-section"><p>In fact, if you try to declare it, Angular throws an error because
<code>HeroDetailComponent</code> is declared in both the <code>HeroModule</code> and the <code>DynamicTestModule</code> (the testing module).</p>
<p>事实上，如果里试图声明它，Angular会抛出错误，因为<code>HeroDetailComponent</code>已经在<code>HeroModule</code>和测试模块的<code>DynamicTestModule</code>中声明。</p>
</div><div class="alert is-helpful"><p>Importing the component&#39;s feature module is often the easiest way to configure the tests,
especially when the feature module is small and mostly self-contained, as feature modules should be.</p>
<p>导入组件的特性模块通常是最简单的配置测试的方法，
尤其是当特性模块很小而且几乎自包含时...特性模块应该是自包含的。</p>
</div><a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="component-override"></a><h2 id="override-a-component-s-providers">Override a component&#39;s providers</h2>
<h2 id="-">重载组件的提供商</h2>
<p>The <code>HeroDetailComponent</code> provides its own <code>HeroDetailService</code>.</p>
<p><code>HeroDetailComponent</code>提供自己的<code>HeroDetailService</code>服务。</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.ts (prototype)</h4></header><code-example language="ts" format="">@Component({
  selector:    &#39;app-hero-detail&#39;,
  templateUrl: &#39;./hero-detail.component.html&#39;,
  styleUrls:  [&#39;./hero-detail.component.css&#39; ],
  providers:  [ HeroDetailService ]
})
export class HeroDetailComponent implements OnInit {
  constructor(
    private heroDetailService: HeroDetailService,
    private route:  ActivatedRoute,
    private router: Router) {
  }
}
</code-example></div><p>It&#39;s not possible to stub the component&#39;s <code>HeroDetailService</code> in the <code>providers</code> of the <code>TestBed.configureTestingModule</code>.
Those are providers for the <em>testing module</em>, not the component. They prepare the dependency injector at the <em>fixture level</em>.</p>
<p>在<code>TestBed.configureTestingModule</code>的<code>providers</code>中stub伪造组件的<code>HeroDetailService</code>是不可行的。
这些是<strong>测试模块</strong>的提供商，而非组件的。组件级别的供应商应该在<strong>fixture级别</strong>准备的依赖注入器。</p>
<p>Angular creates the component with its <em>own</em> injector, which is a <em>child</em> of the fixture injector.
It registers the component&#39;s providers (the <code>HeroDetailService</code> in this case) with the child injector.
A test cannot get to child injector services from the fixture injector.
And <code>TestBed.configureTestingModule</code> can&#39;t configure them either.</p>
<p>Angular创建组件时，该组件有自己的注入器，它是fixture注入器的子级。
Angular使用这个子级注入器来注册组件的提供商（也就是<code>HeroDetailService</code>）。
测试程序无法从fixture的注入器获取这个子级注入器。
而且<code>TestBed.configureTestingModule</code>也无法配置它们。</p>
<p>Angular has been creating new instances of the real <code>HeroDetailService</code> all along!</p>
<p>Angular始终都在创建真实<code>HeroDetailService</code>的实例。</p>
<div class="l-sub-section"><p>These tests could fail or timeout if the <code>HeroDetailService</code> made its own XHR calls to a remote server.
There might not be a remote server to call.</p>
<p>如果<code>HeroDetailService</code>向远程服务器发出自己的XHR请求，这些测试可能会失败或者超时。
这个远程服务器可能根本不存在。</p>
<p>Fortunately, the <code>HeroDetailService</code> delegates responsibility for remote data access to an injected <code>HeroService</code>.</p>
<p>幸运的是，<code>HeroDetailService</code>将远程数据访问的责任交给了注入进来的<code>HeroService</code>。</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.service.ts (prototype)</h4></header><code-example language="ts" format="">@Injectable()
export class HeroDetailService {
  constructor(private heroService: HeroService) {  }
  /* . . . */
}
</code-example></div><p>The <a href="#feature-module-import">previous test configuration</a> replaces the real <code>HeroService</code> with a <code>FakeHeroService</code>
that intercepts server requests and fakes their responses.</p>
<p><a href="#feature-module-import">之前的测试配置</a>将真实的<code>HeroService</code>替换为<code>FakeHeroService</code>，拦截了服务起请求，伪造了它们的响应。</p>
</div><p>What if you aren&#39;t so lucky. What if faking the <code>HeroService</code> is hard? 
What if <code>HeroDetailService</code> makes its own server requests? </p>
<p>如果我们没有这么幸运怎么办？如果伪造<code>HeroService</code>很难怎么办？如果<code>HeroDetailService</code>自己发出服务器请求怎么办？</p>
<p>The <code>TestBed.overrideComponent</code> method can replace the component&#39;s <code>providers</code> with easy-to-manage <em>test doubles</em>
as seen in the following setup variation:</p>
<p><code>TestBed.overrideComponent</code>方法可以将组件的<code>providers</code>替换为容易管理的<strong>测试替身</strong>，参见下面的设置变化：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (Override setup)</h4></header><code-example language="ts" format="">  beforeEach( async(() =&gt; {
    TestBed.configureTestingModule({
      imports:   [ HeroModule ],
      providers: [
        { provide: ActivatedRoute, useValue: activatedRoute },
        { provide: Router,         useClass: RouterStub},
      ]
    })

    // Override component&#39;s own provider
    .overrideComponent(HeroDetailComponent, {
      set: {
        providers: [
          { provide: HeroDetailService, useClass: HeroDetailServiceSpy }
        ]
      }
    })

    .compileComponents();
  }));
</code-example></div><p>Notice that <code>TestBed.configureTestingModule</code> no longer provides a (fake) <code>HeroService</code> because it&#39;s <a href="#spy-stub">not needed</a>.</p>
<p>注意，<code>TestBed.configureTestingModule</code>不再提供（伪造）<code>HeroService</code>，因为已经<a href="#stub-hero-detail-service">没有必要了</a>。</p>
<a id="override-component-method"></a><h3 id="the-_overridecomponent_-method">The <em>overrideComponent</em> method</h3>
<h3 id="-overridecomponent-"><strong>overrideComponent</strong>方法</h3>
<p>Focus on the <code>overrideComponent</code> method.</p>
<p>注意这个<code>overrideComponent</code>方法。</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (overrideComponent)</h4></header><code-example language="ts" format="">.overrideComponent(HeroDetailComponent, {
  set: {
    providers: [
      { provide: HeroDetailService, useClass: HeroDetailServiceSpy }
    ]
  }
})
</code-example></div><p>It takes two arguments: the component type to override (<code>HeroDetailComponent</code>) and an override metadata object.
The <a href="#metadata-override-object">overide metadata object</a> is a generic defined as follows:</p>
<p>它接受两个参数：要重载的组件类型(<code>HeroDetailComponent</code>)和用于重载的元数据对象。
<a href="#metadata-override-object">重载元数据对象</a>是泛型类，就像这样：</p>
<code-example format="." language="javascript">type MetadataOverride<t> = {
  add?: T;
  remove?: T;
  set?: T;
};</t></code-example><p>A metadata override object can either add-and-remove elements in metadata properties or completely reset those properties.
This example resets the component&#39;s <code>providers</code> metadata.</p>
<p>元数据重载对象可以添加和删除元数据属性的项目，也可以彻底重设这些属性。
这个例子重新设置了组件的<code>providers</code>元数据。</p>
<p>The type parameter, <code>T</code>,  is the kind of metadata you&#39;d pass to the <code>@Component</code> decorator:</p>
<p>这个类型参数，<code>T</code>，是你会传递给<code>@Component</code>装饰器的元数据的类型。</p>
<code-example format="." language="javascript">selector?: string;
template?: string;
templateUrl?: string;
providers?: any[];
...
</code-example><a id="spy-stub"></a><h3 id="provide-a-_spy-stub_-_herodetailservicespy_-">Provide a <em>spy stub</em> (<em>HeroDetailServiceSpy</em>)</h3>
<h3 id="-spy-stub-herodetailservicespy-">提供一个<em>刺探桩（Spy stub）</em>（<code>HeroDetailServiceSpy</code>）</h3>
<p>This example completely replaces the component&#39;s <code>providers</code> array with a new array containing a <code>HeroDetailServiceSpy</code>.</p>
<p>这个例子把组件的<code>providers</code>数组完全替换成了一个包含<code>HeroDetailServiceSpy</code>的新数组。</p>
<p>The <code>HeroDetailServiceSpy</code> is a stubbed version of the real <code>HeroDetailService</code>
that fakes all necessary features of that service.
It neither injects nor delegates to the lower level <code>HeroService</code>
so there&#39;s no need to provide a test double for that.</p>
<p><code>HeroDetailServiceSpy</code>是实际<code>HeroDetailService</code>服务的桩版本，它伪造了该服务的所有必要特性。
但它既不需要注入也不会委托给低层的<code>HeroService</code>服务，因此我们不用为<code>HeroService</code>提供测试替身。</p>
<p>The related <code>HeroDetailComponent</code> tests will assert that methods of the <code>HeroDetailService</code>
were called by spying on the service methods.
Accordingly, the stub implements its methods as spies:</p>
<p>通过对该服务的方法进行刺探，<code>HeroDetailComponent</code>的关联测试将会对<code>HeroDetailService</code>是否被调用过进行断言。
因此，这个桩类会把它的方法实现为刺探方法：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)</h4></header><code-example language="ts" format="">class HeroDetailServiceSpy {
  testHero = new Hero(42, &#39;Test Hero&#39;);

  getHero = jasmine.createSpy(&#39;getHero&#39;).and.callFake(
    () =&gt; Promise
      .resolve(true)
      .then(() =&gt; Object.assign({}, this.testHero))
  );

  saveHero = jasmine.createSpy(&#39;saveHero&#39;).and.callFake(
    (hero: Hero) =&gt; Promise
      .resolve(true)
      .then(() =&gt; Object.assign(this.testHero, hero))
  );
}
</code-example></div><a id="override-tests"></a><h3 id="the-override-tests">The override tests</h3>
<h3 id="-">重载的测试程序</h3>
<p>Now the tests can control the component&#39;s hero directly by manipulating the spy-stub&#39;s <code>testHero</code>
and confirm that service methods were called.</p>
<p>现在，测试程序可以通过操控stub的<code>testHero</code>，直接控制组件的英雄，并确保服务的方法被调用过。</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (override tests)</h4></header><code-example language="ts" format="">let hdsSpy: HeroDetailServiceSpy;

beforeEach( async(() =&gt; {
  createComponent();
  // get the component&#39;s injected HeroDetailServiceSpy
  hdsSpy = fixture.debugElement.injector.get(HeroDetailService) as any;
}));

it(&#39;should have called `getHero`&#39;, () =&gt; {
  expect(hdsSpy.getHero.calls.count()).toBe(1, &#39;getHero called once&#39;);
});

it(&#39;should display stub hero\&#39;s name&#39;, () =&gt; {
  expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);
});

it(&#39;should save stub hero change&#39;, fakeAsync(() =&gt; {
  const origName = hdsSpy.testHero.name;
  const newName = &#39;New Name&#39;;

  page.nameInput.value = newName;
  page.nameInput.dispatchEvent(newEvent(&#39;input&#39;)); // tell Angular

  expect(comp.hero.name).toBe(newName, &#39;component hero has new name&#39;);
  expect(hdsSpy.testHero.name).toBe(origName, &#39;service hero unchanged before save&#39;);

  click(page.saveBtn);
  expect(hdsSpy.saveHero.calls.count()).toBe(1, &#39;saveHero called once&#39;);

  tick(); // wait for async save to complete
  expect(hdsSpy.testHero.name).toBe(newName, &#39;service hero has new name after save&#39;);
  expect(page.navSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);
}));
</code-example></div><a id="more-overrides"></a><h3 id="more-overrides">More overrides</h3>
<h3 id="-">更多重载</h3>
<p>The <code>TestBed.overrideComponent</code> method can be called multiple times for the same or different components.
The <code>TestBed</code> offers similar <code>overrideDirective</code>, <code>overrideModule</code>, and <code>overridePipe</code> methods
for digging into and replacing parts of these other classes.</p>
<p><code>TestBed.overrideComponent</code>方法可以在相同或不同的组件中被反复调用。
<code>TestBed</code>还提供了类似的<code>overrideDirective</code>、<code>overrideModule</code>和<code>overridePipe</code>方法，用来深入并重载这些其它类的部件。</p>
<p>Explore the options and combinations on your own.</p>
<p>自己探索这些选项和组合。</p>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="router-outlet-component"></a><h2 id="test-a-_routeroutlet_-component">Test a <em>RouterOutlet</em> component</h2>
<h2 id="-_routeroutlet_-">测试带有<em>RouterOutlet</em>的组件</h2>
<p>The <code>AppComponent</code> displays routed components in a <code>&lt;router-outlet&gt;</code>.
It also displays a navigation bar with anchors and their <code>RouterLink</code> directives.</p>
<p><code>AppComponent</code>在<code>&lt;router-outlet&gt;</code>中显示导航组件。
 它还显示了导航条，包含了链接和它们的<code>RouterLink</code>指令。</p>
<a id="app-component-html"></a><div class="code-example"><header><h4>src/app/app.component.html</h4></header><code-example language="html" format="">&lt;app-banner&gt;&lt;/app-banner&gt;
&lt;app-welcome&gt;&lt;/app-welcome&gt;

&lt;nav&gt;
  &lt;a routerLink=&quot;/dashboard&quot;&gt;Dashboard&lt;/a&gt;
  &lt;a routerLink=&quot;/heroes&quot;&gt;Heroes&lt;/a&gt;
  &lt;a routerLink=&quot;/about&quot;&gt;About&lt;/a&gt;
&lt;/nav&gt;

&lt;router-outlet&gt;&lt;/router-outlet&gt;
</code-example></div><p>The component class does nothing.</p>
<p>组件的类没有做任何事。</p>
<div class="code-example"><header><h4>src/app/app.component.ts</h4></header><code-example language="ts" format="">import { Component } from &#39;@angular/core&#39;;
@Component({
  selector: &#39;my-app&#39;,
  templateUrl: &#39;./app.component.html&#39;
})
export class AppComponent { }
</code-example></div><p>Unit tests can confirm that the anchors are wired properly without engaging the router.
See why this is worth doing <a href="#why-stubbed-routerlink-tests">below</a>.</p>
<p>在不涉及路由的情况下，单元测试可以确认链接的设置是否正确。
参见<a href="#why-stubbed-routerlink-tests">下面的内容</a>，了解为什么值得这么做。</p>
<a id="stub-component"></a><h3 id="stubbing-unneeded-components">Stubbing unneeded components</h3>
<h3 id="stub-">stub伪造不需要的组件</h3>
<p>The test setup should look familiar.</p>
<p>该测试配置应该看起来很眼熟：</p>
<div class="code-example"><header><h4>src/app/app.component.spec.ts (Stub Setup)</h4></header><code-example language="ts" format="">beforeEach( async(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [
      AppComponent,
      BannerComponent, WelcomeStubComponent,
      RouterLinkStubDirective, RouterOutletStubComponent
    ]
  })

  .compileComponents()
  .then(() =&gt; {
    fixture = TestBed.createComponent(AppComponent);
    comp    = fixture.componentInstance;
  });
}));
</code-example></div><p>The <code>AppComponent</code> is the declared test subject.</p>
<p><code>AppComponent</code>是被声明的测试对象。</p>
<p>The setup extends the default testing module with one real component (<code>BannerComponent</code>) and several stubs.</p>
<p>使用一个真实的组件（<code>BannerComponent</code>）和几个stub，该配置扩展了默认测试模块。</p>
<ul>
<li><p><code>BannerComponent</code> is simple and harmless to use as is.</p>
<p>原样使用<code>BannerComponent</code>非常简单而且无害。</p>
</li>
<li><p>The real <code>WelcomeComponent</code> has an injected service. <code>WelcomeStubComponent</code> is a placeholder with no service to worry about.</p>
<p>真实的<code>WelcomeComponent</code>有被注入的服务。<code>WelcomeStubComponent</code>是无服务的替代品。</p>
</li>
<li><p>The real <code>RouterOutlet</code> is complex and errors easily.
The <code>RouterOutletStubComponent</code> (in <code>testing/router-stubs.ts</code>) is safely inert.</p>
<p>真实的<code>RouterOutlet</code>很复杂而且容易出错。
<code>testing/router-stubs.ts</code>里的<code>RouterOutletStubComponent</code>是安全的替代品。</p>
</li>
</ul>
<p>The component stubs are essential. 
Without them, the Angular compiler doesn&#39;t recognize the <code>&lt;app-welcome&gt;</code> and <code>&lt;router-outlet&gt;</code> tags 
and throws an error. </p>
<p>组件stub替代品很关键。
没有它们，Angular编译器无法识别<code>&lt;app-welcome</code>和<code>&lt;router-outlet&gt;</code>标签，抛出错误。</p>
<a id="router-link-stub"></a><h3 id="stubbing-the-_routerlink_">Stubbing the <em>RouterLink</em></h3>
<h3 id="stub-_routerlink_">Stub伪造<em>RouterLink</em></h3>
<p>The <code>RouterLinkStubDirective</code> contributes substantively to the test:</p>
<p><code>RouterLinkStubDirective</code>为测试作出了重要的贡献：</p>
<div class="code-example"><header><h4>testing/router-stubs.ts (RouterLinkStubDirective)</h4></header><code-example language="ts" format="">@Directive({
  selector: &#39;[routerLink]&#39;,
  host: {
    &#39;(click)&#39;: &#39;onClick()&#39;
  }
})
export class RouterLinkStubDirective {
  @Input(&#39;routerLink&#39;) linkParams: any;
  navigatedTo: any = null;

  onClick() {
    this.navigatedTo = this.linkParams;
  }
}
</code-example></div><p>The <code>host</code> metadata property wires the click event of the host element (the <code>&lt;a&gt;</code>) to the directive&#39;s <code>onClick</code> method.
The URL bound to the <code>[routerLink]</code> attribute flows to the directive&#39;s <code>linkParams</code> property.
Clicking the anchor should trigger the <code>onClick</code> method which sets the telltale <code>navigatedTo</code> property.
Tests can inspect that property to confirm the expected <em>click-to-navigation</em> behavior.</p>
<p><code>host</code>元数据属性将宿主元素(<code>&lt;a&gt;</code>)的click事件与指令的<code>onClick</code>方法关联起来。
绑定到<code>[routerLink]</code>的URL属性被传递到指令的<code>linkParams</code>属性。
点击这个链接应该能触发<code>onClick</code>方法，从而设置<code>navigatedTo</code>属性。
测试程序可以查看这个属性，来确认期望的<strong>点击导航</strong>行为。</p>
<a id="by-directive"></a><a id="inject-directive"></a><h3 id="_by-directive_-and-injected-directives"><em>By.directive</em> and injected directives</h3>
<h3 id="_by-directive_-"><em>By.directive</em>和注入的指令</h3>
<p>A little more setup triggers the initial data binding and gets references to the navigation links:</p>
<p>再一步配置触发了数据绑定的初始化，获取导航链接的引用：</p>
<div class="code-example"><header><h4>src/app/app.component.spec.ts (test setup)</h4></header><code-example language="ts" format="">beforeEach(() =&gt; {
  // trigger initial data binding
  fixture.detectChanges();

  // find DebugElements with an attached RouterLinkStubDirective
  linkDes = fixture.debugElement
    .queryAll(By.directive(RouterLinkStubDirective));

  // get the attached link directive instances using the DebugElement injectors
  links = linkDes
    .map(de =&gt; de.injector.get(RouterLinkStubDirective) as RouterLinkStubDirective);
});
</code-example></div><p>Two points of special interest:</p>
<p>特别值得注意的两点：</p>
<ol>
<li><p>You can locate elements <em>by directive</em>, using <code>By.directive</code>, not just by css selectors.</p>
<p>你还可以按指令定位元素，使用<code>By.directive</code>，而不仅仅是通过CSS选择器。</p>
</li>
<li><p>You can use the component&#39;s dependency injector to get an attached directive because
Angular always adds attached directives to the component&#39;s injector.</p>
<p>你可以使用组件的依赖注入器来获取附加的指令，因为Angular总是将附加组件添加到组件的注入器中。</p>
</li>
</ol>
<a id="app-component-tests"></a><p>Here are some tests that leverage this setup:</p>
<p>下面是一些使用这个配置的测试程序：</p>
<div class="code-example"><header><h4>src/app/app.component.spec.ts (selected tests)</h4></header><code-example language="ts" format="">it(&#39;can get RouterLinks from template&#39;, () =&gt; {
  expect(links.length).toBe(3, &#39;should have 3 links&#39;);
  expect(links[0].linkParams).toBe(&#39;/dashboard&#39;, &#39;1st link should go to Dashboard&#39;);
  expect(links[1].linkParams).toBe(&#39;/heroes&#39;, &#39;1st link should go to Heroes&#39;);
});

it(&#39;can click Heroes link in template&#39;, () =&gt; {
  const heroesLinkDe = linkDes[1];
  const heroesLink = links[1];

  expect(heroesLink.navigatedTo).toBeNull(&#39;link should not have navigated yet&#39;);

  heroesLinkDe.triggerEventHandler(&#39;click&#39;, null);
  fixture.detectChanges();

  expect(heroesLink.navigatedTo).toBe(&#39;/heroes&#39;);
});
</code-example></div><div class="l-sub-section"><p>The &quot;click&quot; test <em>in this example</em> is worthless.
It works hard to appear useful when in fact it
tests the <code>RouterLinkStubDirective</code> rather than the <em>component</em>.
This is a common failing of directive stubs.</p>
<p>本例中的“click”测试程序其实毫无价值。
它显得很有用，但是事实上，它测试的是<code>RouterLinkStubDirective</code>，而非测试组件。
这是指令stub的通病。</p>
<p>It has a legitimate purpose in this guide. 
It demonstrates how to find a <code>RouterLink</code> element, click it, and inspect a result,
without engaging the full router machinery.
This is a skill you may need to test a more sophisticated component, one that changes the display,
re-calculates parameters, or re-arranges navigation options when the user clicks the link.</p>
<p>在本章中，它有存在的必要。
它演示了如何在不涉及完整路由器机制的情况下，如何找到<code>RouterLink</code>元素、点击它并检查结果。
要测试更复杂的组件，你可能需要具备这样的能力，能改变视图和重新计算参数，或者当用户点击链接时，有能力重新安排导航选项。</p>
</div><a id="why-stubbed-routerlink-tests"></a><h3 id="what-good-are-these-tests-">What good are these tests?</h3>
<h3 id="-">这些测试有什么好处？</h3>
<p>Stubbed <code>RouterLink</code> tests can confirm that a component with links and an outlet is setup properly,
that the component has the links it should have, and that they are all pointing in the expected direction.
These tests do not concern whether the app will succeed in navigating to the target component when the user clicks a link.</p>
<p>stub伪造的<code>RouterLink</code>测试可以确认带有链接和outlet的组件的设置的正确性，确认组件有应该有的链接，确认它们都指向了正确的方向。
这些测试程序不关心用户点击链接时，应用是否会成功的导航到目标组件。</p>
<p>Stubbing the RouterLink and RouterOutlet is the best option for such limited testing goals.
Relying on the real router would make them brittle.
They could fail for reasons unrelated to the component.
For example, a navigation guard could prevent an unauthorized user from visiting the <code>HeroListComponent</code>.
That&#39;s not the fault of the <code>AppComponent</code> and no change to that component could cure the failed test.</p>
<p>对于这样局限的测试目标，stub伪造RouterLink和RouterOutlet是最佳选择。
依靠真正的路由器会让它们很脆弱。
它们可能因为与组件无关的原因而失败。
例如，一个导航守卫可能防止没有授权的用户访问<code>HeroListComponent</code>。
这并不是<code>AppComponent</code>的过错，并且无论该组件怎么改变都无法修复这个失败的测试程序。</p>
<p>A <em>different</em> battery of tests can explore whether the application navigates as expected
in the presence of conditions that influence guards such as whether the user is authenticated and authorized.</p>
<p>不同的测试程序可以探索在不同条件下（比如像检查用户是否认证），该应用是否和期望的那样导航。</p>
<div class="alert is-helpful"><p>A future guide update will explain how to write such tests with the <code>RouterTestingModule</code>.</p>
<p>未来本章的更新将介绍如何使用<code>RouterTestingModule</code>来编写这样的测试程序。</p>
</div><a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="shallow-component-test"></a><h2 id="-shallow-component-tests-with-no-_errors-_schema-">&quot;Shallow component tests&quot; with <em>NO_ERRORS_SCHEMA</em></h2>
<h2 id="-no-_errors-_schema-">使用<em>NO_ERRORS_SCHEMA</em>来“浅化”组件测试程序</h2>
<p>The <a href="#stub-component">previous setup</a> declared the <code>BannerComponent</code> and stubbed two other components
for <em>no reason other than to avoid a compiler error</em>.</p>
<p><a href="#stub-component">以前的配置</a>声明了<code>BannerComponent</code>，并stub伪造了两个其它组件，<strong>仅仅是为了避免编译错误，不是为别的原因</strong>。</p>
<p>Without them, the Angular compiler doesn&#39;t recognize the <code>&lt;app-banner&gt;</code>, <code>&lt;app-welcome&gt;</code> and <code>&lt;router-outlet&gt;</code> tags 
in the <a href="#app-component-html"><em>app.component.html</em></a> template and throws an error. </p>
<p>没有它们，Angular编译器无法识别<a href="#app-component-html"><em>app.component.html</em></a>模板里的<code>&lt;app-banner&gt;</code>、<code>&lt;app-welcome&gt;</code>和<code>&lt;router-outlet&gt;</code>标签，并抛出错误。</p>
<p>Add <code>NO_ERRORS_SCHEMA</code> to the testing module&#39;s <code>schemas</code> metadata
to tell the compiler to ignore unrecognized elements and attributes.
You no longer have to declare irrelevant components and directives.</p>
<p>添加<code>NO_ERRORS_SCHEMA</code>到测试模块的<code>schemas</code>元数据中，告诉编译器忽略不认识的元素和属性。
这样你不再需要声明无关组件和指令。</p>
<p>These tests are <strong><em>shallow</em></strong> because they only &quot;go deep&quot; into the components you want to test.
Here is a setup, with <code>import</code> statements, that demonstrates the improved simplicity of <em>shallow</em> tests, relative to the stubbing setup.</p>
<p>这些测试程序比较<strong>浅</strong>，因为它们只“深入”到你要测试的组件。
这里是一套配置（拥有<code>import</code>语句），体现了相比使用stub伪造的配置来说，<strong>浅</strong>测试程序的简单性。</p>
<code-tabs><code-pane language="ts" name="src/app/app.component.spec.ts (NO_ERRORS_SCHEMA)" format=".">import { NO_ERRORS_SCHEMA }          from &#39;@angular/core&#39;;
import { AppComponent }              from &#39;./app.component&#39;;
import { RouterOutletStubComponent } from &#39;../testing&#39;;

beforeEach( async(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ AppComponent, RouterLinkStubDirective ],
    schemas:      [ NO_ERRORS_SCHEMA ]
  })

  .compileComponents()
  .then(() =&gt; {
    fixture = TestBed.createComponent(AppComponent);
    comp    = fixture.componentInstance;
  });
}));
</code-pane><code-pane language="ts" name="src/app/app.component.spec.ts (Stubs)" format=".">  import { Component }                 from &#39;@angular/core&#39;;
  import { AppComponent }              from &#39;./app.component&#39;;
  import { BannerComponent }           from &#39;./banner.component&#39;;
  import { RouterLinkStubDirective }   from &#39;../testing&#39;;
  import { RouterOutletStubComponent } from &#39;../testing&#39;;

  @Component({selector: &#39;app-welcome&#39;, template: &#39;&#39;})
  class WelcomeStubComponent {}

  beforeEach( async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent,
        BannerComponent, WelcomeStubComponent,
        RouterLinkStubDirective, RouterOutletStubComponent
      ]
    })

    .compileComponents()
    .then(() =&gt; {
      fixture = TestBed.createComponent(AppComponent);
      comp    = fixture.componentInstance;
    });
  }));
</code-pane></code-tabs><p>The <em>only</em> declarations are the <em>component-under-test</em> (<code>AppComponent</code>) and the <code>RouterLinkStubDirective</code>
that contributes actively to the tests.
The <a href="#app-component-tests">tests in this example</a> are unchanged.</p>
<p>这里<strong>唯一</strong>声明的是<strong>被测试的组件</strong>(<code>AppComponent</code>)和测试需要的<code>RouterLinkStubDirective</code>。
没有改变任何<a href="#app-component-tests">原测试程序</a>。</p>
<div class="alert is-important"><p><em>Shallow component tests</em> with <code>NO_ERRORS_SCHEMA</code> greatly simplify unit testing of complex templates.
However, the compiler no longer alerts you to mistakes
such as misspelled or misused components and directives.</p>
<p>使用<code>NO_ERRORS_SCHEMA</code>的<strong>浅组件测试程序</strong>很大程度上简化了拥有复杂模板组件的单元测试。
但是，编译器将不再提醒你一些错误，比如模板中拼写错误或者误用的组件和指令。</p>
</div><a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="attribute-directive"></a><h2 id="test-an-attribute-directive">Test an attribute directive</h2>
<h2 id="-">测试属性指令</h2>
<p>An <em>attribute directive</em> modifies the behavior of an element, component or another directive.
Its name reflects the way the directive is applied: as an attribute on a host element.</p>
<p><strong>属性指令</strong>修改元素、组件和其它指令的行为。正如它们的名字所示，它们是作为宿主元素的属性来被使用的。</p>
<p>The sample application&#39;s <code>HighlightDirective</code> sets the background color of an element
based on either a data bound color or a default color (lightgray).
It also sets a custom property of the element (<code>customProperty</code>) to <code>true</code>
for no reason other than to show that it can.</p>
<p>本例子应用的<code>HighlightDirective</code>使用数据绑定的颜色或者默认颜色来设置元素的背景色。
它同时设置元素的<code>customProperty</code>属性为<code>true</code>，这里仅仅是为了显示它能这么做而已，并无其它原因。</p>
<div class="code-example"><header><h4>src/app/shared/highlight.directive.ts</h4></header><code-example language="ts" format="">import { Directive, ElementRef, Input, OnChanges } from &#39;@angular/core&#39;;

@Directive({ selector: &#39;[highlight]&#39; })
/** Set backgroundColor for the attached element to highlight color
 *  and set the element&#39;s customProperty to true */
export class HighlightDirective implements OnChanges {

  defaultColor =  &#39;rgb(211, 211, 211)&#39;; // lightgray

  @Input(&#39;highlight&#39;) bgColor: string;

  constructor(private el: ElementRef) {
    el.nativeElement.style.customProperty = true;
  }

  ngOnChanges() {
    this.el.nativeElement.style.backgroundColor = this.bgColor || this.defaultColor;
  }
}
</code-example></div><p>It&#39;s used throughout the application, perhaps most simply in the <code>AboutComponent</code>:</p>
<p>它的使用贯穿整个应用，也许最简单的使用在<code>AboutComponent</code>里：</p>
<div class="code-example"><header><h4>src/app/about.component.ts</h4></header><code-example language="ts" format="">import { Component } from &#39;@angular/core&#39;;
@Component({
  template: `
  &lt;h2 highlight=&quot;skyblue&quot;&gt;About&lt;/h2&gt;
  &lt;twain-quote&gt;&lt;/twain-quote&gt;
  &lt;p&gt;All about this sample&lt;/p&gt;`
})
export class AboutComponent { }
</code-example></div><p>Testing the specific use of the <code>HighlightDirective</code> within the <code>AboutComponent</code> requires only the
techniques explored above (in particular the <a href="#shallow-component-test">&quot;Shallow test&quot;</a> approach).</p>
<p>使用<code>AboutComponent</code>来测试这个<code>HightlightDirective</code>的使用，只需要上面解释过的知识就够了，（尤其是<a href="#shallow-component-test">&quot;浅测试程序&quot;</a>方法)。</p>
<div class="code-example"><header><h4>src/app/about.component.spec.ts</h4></header><code-example language="ts" format="">beforeEach(() =&gt; {
  fixture = TestBed.configureTestingModule({
    declarations: [ AboutComponent, HighlightDirective],
    schemas:      [ NO_ERRORS_SCHEMA ]
  })
  .createComponent(AboutComponent);
  fixture.detectChanges(); // initial binding
});

it(&#39;should have skyblue &lt;h2&gt;&#39;, () =&gt; {
  const de = fixture.debugElement.query(By.css(&#39;h2&#39;));
  const bgColor = de.nativeElement.style.backgroundColor;
  expect(bgColor).toBe(&#39;skyblue&#39;);
});
</code-example></div><p>However, testing a single use case is unlikely to explore the full range of a directive&#39;s capabilities.
Finding and testing all components that use the directive is tedious, brittle, and almost as unlikely to afford full coverage.</p>
<p>但是，测试单一的用例一般无法探索该指令的全部能力。
查找和测试所有使用该指令的组件非常繁琐和脆弱，并且通常无法覆盖所有组件。</p>
<p><a href="#isolated-unit-tests">Isolated unit tests</a> might be helpful, 
but attribute directives like this one tend to manipulate the DOM. 
Isolated unit tests don&#39;t touch the DOMand, therefore ,
do not inspire confidence in the directive&#39;s efficacy.</p>
<p><a href="#isolated-unit-tests">孤立单元测试</a>可能有用。
但是像这样的属性指令一般都操纵DOM。孤立单元测试不能控制DOM，所以不推荐用它测试指令的功能。</p>
<p>A better solution is to create an artificial test component that demonstrates all ways to apply the directive.</p>
<p>更好的方法是创建一个展示所有使用该组件的方法的人工测试组件。</p>
<div class="code-example"><header><h4>src/app/shared/highlight.directive.spec.ts (TestComponent)</h4></header><code-example language="ts" format="">@Component({
  template: `
  &lt;h2 highlight=&quot;yellow&quot;&gt;Something Yellow&lt;/h2&gt;
  &lt;h2 highlight&gt;The Default (Gray)&lt;/h2&gt;
  &lt;h2&gt;No Highlight&lt;/h2&gt;
  &lt;input #box [highlight]=&quot;box.value&quot; value=&quot;cyan&quot;/&gt;`
})
class TestComponent { }
</code-example></div><figure class="image-display"><img src="/resources/images/devguide/testing/highlight-directive-spec.png" width="200px" alt="HighlightDirective spec in action"></figure><div class="l-sub-section"><p>The <code>&lt;input&gt;</code> case binds the <code>HighlightDirective</code> to the name of a color value in the input box.
The initial value is the word &quot;cyan&quot; which should be the background color of the input box.</p>
<p><code>&lt;input&gt;</code>用例将<code>HighlightDirective</code>绑定到输入框里输入的颜色名字。
初始只是单词“cyan”，所以输入框的背景色应该是cyan。</p>
</div><p>Here are some tests of this component:</p>
<p>下面是一些该组件的测试程序：</p>
<div class="code-example"><header><h4>src/app/shared/highlight.directive.spec.ts (selected tests)</h4></header><code-example language="ts" format="linenums">beforeEach(() =&gt; {
  fixture = TestBed.configureTestingModule({
    declarations: [ HighlightDirective, TestComponent ]
  })
  .createComponent(TestComponent);

  fixture.detectChanges(); // initial binding

  // all elements with an attached HighlightDirective
  des = fixture.debugElement.queryAll(By.directive(HighlightDirective));

  // the h2 without the HighlightDirective
  bareH2 = fixture.debugElement.query(By.css(&#39;h2:not([highlight])&#39;));
});

// color tests
it(&#39;should have three highlighted elements&#39;, () =&gt; {
  expect(des.length).toBe(3);
});

it(&#39;should color 1st &lt;h2&gt; background &quot;yellow&quot;&#39;, () =&gt; {
  const bgColor = des[0].nativeElement.style.backgroundColor;
  expect(bgColor).toBe(&#39;yellow&#39;);
});

it(&#39;should color 2nd &lt;h2&gt; background w/ default color&#39;, () =&gt; {
  const dir = des[1].injector.get(HighlightDirective) as HighlightDirective;
  const bgColor = des[1].nativeElement.style.backgroundColor;
  expect(bgColor).toBe(dir.defaultColor);
});

it(&#39;should bind &lt;input&gt; background to value color&#39;, () =&gt; {
  // easier to work with nativeElement
  const input = des[2].nativeElement as HTMLInputElement;
  expect(input.style.backgroundColor).toBe(&#39;cyan&#39;, &#39;initial backgroundColor&#39;);

  // dispatch a DOM event so that Angular responds to the input value change.
  input.value = &#39;green&#39;;
  input.dispatchEvent(newEvent(&#39;input&#39;));
  fixture.detectChanges();

  expect(input.style.backgroundColor).toBe(&#39;green&#39;, &#39;changed backgroundColor&#39;);
});


it(&#39;bare &lt;h2&gt; should not have a customProperty&#39;, () =&gt; {
  expect(bareH2.properties[&#39;customProperty&#39;]).toBeUndefined();
});
</code-example></div><p>A few techniques are noteworthy:</p>
<p>一些技巧值得注意：</p>
<ul>
<li><p>The <code>By.directive</code> predicate is a great way to get the elements that have this directive <em>when their element types are unknown</em>.</p>
<p>当<strong>已知元素类型</strong>时，<code>By.directive</code>是一种获取拥有这个指令的元素的好方法。</p>
</li>
<li><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:not" target="_blank"><code>:not</code> pseudo-class</a>
in <code>By.css(&#39;h2:not([highlight])&#39;)</code> helps find <code>&lt;h2&gt;</code> elements that <em>do not</em> have the directive.
<code>By.css(&#39;*:not([highlight])&#39;)</code> finds <em>any</em> element that does not have the directive.</p>
<p><code>By.css(&#39;h2:not([highlight])&#39;)</code>里的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:not" target="_blank"><code>:not</code>伪类（pseudo-class）</a>帮助查找<strong>不带</strong>该指令的<code>&lt;h2&gt;</code>元素。<code>By.css(&#39;*:not([highlight])&#39;)</code>查找<strong>所有</strong>不带该指令的元素。</p>
</li>
<li><p><code>DebugElement.styles</code> affords access to element styles even in the absence of a real browser, thanks to the <code>DebugElement</code> abstraction.
But feel free to exploit the <code>nativeElement</code> when that seems easier or more clear than the abstraction.</p>
<p><code>DebugElement.styles</code>让我们不借助真实的浏览器也可以访问元素的样式，感谢<code>DebugElement</code>提供的这层抽象！
但是如果直接使用<code>nativeElement</code>会比这层抽象更简单、更清晰，也可以放心大胆的使用它。</p>
</li>
<li><p>Angular adds a directive to the injector of the element to which it is applied.
The test for the default color uses the injector of the second <code>&lt;h2&gt;</code> to get its <code>HighlightDirective</code> instance
and its <code>defaultColor</code>.</p>
<p>Angular将指令添加到它的元素的注入器中。默认颜色的测试程序使用第二个<code>&lt;h2&gt;</code>的注入器来获取它的<code>HighlightDirective</code>实例以及它的<code>defaultColor</code>。</p>
</li>
<li><p><code>DebugElement.properties</code> affords access to the artificial custom property that is set by the directive.</p>
<p><code>DebugElement.properties</code>让我们可以访问由指令设置的自定义属性。</p>
</li>
</ul>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="isolated-unit-tests"></a><h2 id="isolated-unit-tests">Isolated Unit Tests</h2>
<h2 id="-">孤立的单元测试</h2>
<p>Testing applications with the help of the Angular testing utilities is the main focus of this guide.</p>
<p>使用Angular测试工具测试应用程序是本章的重点。</p>
<p>However, it&#39;s often more productive to explore the inner logic of application classes
with <em>isolated</em>  unit tests that don&#39;t depend upon Angular.
Such tests are often smaller and  easier to read, write, and maintain.</p>
<p>但是，使用<strong>孤立</strong>单元测试来探索应用类的内在逻辑往往更加有效率，它不依赖Angular。
  这种测试程序通常比较小、更易阅读、编写和维护。</p>
<p>They don&#39;t carry extra baggage:</p>
<p>它们不用背负额外的包袱：</p>
<ul>
<li><p>Import from the Angular test libraries.</p>
<p>从Angular测试库导入</p>
</li>
<li><p>Configure a module.</p>
<p>配置模块</p>
</li>
<li><p>Prepare dependency injection <code>providers</code>.</p>
<p>准备依赖注入<code>providers</code></p>
</li>
<li><p>Call <code>inject</code> or <code>async</code> or <code>fakeAsync</code>.</p>
<p>调用<code>inject</code>，或者<code>async</code>，或者<code>fakeAsync</code></p>
</li>
</ul>
<p>They follow patterns familiar to test developers everywhere:</p>
<p>它们会遵循测试时众所周知的模式：</p>
<ul>
<li><p>Exhibit standard, Angular-agnostic testing techniques.</p>
<p>使用标准的、与Angular无关的测试技巧</p>
</li>
<li><p>Create instances directly with <code>new</code>.</p>
<p>直接使用<code>new</code>创建实例</p>
</li>
<li><p>Substitute test doubles (stubs, spys, and mocks) for the real dependencies.</p>
<p>用测试替身（stub，spy和mock）替代真正的依赖</p>
</li>
</ul>
<div class="callout is-important"><header>Write both kinds of tests</header><header>同时采用这两种测试程序</header><p>Good developers write both kinds of tests for the same application part, often in the same spec file.
Write simple <em>isolated</em> unit tests to validate the part in isolation.
Write <em>Angular</em> tests to validate the part as it interacts with Angular,
updates the DOM, and collaborates with the rest of the application.</p>
<p>优秀的开发者同时编写这两种测试程序来测试相同的应用部件，往往在同一个spec文件。
编写简单的<strong>孤立</strong>单元测试程序来验证孤立的部分。
编写<strong>Angular</strong>测试程序来验证与Angular互动、更新DOM、以及与应用其它部分互动的部分。</p>
</div><a id="isolated-service-tests"></a><h3 id="services">Services</h3>
<h3 id="-">服务</h3>
<p>Services are good candidates for isolated unit testing.
Here are some synchronous and asynchronous unit tests of the <code>FancyService</code>
written without assistance from Angular testing utilities.</p>
<p>服务是应用孤立测试的好例子。
下面是未使用Angular测试工具的一些<code>FancyService</code>的同步和异步单元测试：</p>
<div class="code-example"><header><h4>src/app/bag/bag.no-testbed.spec.ts</h4></header><code-example language="ts" format="linenums">// Straight Jasmine - no imports from Angular test libraries

describe(&#39;FancyService without the TestBed&#39;, () =&gt; {
  let service: FancyService;

  beforeEach(() =&gt; { service = new FancyService(); });

  it(&#39;#getValue should return real value&#39;, () =&gt; {
    expect(service.getValue()).toBe(&#39;real value&#39;);
  });

  it(&#39;#getAsyncValue should return async value&#39;, (done: DoneFn) =&gt; {
    service.getAsyncValue().then(value =&gt; {
      expect(value).toBe(&#39;async value&#39;);
      done();
    });
  });

  it(&#39;#getTimeoutValue should return timeout value&#39;,  (done: DoneFn) =&gt; {
    service = new FancyService();
    service.getTimeoutValue().then(value =&gt; {
      expect(value).toBe(&#39;timeout value&#39;);
      done();
    });
  });

  it(&#39;#getObservableValue should return observable value&#39;, (done: DoneFn) =&gt; {
    service.getObservableValue().subscribe(value =&gt; {
      expect(value).toBe(&#39;observable value&#39;);
      done();
    });
  });

});
</code-example></div><p>A rough line count suggests that these isolated unit tests are about 25% smaller than equivalent Angular tests.
That&#39;s telling but not decisive.
The benefit comes from reduced setup and code complexity.</p>
<p>粗略行数表明，这些孤立单元测试比同等的Angular测试小25%。
这表明了它的好处，但是不是最关键的。
主要的好处来自于缩减的配置和代码的复杂性。</p>
<p>Compare these equivalent tests of <code>FancyService.getTimeoutValue</code>.</p>
<p>比较下面两个同等的<code>FancyService.getTimeoutValue</code>测试程序：</p>
<code-tabs><code-pane language="ts" name="src/app/bag/bag.no-testbed.spec.ts (Isolated)" format="linenums">it(&#39;#getTimeoutValue should return timeout value&#39;,  (done: DoneFn) =&gt; {
  service = new FancyService();
  service.getTimeoutValue().then(value =&gt; {
    expect(value).toBe(&#39;timeout value&#39;);
    done();
  });
});
</code-pane><code-pane language="ts" name="src/app/bag/bag.spec.ts (with Angular testing utilities)" format="linenums">beforeEach(() =&gt; {
  TestBed.configureTestingModule({ providers: [FancyService] });
});

it(&#39;test should wait for FancyService.getTimeoutValue&#39;,
  async(inject([FancyService], (service: FancyService) =&gt; {

  service.getTimeoutValue().then(
    value =&gt; expect(value).toBe(&#39;timeout value&#39;)
  );
})));
</code-pane></code-tabs><p>They have about the same line-count, but the Angular-dependent version
has more moving parts including a couple of utility functions (<code>async</code> and <code>inject</code>).
Both approaches work and it&#39;s not much of an issue if you&#39;re using the
Angular testing utilities nearby for other reasons.
On the other hand, why burden simple service tests with added complexity?</p>
<p>它们有类似的行数。
但是，依赖Angular的版本有更多活动的部分，包括一些工具函数（<code>async</code>和<code>inject</code>)。
两种方法都可行，而且如果你为了某些原因使用Angular测试工具，也并没有什么问题。
反过来，为什么要为简单的服务测试程序添加复杂度呢？</p>
<p>Pick the approach that suits you.</p>
<p>选择你喜欢的方法。</p>
<a id="services-with-dependencies"></a><h3 id="services-with-dependencies">Services with dependencies</h3>
<h3 id="-">带依赖的服务</h3>
<p>Services often depend on other services that Angular injects into the constructor.
You can test these services <em>without</em> the <code>TestBed</code>.
In many cases, it&#39;s easier to create and <em>inject</em> dependencies by hand.</p>
<p>服务通常依赖其它服务，Angular通过构造函数注入它们。
你可以<strong>不使用</strong>TestBed测试这些服务。
在许多情况下，创建和手动<strong>注入</strong>依赖来的更加容易。</p>
<p>The <code>DependentService</code> is a simple example:</p>
<p><code>DependentService</code>是一个简单的例子：</p>
<div class="code-example"><header><h4>src/app/bag/bag.ts</h4></header><code-example language="ts" format="">@Injectable()
export class DependentService {
  constructor(private dependentService: FancyService) { }
  getValue() { return this.dependentService.getValue(); }
}
</code-example></div><p>It delegates its only method, <code>getValue</code>, to the injected <code>FancyService</code>.</p>
<p>它将唯一的方法，<code>getValue</code>，委托给了注入的<code>FancyService</code>。</p>
<p>Here are several ways to test it.</p>
<p>这里是几种测试它的方法。</p>
<div class="code-example"><header><h4>src/app/bag/bag.no-testbed.spec.ts</h4></header><code-example language="ts" format="linenums">describe(&#39;DependentService without the TestBed&#39;, () =&gt; {
  let service: DependentService;

  it(&#39;#getValue should return real value by way of the real FancyService&#39;, () =&gt; {
    service = new DependentService(new FancyService());
    expect(service.getValue()).toBe(&#39;real value&#39;);
  });

  it(&#39;#getValue should return faked value by way of a fakeService&#39;, () =&gt; {
    service = new DependentService(new FakeFancyService());
    expect(service.getValue()).toBe(&#39;faked value&#39;);
  });

  it(&#39;#getValue should return faked value from a fake object&#39;, () =&gt; {
    const fake =  { getValue: () =&gt; &#39;fake value&#39; };
    service = new DependentService(fake as FancyService);
    expect(service.getValue()).toBe(&#39;fake value&#39;);
  });

  it(&#39;#getValue should return stubbed value from a FancyService spy&#39;, () =&gt; {
    const fancy = new FancyService();
    const stubValue = &#39;stub value&#39;;
    const spy = spyOn(fancy, &#39;getValue&#39;).and.returnValue(stubValue);
    service = new DependentService(fancy);

    expect(service.getValue()).toBe(stubValue, &#39;service returned stub value&#39;);
    expect(spy.calls.count()).toBe(1, &#39;stubbed method was called once&#39;);
    expect(spy.calls.mostRecent().returnValue).toBe(stubValue);
  });
});
</code-example></div><p>The first test creates a <code>FancyService</code> with <code>new</code> and passes it to the <code>DependentService</code> constructor.</p>
<p>第一个测试程序使用<code>new</code>创建<code>FancyService</code>实例，并将它传递给<code>DependentService</code>构造函数。</p>
<p>However, it&#39;s rarely that simple. The injected service can be difficult to create or control.
You can mock the dependency,  use a dummy value, or stub the pertinent service method
with a substitute method that &#39;s easy to control.</p>
<p>很少有这么简单的，注入的服务有可能很难创建和控制。
你可以mock依赖，或者使用假值，或者用易于控制的替代品stub伪造相关服务。</p>
<p>These <em>isolated</em> unit testing techniques are great for exploring the inner logic of a service or its
simple integration with a component class.
Use the Angular testing utilities when writing tests that validate how a service interacts with components
<em>within the Angular runtime environment</em>.</p>
<p>这些<strong>孤立</strong>单元测试技巧是一个很好的方法，用来探索服务的内在逻辑，以及它与组件类简单的集成。
当在<strong>运行时间环境下</strong>，使用Angular测试工具来验证一个服务是如何与组件互动的。</p>
<a id="isolated-pipe-tests"></a><h3 id="pipes">Pipes</h3>
<h3 id="-">管道</h3>
<p>Pipes are easy to test without the Angular testing utilities.</p>
<p>管道很容易测试，无需Angular测试工具。</p>
<p>A pipe class has one method, <code>transform</code>, that manipulates the input
value into a transformed output value.
The <code>transform</code> implementation rarely interacts with the DOM.
Most pipes have no dependence on Angular other than the <code>@Pipe</code>
metadata and an interface.</p>
<p>管道类有一个方法，<code>transform</code>，用来转换输入值到输出值。
<code>transform</code>的实现很少与DOM交互。
除了<code>@Pipe</code>元数据和一个接口外，大部分管道不依赖Angular。</p>
<p>Consider a <code>TitleCasePipe</code> that capitalizes the first letter of each word.
Here&#39;s a naive implementation with a regular expression.</p>
<p>假设<code>TitleCasePipe</code>将每个单词的第一个字母变成大写。
下面是使用正则表达式实现的简单代码：</p>
<div class="code-example"><header><h4>src/app/shared/title-case.pipe.ts</h4></header><code-example language="ts" format="">import { Pipe, PipeTransform } from &#39;@angular/core&#39;;

@Pipe({name: &#39;titlecase&#39;, pure: false})
/** Transform to Title Case: uppercase the first letter of the words in a string.*/
export class TitleCasePipe implements PipeTransform {
  transform(input: string): string {
    return input.length === 0 ? &#39;&#39; :
      input.replace(/\w\S*/g, (txt =&gt; txt[0].toUpperCase() + txt.substr(1).toLowerCase() ));
  }
}
</code-example></div><p>Anything that uses a regular expression is worth testing thoroughly.
Use simple Jasmine to explore the expected cases and the edge cases.</p>
<p>任何使用正则表达式的类都值得彻底的进行测试。
使用Jasmine来探索预期的用例和极端的用例。</p>
<div class="code-example"><header><h4>src/app/shared/title-case.pipe.spec.ts</h4></header><code-example language="ts" format="linenums">describe(&#39;TitleCasePipe&#39;, () =&gt; {
  // This pipe is a pure, stateless function so no need for BeforeEach
  let pipe = new TitleCasePipe();

  it(&#39;transforms &quot;abc&quot; to &quot;Abc&quot;&#39;, () =&gt; {
    expect(pipe.transform(&#39;abc&#39;)).toBe(&#39;Abc&#39;);
  });

  it(&#39;transforms &quot;abc def&quot; to &quot;Abc Def&quot;&#39;, () =&gt; {
    expect(pipe.transform(&#39;abc def&#39;)).toBe(&#39;Abc Def&#39;);
  });

  // ... more tests ...
});
</code-example></div><a id="write-tests"></a><h3 id="write-angular-tests-too">Write Angular tests too</h3>
<h3 id="-angular-">同时也编写Angular测试</h3>
<p>These are tests of the pipe <em>in isolation</em>.
They can&#39;t tell if the <code>TitleCasePipe</code> is working properly as applied in the application components.</p>
<p>有些管道的测试程序是<strong>孤立的</strong>。
它们不能验证<code>TitleCasePipe</code>是否在应用到组件上时是否工作正常。</p>
<p>Consider adding component tests such as this one:</p>
<p>考虑像这样添加组件测试程序：</p>
<div class="code-example"><header><h4>src/app/hero/hero-detail.component.spec.ts (pipe test)</h4></header><code-example language="ts" format="linenums">it(&#39;should convert hero name to Title Case&#39;, () =&gt; {
  const inputName = &#39;quick BROWN  fox&#39;;
  const titleCaseName = &#39;Quick Brown  Fox&#39;;

  // simulate user entering new name into the input box
  page.nameInput.value = inputName;

  // dispatch a DOM event so that Angular learns of input value change.
  page.nameInput.dispatchEvent(newEvent(&#39;input&#39;));

  // Tell Angular to update the output span through the title pipe
  fixture.detectChanges();

  expect(page.nameDisplay.textContent).toBe(titleCaseName);
});
</code-example></div><a id="isolated-component-tests"></a><h3 id="components">Components</h3>
<h3 id="-">组件</h3>
<p>Component tests typically examine how a component class interacts with its own template or with collaborating components.
The Angular testing utilities are specifically designed to facilitate such tests.</p>
<p>组件测试通常检查该组件类是如何与自己的模板或者其它合作组件交互的。
Angular测试工具是专门为这种测试设计的。</p>
<p>Consider this <code>ButtonComp</code> component.</p>
<p>考虑这个<code>ButtonComp</code>组件。</p>
<div class="code-example"><header><h4>src/app/bag/bag.ts (ButtonComp)</h4></header><code-example language="ts" format="">@Component({
  selector: &#39;button-comp&#39;,
  template: `
    &lt;button (click)=&quot;clicked()&quot;&gt;Click me!&lt;/button&gt;
    &lt;span&gt;{{message}}&lt;/span&gt;`
})
export class ButtonComponent {
  isOn = false;
  clicked() { this.isOn = !this.isOn; }
  get message() { return `The light is ${this.isOn ? &#39;On&#39; : &#39;Off&#39;}`; }
}
</code-example></div><p>The following Angular test demonstrates that clicking a button in the template leads
to an update of the on-screen message.</p>
<p>下面的Angular测试演示点击模板里的按钮后，引起了屏幕上的消息的更新。</p>
<div class="code-example"><header><h4>src/app/bag/bag.spec.ts (ButtonComp)</h4></header><code-example language="ts" format="">it(&#39;should support clicking a button&#39;, () =&gt; {
  const fixture = TestBed.createComponent(ButtonComponent);
  const btn  = fixture.debugElement.query(By.css(&#39;button&#39;));
  const span = fixture.debugElement.query(By.css(&#39;span&#39;)).nativeElement;

  fixture.detectChanges();
  expect(span.textContent).toMatch(/is off/i, &#39;before click&#39;);

  click(btn);
  fixture.detectChanges();
  expect(span.textContent).toMatch(/is on/i, &#39;after click&#39;);
});
</code-example></div><p>The assertions verify that the data values flow from one HTML control (the <code>&lt;button&gt;</code>) to the component and
from the component back to a <em>different</em> HTML control (the <code>&lt;span&gt;</code>).
A passing test means the component and its template are wired correctly.</p>
<p>该判断验证了数据绑定从一个HTML控件(<code>&lt;button&gt;</code>)流动到组件，以及从组件回到<strong>不同</strong>的HTML控件(<code>&lt;span&gt;</code>)。
通过的测试程序说明组件和它的模块是否设置正确。</p>
<p>Isolated unit tests can more rapidly probe a component at its API boundary,
exploring many more conditions with less effort.</p>
<p>孤立单元测试可以更快的在API边界探测组件，更轻松的探索更多条件。</p>
<p>Here are a set of unit tests that verify the component&#39;s outputs in the face of a variety of
component inputs.</p>
<p>下面是一套单元测试程序，用来验证面对多种输入时组件的输出。</p>
<div class="code-example"><header><h4>src/app/bag/bag.no-testbed.spec.ts (ButtonComp)</h4></header><code-example language="ts" format="">describe(&#39;ButtonComp&#39;, () =&gt; {
  let comp: ButtonComponent;
  beforeEach(() =&gt; comp = new ButtonComponent());

  it(&#39;#isOn should be false initially&#39;, () =&gt; {
    expect(comp.isOn).toBe(false);
  });

  it(&#39;#clicked() should set #isOn to true&#39;, () =&gt; {
    comp.clicked();
    expect(comp.isOn).toBe(true);
  });

  it(&#39;#clicked() should set #message to &quot;is on&quot;&#39;, () =&gt; {
    comp.clicked();
    expect(comp.message).toMatch(/is on/i);
  });

  it(&#39;#clicked() should toggle #isOn&#39;, () =&gt; {
    comp.clicked();
    expect(comp.isOn).toBe(true);
    comp.clicked();
    expect(comp.isOn).toBe(false);
  });
});
</code-example></div><p>Isolated component tests offer a lot of test coverage with less code and almost no setup.
This is even more of an advantage with complex components, which
may require meticulous preparation with the Angular testing utilities.</p>
<p>孤立组件单元测试使用更少的代码以及几乎不存在的配置，提供了很多测试覆盖率。
在测试复杂的组件时，这个优势显得更加明显，因为可能需要使用Angular测试工具进行精心准备。</p>
<p>On the other hand, isolated unit tests can&#39;t confirm that the <code>ButtonComp</code> is
properly bound to its template or even data bound at all.
Use Angular tests for that.</p>
<p>但是，孤立测试无法确认<code>ButtonComp</code>是否与其模板正确的绑定，或者是否有数据绑定。
使用Angular测试来应对它们。</p>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l-hr"></div><a id="atu-apis"></a><h2 id="angular-testing-utility-apis">Angular testing utility APIs</h2>
<h2 id="angular-api">Angular测试工具API</h2>
<p>This section takes inventory of the most useful Angular testing features and summarizes what they do.</p>
<p>本节将最有用的Angular测试功能提取出来，并总结了它们的作用。</p>
<p>The Angular testing utilities include the <code>TestBed</code>, the <code>ComponentFixture</code>, and a handful of functions that control the test environment.
The <a href="#testbed-api-summary"><em>TestBed</em></a> and <a href="#component-fixture-api-summary"><em>ComponentFixture</em></a> classes are covered separately.</p>
<p>Angular测试工具包括<code>TestBed</code>、<code>ComponentFixture</code>和一些其他函数，用来控制测试环境。
<a href="#testbed-api-summary"><em>TestBed</em></a>和<a href="#component-fixture-api-summary"><em>ComponentFixture</em></a>在这里分别解释了。</p>
<p>Here&#39;s a summary of the stand-alone functions, in order of likely utility:</p>
<p>下面是一些独立函数的总结，以使用频率排序：</p>
<table><tr><th><p>Function</p><p>函数</p></th><th><p>Description</p><p>描述</p></th></tr><tr><td style="vertical-align: top"><code>async</code></td><td><p>Runs the body of a test (<code>it</code>) or setup (<code>beforeEach</code>) function within a special <em>async test zone</em>.
See <a href="#async">discussion above</a>.</p>
<p>在特殊的<strong>async测试区域</strong>运行测试程序（<code>it</code>)或者设置（<code>beforeEach</code>）的主体。
参见<a href="#async">上面的讨论</a>.</p>
</td></tr><tr><td style="vertical-align: top"><code>fakeAsync</code></td><td><p>Runs the body of a test (<code>it</code>) within a special <em>fakeAsync test zone</em>, enabling
a linear control flow coding style. See <a href="#fake-async">discussion above</a>.</p>
<p>在特殊的<strong>fakeAsync测试区域</strong>运行测试程序（<code>it</code>）的主体，造就控制流更加线性的代码风格。
参见<a href="#fake-async">上面的讨论</a>.</p>
</td></tr><tr><td style="vertical-align: top"><code>tick</code></td><td><p>Simulates the passage of time and the completion of pending asynchronous activities
by flushing both <em>timer</em> and <em>micro-task</em> queues within the <em>fakeAsync test zone</em>.</p>
<p>在<strong>fakeAsync测试区域</strong>内触发<strong>计时器</strong>和<strong>微任务</strong>队列，以模拟时间的推移和未完成异步任务的完成。</p>
<div class="l-sub-section"><p>The curious, dedicated reader might enjoy this lengthy blog post,
&quot;<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank"><em>Tasks, microtasks, queues and schedules</em></a>&quot;.</p>
<p>好奇和执着的读者可能会喜欢这篇长博客：
&quot;<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank"><em>Tasks, microtasks, queues and schedules</em></a>&quot;.</p>
</div><p>Accepts an optional argument that moves the virtual clock forward
by the specified number of milliseconds,
clearing asynchronous activities scheduled within that timeframe.
See <a href="#tick">discussion above</a>.</p>
<p>接受一个可选参数，往前推移虚拟时间提供数字的毫秒数，清除在这段时间内的异步行为。
参见<a href="#tick">上面的讨论</a></p>
</td></tr><tr><td style="vertical-align: top"> <code>inject</code></td><td><p>Injects one or more services from the current <code>TestBed</code> injector into a test function.
See <a href="#inject">above</a>.</p>
<p>从当前<code>TestBed</code>注入器注入一个或多个服务到测试函数。参见<a href="#inject">上面</a>。</p>
</td></tr><tr><td style="vertical-align: top"><code>discardPeriodicTasks</code></td><td><p>When a <code>fakeAsync</code> test ends with pending timer event <em>tasks</em> (queued <code>setTimeOut</code> and <code>setInterval</code> callbacks),
the test fails with a clear error message.</p>
<p>当<code>fakeAsync</code>测试程序以正在运行的计时器事件<strong>任务</strong>（排队中的<code>setTimeOut</code>和<code>setInterval</code>的回调）结束时，
测试会失败，并显示一条明确的错误信息。</p>
<p>In general, a test should end with no queued tasks. 
When pending timer tasks are expected, call <code>discardPeriodicTasks</code> to flush the <em>task</em> queue
and avoid the error.</p>
<p>一般来讲，测试程序应该以无排队任务结束。
当待执行计时器任务存在时，调用<code>discardPeriodicTasks</code>来触发<strong>任务</strong>队列，防止该错误发生。</p>
</td></tr><tr><td style="vertical-align: top"><code>flushMicrotasks</code></td><td><p>When a <code>fakeAsync</code> test ends with pending <em>micro-tasks</em> such as unresolved promises,
the test fails with a clear error message.</p>
<p>当<code>fakeAsync</code>测试程序以待执行<strong>微任务</strong>（比如未解析的承诺）结束时，测试会失败并显示明确的错误信息。</p>
<p>In general, a test should wait for micro-tasks to finish.
When pending microtasks are expected, call <code>flushMicrotasks</code> to flush the  <em>micro-task</em> queue
and avoid the error.</p>
<p>一般来说，测试应该等待微任务结束。
当待执行微任务存在时，调用<code>flushMicrotasks</code>来触发<strong>微任务</strong>队列，防止该错误发生。</p>
</td></tr><tr><td style="vertical-align: top"><code>ComponentFixtureAutoDetect</code></td><td><p>A provider token for a service that turns on <a href="#automatic-change-detection">automatic change detection</a>.</p>
<p>一个提供商令牌，用来设置<strong>auto-changeDetect</strong>的值，它默认值为<code>false</code>。
参见<a href="#automatic-change-detection">自动变更检测</a></p>
</td></tr><tr><td style="vertical-align: top"><code>getTestBed</code></td><td><p>Gets the current instance of the <code>TestBed</code>.
Usually unnecessary because the static class methods of the <code>TestBed</code> class are typically sufficient.
The <code>TestBed</code> instance exposes a few rarely used members that are not available as
static methods.</p>
<p>获取当前<code>TestBed</code>实例。
通常用不上，因为<code>TestBed</code>的静态类方法已经够用。
<code>TestBed</code>实例有一些很少需要用到的方法，它们没有对应的静态方法。</p>
</td></tr></table><div class="l-hr"></div><a id="testbed-class-summary"></a><h3 id="_testbed_-class-summary"><em>TestBed</em> class summary</h3>
<h3 id="_testbed_-"><em>TestBed</em> 类总结</h3>
<p>The <code>TestBed</code> class is one of the principal Angular testing utilities.
Its API is quite large and can be overwhelming until you&#39;ve explored it,
a little at a time. Read the early part of this guide first
to get the basics before trying to absorb the full API.</p>
<p><code>TestBed</code>类是Angular测试工具的主要类之一。它的API很庞大，可能有点过于复杂，直到你一点一点的探索它们。
阅读本章前面的部分，了解了基本的知识以后，再试着了解完整API。</p>
<p>The module definition passed to <code>configureTestingModule</code> 
is a subset of the <code>@NgModule</code> metadata properties.</p>
<p>传递给<code>configureTestingModule</code>的模块定义是<code>@NgModule</code>元数据属性的子集。</p>
<code-example format="." language="javascript">type TestModuleMetadata = {
  providers?: any[];
  declarations?: any[];
  imports?: any[];
  schemas?: Array&lt;SchemaMetadata | any[]&gt;;
};
</code-example><a id="metadata-override-object"></a><p>Each override method takes a <code>MetadataOverride&lt;T&gt;</code> where <code>T</code> is the kind of metadata
appropriate to the method, that is, the parameter of an <code>@NgModule</code>,
<code>@Component</code>, <code>@Directive</code>, or <code>@Pipe</code>.</p>
<p>每一个重载方法接受一个<code>MetadataOverride&lt;T&gt;</code>，这里<code>T</code>是适合这个方法的元数据类型，也就是<code>@NgModule</code>、<code>@Component</code>、<code>@Directive</code>或者<code>@Pipe</code>的参数。</p>
<code-example format="." language="javascript">type MetadataOverride<t> = {
  add?: T;
  remove?: T;
  set?: T;
};
</t></code-example><a id="testbed-methods"></a><p>The <code>TestBed</code> API consists of static class methods that either update or reference a <em>global</em> instance of the<code>TestBed</code>.</p>
<p><code>TestBed</code>的API包含了一系列静态类方法，它们更新或者引用<strong>全局</strong>的<code>TestBed</code>实例。</p>
<p>Internally, all static methods cover methods of the current runtime <code>TestBed</code> instance ,
which is also returned by the <code>getTestBed()</code> function.</p>
<p>在内部，所有静态方法在<code>getTestBed()</code>函数返回的当前运行时间的<code>TestBed</code>实例上都有对应的方法。</p>
<p>Call <code>TestBed</code> methods <em>within</em> a <code>beforeEach()</code> to ensure a fresh start before each individual test.</p>
<p>在<code>BeforeEach()</code>内调用<code>TestBed</code>方法，这样确保在运行每个单独测试时，都有崭新的开始。</p>
<p>Here are the most important static methods, in order of likely utility.</p>
<p>这里列出了最重要的静态方法，以使用频率排序：</p>
<table><tr><th><p>Methods</p><p>方法</p></th><th><p>Description</p><p>描述</p></th></tr><tr><td style="vertical-align: top"><code>configureTestingModule</code></td><td><p>The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>)
establish the <a href="##testbed-initTestEnvironment">initial test environment</a> and a default testing module.
The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs.</p>
<p>测试垫片（<code>karma-test-shim</code>, <code>browser-test-shim</code>）创建了<a href="##testbed-initTestEnvironment">初始测试环境</a>和默认测试模块。
默认测试模块是使用基本声明和一些Angular服务替代品，它们是所有测试程序都需要的。</p>
<p>Call <code>configureTestingModule</code> to refine the testing module configuration for a particular set of tests
by adding and removing imports, declarations (of components, directives, and pipes), and providers.</p>
<p>调用<code>configureTestingModule</code>来为一套特定的测试定义测试模块配置，添加和删除导入、（组件、指令和管道的）声明和服务提供商。</p>
</td></tr><tr><td style="vertical-align: top"><code>compileComponents</code></td><td><p>Compile the testing module asynchronously after you&#39;ve finished configuring it.
You <strong>must</strong> call this method if <em>any</em> of the testing module components have a <code>templateUrl</code>
or <code>styleUrls</code> because fetching component template and style files is necessarily asynchronous.
See <a href="#compile-components">above</a>.</p>
<p>在你完成配置以后异步编译测试模块。
如果<strong>任何</strong>测试组件有<code>templateUrl</code>或<code>styleUrls</code>，那么你<strong>必须</strong>调用这个方法。因为获取组件模块和样式文件必须是异步的。
参见<a href="#compile-components">上面的描述</a>。</p>
<p>After calling <code>compileComponents</code>, the <code>TestBed</code> configuration is frozen for the duration of the current spec.</p>
<p>调用完<code>compileComponents</code>之后，<code>TestBed</code>的配置就会在当前测试期间被冻结。</p>
</td></tr><tr><td style="vertical-align: top"><code>createComponent<t></t></code></td><td><p>Create an instance of a component of type <code>T</code> based on the current <code>TestBed</code> configuration.
After calling <code>compileComponent</code>, the <code>TestBed</code> configuration is frozen for the duration of the current spec.</p>
<p>基于当前<code>TestBed</code>的配置创建一个类型为T的组件实例。
一旦调用，<code>TestBed</code>的配置就会在当前测试期间被冻结。</p>
</td></tr><tr><td style="vertical-align: top"><code>overrideModule</code></td><td><p>Replace metadata for the given <code>NgModule</code>. Recall that modules can import other modules.
The <code>overrideModule</code> method can reach deeply into the current testing module to
modify one of these inner modules.</p>
<p>替换指定的<code>NgModule</code>的元数据。回想一下，模块可以导入其他模块。
<code>overrideModule</code>方法可以深入到当前测试模块深处，修改其中一个内部模块。</p>
</td></tr><tr><td style="vertical-align: top"><code>overrideComponent</code></td><td><p>Replace metadata for the given component class, which could be nested deeply
within an inner module.</p>
<p>替换指定组件类的元数据，该组件类可能嵌套在一个很深的内部模块中。</p>
</td></tr><tr><td style="vertical-align: top"><code>overrideDirective</code></td><td><p>Replace metadata for the given directive class, which could be nested deeply
within an inner module.</p>
<p>替换指定指令类的元数据，该指令可能嵌套在一个很深的内部模块中。</p>
</td></tr><tr><td style="vertical-align: top"><code>overridePipe</code></td><td><p>Replace metadata for the given pipe class, which could be nested deeply
within an inner module.</p>
<p>替换指定管道类的元数据，该管道可能嵌套在一个很深的内部模块中。</p>
</td></tr><tr><td style="vertical-align: top"><a id="testbed-get"></a>
<code>get</code></td><td><p>Retrieve a service from the current <code>TestBed</code> injector.</p>
<p>从当前<code>TestBed</code>注入器获取一个服务。</p>
<p>The <code>inject</code> function is often adequate for this purpose.
But <code>inject</code> throws an error if it can&#39;t provide the service.
What if the service is optional?</p>
<p><code>inject</code>函数通常很适合这个任务。
但是如果<code>inject</code>不能提供服务，它会抛出错误。
如果服务是可选的呢？</p>
<p>The <code>TestBed.get</code> method takes an optional second parameter,
the object to return if Angular can&#39;t find the provider
(<code>null</code> in this example):</p>
<p><code>TestBed.get</code>方法接受一个可选的第二参数，它是在Angular找不到所需提供商时返回的对象。（在本例中为<code>null</code>）：</p>
<div class="code-example"><code-example language="ts" format="">service = TestBed.get(FancyService, null);
</code-example></div><p>After calling <code>get</code>, the <code>TestBed</code> configuration is frozen for the duration of the current spec.</p>
<p>一旦调用，<code>TestBed</code>的配置就会在当前测试期间被冻结。</p>
</td></tr><tr><td style="vertical-align: top"><a id="testbed-initTestEnvironment"></a>
<code>initTestEnvironment</code></td><td><p>Initialize the testing environment for the entire test run.</p>
<p>为整套测试的运行初始化测试环境。</p>
<p>The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) call it for you
so there is rarely a reason for you to call it yourself.</p>
<p>测试垫片(<code>karma-test-shim</code>, <code>browser-test-shim</code>)会为你调用它，所以你很少需要自己调用它。</p>
<p>You may call this method <em>exactly once</em>. If you must change
this default in the middle of your test run, call <code>resetTestEnvironment</code> first.</p>
<p>这个方法只能被调用<strong>一次</strong>。如果确实需要在测试程序运行期间变换这个默认设置，那么先调用<code>resetTestEnvironment</code>。</p>
<p>Specify the Angular compiler factory, a <code>PlatformRef</code>, and a default Angular testing module.
Alternatives for non-browser platforms are available in the general form
<code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code>.</p>
<p>指定Angular编译器工厂，<code>PlatformRef</code>，和默认Angular测试模块。
以<code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code>的形式提供非浏览器平台的替代品。</p>
</td></tr><tr><td style="vertical-align: top"><code>resetTestEnvironment</code></td><td><p>Reset the initial test environment, including the default testing module.</p>
<p>重设初始测试环境，包括默认测试模块在内。</p>
</td></tr></table><p>A few of the <code>TestBed</code> instance methods are not covered by static <code>TestBed</code> <em>class</em> methods.
These are rarely needed.</p>
<p>少数<code>TestBed</code>实例方法没有对应的静态方法。它们很少被使用。</p>
<a id="component-fixture-api-summary"></a><h3 id="the-_componentfixture_">The <em>ComponentFixture</em></h3>
<h3 id="_componentfixture_-"><em>ComponentFixture</em>对象</h3>
<p>The <code>TestBed.createComponent&lt;T&gt;</code>
creates an instance of the component <code>T</code>
and returns a strongly typed <code>ComponentFixture</code> for that component.</p>
<p><code>TestBed.createComponent&lt;T&gt;</code>创建一个组件<code>T</code>的实例，并为该组件返回一个强类型的<code>ComponentFixture</code>。</p>
<p>The <code>ComponentFixture</code> properties and methods provide access to the component,
its DOM representation, and aspects of its Angular environment.</p>
<p><code>ComponentFixture</code>的属性和方法提供了对组件、它的DOM和它的Angular环境方面的访问。</p>
<a id="component-fixture-properties"></a><h3 id="_componentfixture_-properties"><em>ComponentFixture</em> properties</h3>
<h3 id="_componentfixture_-"><em>ComponentFixture</em>的属性</h3>
<p>Here are the most important properties for testers, in order of likely utility.</p>
<p>下面是对测试最重要的属性，以使用频率排序：</p>
<table><tr><th><p>Properties</p><p>属性</p></th><th><p>Description</p><p>描述</p></th></tr><tr><td style="vertical-align: top"><code>componentInstance</code></td><td><p>The instance of the component class created by <code>TestBed.createComponent</code>.</p>
<p>被<code>TestBed.createComponent</code>创建的组件类实例。</p>
</td></tr><tr><td style="vertical-align: top"><code>debugElement</code></td><td><p>The <code>DebugElement</code> associated with the root element of the component.</p>
<p>与组件根元素关联的<code>DebugElement</code>。</p>
<p>The <code>debugElement</code> provides insight into the component and its DOM element during test and debugging.
It&#39;s a critical property for testers. The most interesting members are covered <a href="#debug-element-details">below</a>.</p>
<p><code>debugElement</code>在测试和调试期间，提供对组件及其DOM元素的访问。
它是测试者至关重要的属性。它最有用的成员在<a href="#debug-element-details">下面</a>有所介绍。</p>
</td></tr><tr><td style="vertical-align: top"><code>nativeElement</code></td><td><p>The native DOM element at the root of the component.</p>
<p>组件的原生根DOM元素。</p>
</td></tr><tr><td style="vertical-align: top"><code>changeDetectorRef</code></td><td><p>The <code>ChangeDetectorRef</code> for the component.</p>
<p>组件的<code>ChangeDetectorRef</code>。</p>
<p>The <code>ChangeDetectorRef</code> is most valuable when testing a
component that has the <code>ChangeDetectionStrategy.OnPush</code> method
or the component&#39;s change detection is under your programmatic control.</p>
<p>在测试一个拥有<code>ChangeDetectionStrategy.OnPush</code>的组件，或者在组件的变化测试在你的程序控制下时，<code>ChangeDetectorRef</code>是最重要的。</p>
</td></tr></table><a id="component-fixture-methods"></a><h3 id="_componentfixture_-methods"><em>ComponentFixture</em> methods</h3>
<h3 id="_componentfixture_-"><em>ComponentFixture</em>的方法</h3>
<p>The <em>fixture</em> methods cause Angular to perform certain tasks on the component tree.
Call these method to trigger Angular behavior in response to simulated user action.</p>
<p><strong>fixture</strong>方法使Angular对组件树执行某些任务。
在触发Angular行为来模拟的用户行为时，调用这些方法。</p>
<p>Here are the most useful methods for testers.</p>
<p>下面是对测试最有用的方法。</p>
<table><tr><th><p>Methods</p><p>方法</p></th><th><p>Description</p><p>描述</p></th></tr><tr><td style="vertical-align: top"><code>detectChanges</code></td><td><p>Trigger a change detection cycle for the component.</p>
<p>为组件触发一轮变化检查。</p>
<p>Call it to initialize the component (it calls <code>ngOnInit</code>) and after your
test code, change the component&#39;s data bound property values.
Angular can&#39;t see that you&#39;ve changed <code>personComponent.name</code> and won&#39;t update the <code>name</code>
binding until you call <code>detectChanges</code>.</p>
<p>调用它来初始化组件（它调用<code>ngOnInit</code>）。或者在你的测试代码改变了组件的数据绑定属性值后调用它。
Angular不能检测到你已经改变了<code>personComponent.name</code>属性，也不会更新<code>name</code>的绑定，直到你调用了<code>detectChanges</code>。</p>
<p>Runs <code>checkNoChanges</code>afterwards to confirm that there are no circular updates unless
called as <code>detectChanges(false)</code>;</p>
<p>之后，运行<code>checkNoChanges</code>，来确认没有循环更新，除非它被这样调用：<code>detectChanges(false)</code>。</p>
</td></tr><tr><td style="vertical-align: top"><code>autoDetectChanges</code></td><td><p>Set this to <code>true</code> when you want the fixture to detect changes automatically.</p>
<p>设置fixture是否应该自动试图检测变化。</p>
<p>When autodetect is <code>true</code>, the test fixture calls <code>detectChanges</code> immediately
after creating the component. Then it listens for pertinent zone events
and calls <code>detectChanges</code> accordingly.
When your test code modifies component property values directly,
you probably still have to call <code>fixture.detectChanges</code> to trigger data binding updates.</p>
<p>当自动检测打开时，测试fixture监听<strong>zone</strong>事件，并调用<code>detectChanges</code>。
当你的测试代码直接修改了组件属性值时，你还是要调用<code>fixture.detectChanges</code>来触发数据绑定更新。</p>
<p>The default is <code>false</code>. Testers who prefer fine control over test behavior
tend to keep it <code>false</code>.</p>
<p>默认值是<code>false</code>，喜欢对测试行为进行精细控制的测试者一般保持它为<code>false</code>。</p>
</td></tr><tr><td style="vertical-align: top"><code>checkNoChanges</code></td><td><p>Do a change detection run to make sure there are no pending changes.
Throws an exceptions if there are.</p>
<p>运行一次变更检测来确认没有待处理的变化。如果有未处理的变化，它将抛出一个错误。</p>
</td></tr><tr><td style="vertical-align: top"><code>isStable</code></td><td><p>If the fixture is currently <em>stable</em>, returns <code>true</code>.
If there are async tasks that have not completed, returns <code>false</code>.</p>
<p>如果fixture当前是<strong>稳定的</strong>，则返回<code>true</code>。
如果有异步任务没有完成，则返回<code>false</code>。</p>
</td></tr><tr><td style="vertical-align: top"><code>whenStable</code></td><td><p>Returns a promise that resolves when the fixture is stable.</p>
<p>返回一个承诺，在fixture稳定时解析。</p>
<p>To resume testing after completion of asynchronous activity or
asynchronous change detection, hook that promise.
See <a href="#when-stable">above</a>.</p>
<p>钩住这个承诺，以在异步行为或者异步变更检测之后继续测试。参见<a href="#when-stable">上面</a>。</p>
</td></tr><tr><td style="vertical-align: top"><code>destroy</code></td><td><p>Trigger component destruction.</p>
<p>触发组件的销毁。</p>
</td></tr></table><a id="debug-element-details"></a><h3 id="_debugelement_"><em>DebugElement</em></h3>
<p>The <code>DebugElement</code> provides crucial insights into the component&#39;s DOM representation.</p>
<p><code>DebugElement</code>提供了对组件的DOM的访问。</p>
<p>From the test root component&#39;s <code>DebugElement</code> returned by <code>fixture.debugElement</code>,
you can walk (and query) the fixture&#39;s entire element and component subtrees.</p>
<p><code>fixture.debugElement</code>返回测试根组件的<code>DebugElement</code>，通过它你可以访问（查询）fixture的整个元素和组件子树。</p>
<p>Here are the most useful <code>DebugElement</code> members for testers, in approximate order of utility:</p>
<p>下面是<code>DebugElement</code>最有用的成员，以使用频率排序。</p>
<table><tr><th><p>Member</p><p>成员</p></th><th><p>Description</p><p>描述</p></th></tr><tr><td style="vertical-align: top"><code>nativeElement</code></td><td><p>The corresponding DOM element in the browser (null for WebWorkers).</p>
<p>与浏览器中DOM元素对应（WebWorkers时，值为null）。</p>
</td></tr><tr><td style="vertical-align: top"><code>query</code></td><td><p>Calling <code>query(predicate: Predicate&lt;DebugElement&gt;)</code> returns the first <code>DebugElement</code>
that matches the <a href="#query-predicate">predicate</a> at any depth in the subtree.</p>
<p>调用<code>query(predicate: Predicate&lt;DebugElement&gt;)</code>返回子树所有层中第一个匹配<a href="#query-predicate">predicate</a>的<code>DebugElement</code>。</p>
</td></tr><tr><td style="vertical-align: top"><code>queryAll</code></td><td><p>Calling <code>queryAll(predicate: Predicate&lt;DebugElement&gt;)</code> returns all <code>DebugElements</code>
that matches the <a href="#query-predicate">predicate</a> at any depth in subtree.</p>
<p>调用<code>query(predicate: Predicate&lt;DebugElement&gt;)</code>返回子树所有层中所有匹配<a href="#query-predicate">predicate</a><code>DebugElement</code>。</p>
</td></tr><tr><td style="vertical-align: top"><code>injector</code></td><td><p>The host dependency injector.
For example, the root element&#39;s component instance injector.</p>
<p>宿主依赖注入器。
比如，根元素的组件实例注入器。</p>
</td></tr><tr><td style="vertical-align: top"><code>componentInstance</code></td><td><p>The element&#39;s own component instance, if it has one.</p>
<p>元素自己的组件实例（如果有）。  </p>
</td></tr><tr><td style="vertical-align: top"><code>context</code></td><td><p>An object that provides parent context for this element.
Often an ancestor component instance that governs this element.</p>
<p>为元素提供父级上下文的对象。
通常是控制该元素的祖级组件实例。</p>
<p>When an element is repeated within <code>*ngFor</code>, the context is an <code>NgForRow</code> whose <code>$implicit</code>
property is the value of the row instance value.
For example, the <code>hero</code> in <code>*ngFor=&quot;let hero of heroes&quot;</code>.</p>
<p>当一个元素被<code>*ngFor</code>重复，它的上下文为<code>NgForRow</code>，它的<code>$implicit</code>属性值是该行的实例值。
比如，<code>*ngFor=&quot;let hero of heroes&quot;</code>里的<code>hero</code>。</p>
</td></tr><tr><td style="vertical-align: top"><code>children</code></td><td><p>The immediate <code>DebugElement</code> children. Walk the tree by descending through <code>children</code>.</p>
<p><code>DebugElement</code>的直接子级。通过<code>children</code>来降序探索元素树。</p>
<div class="l-sub-section"><p><code>DebugElement</code> also has <code>childNodes</code>, a list of <code>DebugNode</code> objects.
<code>DebugElement</code> derives from <code>DebugNode</code> objects and there are often
more nodes than elements. Testers can usually ignore plain nodes.</p>
<p><code>DebugElement</code>还有<code>childNodes</code>，即<code>DebugNode</code>对象列表。
<code>DebugElement</code>从<code>DebugNode</code>对象衍生，而且通常节点（node）比元素多。测试者通常忽略赤裸节点。</p>
</div></td></tr><tr><td style="vertical-align: top"><code>parent</code></td><td><p>The <code>DebugElement</code> parent. Null if this is the root element.</p>
<p><code>DebugElement</code>的父级。如果<code>DebugElement</code>是根元素，<code>parent</code>为null。</p>
</td></tr><tr><td style="vertical-align: top"><code>name</code></td><td><p>The element tag name, if it is an element.</p>
<p>元素的标签名字，如果它是一个元素的话。</p>
</td></tr><tr><td style="vertical-align: top"><code>triggerEventHandler</code></td><td><p>Triggers the event by its name if there is a corresponding listener
in the element&#39;s <code>listeners</code> collection.
The second parameter is the <em>event object</em> expected by the handler.
See <a href="#trigger-event-handler">above</a>.</p>
<p>如果在元素的<code>listeners</code>列表中有一个对应的<code>listener</code>，则以事件名字触发。
第二个参数是<strong>事件对象</strong>，一般为事件处理器。
参见<a href="#trigger-event-handler">上面</a>。</p>
<p>If the event lacks a listener or there&#39;s some other problem,
consider calling <code>nativeElement.dispatchEvent(eventObject)</code>.</p>
<p>如果事件缺乏监听器，或者有其它问题，考虑调用<code>nativeElement.dispatchEvent(eventObject)</code>。</p>
</td></tr><tr><td style="vertical-align: top"><code>listeners</code></td><td><p>The callbacks attached to the component&#39;s <code>@Output</code> properties and/or the element&#39;s event properties.</p>
<p>元素的<code>@Output</code>属性以及/或者元素的事件属性所附带的回调函数。</p>
</td></tr><tr><td style="vertical-align: top"><code>providerTokens</code></td><td><p>This component&#39;s injector lookup tokens.
Includes the component itself plus the tokens that the component lists in its <code>providers</code> metadata.</p>
<p>组件注入器的查询令牌。
包括组件自己的令牌和组件的<code>providers</code>元数据中列出来的令牌。</p>
</td></tr><tr><td style="vertical-align: top"><code>source</code></td><td><p>Where to find this element in the source component template.</p>
<p>source是在源组件模板中查询这个元素的处所。</p>
</td></tr><tr><td style="vertical-align: top"><code>references</code></td><td><p>Dictionary of objects associated with template local variables (e.g. <code>#foo</code>),
keyed by the local variable name.</p>
<p>与模板本地变量（比如<code>#foo</code>）关联的词典对象，关键字与本地变量名字配对。</p>
</td></tr></table><a id="query-predicate"></a><p>The <code>DebugElement.query(predicate)</code> and <code>DebugElement.queryAll(predicate)</code> methods take a
predicate that filters the source element&#39;s subtree for matching <code>DebugElement</code>.</p>
<p><code>DebugElement.query(predicate)</code>和<code>DebugElement.queryAll(predicate)</code>方法接受一个条件方法，
它过滤源元素的子树，返回匹配的<code>DebugElement</code>。</p>
<p>The predicate is any method that takes a <code>DebugElement</code> and returns a <em>truthy</em> value.
The following example finds all <code>DebugElements</code> with a reference to a template local variable named &quot;content&quot;:</p>
<p>这个条件方法是任何接受一个<code>DebugElement</code>并返回真值的方法。
下面的例子查询所有拥有名为<code>content</code>的模块本地变量的所有<code>DebugElement</code>：</p>
<div class="code-example"><code-example language="ts" format="">// Filter for DebugElements with a #content reference
const contentRefs = el.queryAll( de =&gt; de.references[&#39;content&#39;]);
</code-example></div><p>The Angular <code>By</code> class has three static methods for common predicates:</p>
<p>Angular的<code>By</code>类为常用条件方法提供了三个静态方法：</p>
<ul>
<li><p><code>By.all</code> - return all elements.</p>
<p><code>By.all</code> - 返回所有元素</p>
</li>
<li><p><code>By.css(selector)</code> - return elements with matching CSS selectors.</p>
<p><code>By.css(selector)</code> - 返回符合CSS选择器的元素。</p>
</li>
<li><p><code>By.directive(directive)</code> - return elements that Angular matched to an instance of the directive class.</p>
<p><code>By.directive(directive)</code> - 返回Angular能匹配一个指令类实例的所有元素。</p>
</li>
</ul>
<div class="code-example"><header><h4>src/app/hero/hero-list.component.spec.ts</h4></header><code-example language="ts" format="">// Can find DebugElement either by css selector or by directive
const h2        = fixture.debugElement.query(By.css(&#39;h2&#39;));
const directive = fixture.debugElement.query(By.directive(HighlightDirective));
</code-example></div><!-- Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Revive in future?#renderer-tests
:marked
  Many custom application directives inject the `Renderer` and call one of its `set...` methods.

  很多制定应用程序指令注入`Renderer`并调用它其中一个方法`set...`。
  
  The test environment substitutes the `DebugDomRender` for the runtime `Renderer`.
  The `DebugDomRender` updates additional dictionary properties of the `DebugElement`
  when something calls a `set...` method.
  
  运行时的`Renderer`在测试环境中的替代品为`DebugDomRender`。
  在调用`set...`方法时，`DebugDomRender`更新`DebugElement`额外词典属性。

  These dictionary properties are primarily of interest to authors of Angular DOM inspection tools
  but they may provide useful insights to testers as well.

  这些词典属性主要是为Angular DOM检测工具准备的，但是它们可能对测试者提供有用的信息。
  
table
  tr
    thp Dictionary
    p 词典thp Description
  p 描述tr
    td(style="vertical-align: top") <code>properties</code>
    td
      :marked
        Updated by `Renderer.setElementProperty`.
        Many Angular directives call it, including `NgModel`.

        被`Renderer.setElementProperty`更新。
                很多Angular指令调用它，包括`NgModel`。
  tr
    td(style="vertical-align: top") <code>attributes</code>
    td
      :marked
        Updated by `Renderer.setElementAttribute`.
        Angular `[attribute]` bindings call it.
  
        被`Renderer.setElementAttribute`更新。
        Angular的`[attribute]`绑定调用它。  
  tr
    td(style="vertical-align: top") <code>classes</code>
    td
      :marked
        Updated by `Renderer.setElementClass`.
        Angular `[class]` bindings call it.
  
        被`Renderer.setElementClass`更新。
        Angular的`[class]`绑定调用它。  
  tr
    td(style="vertical-align: top") <code>styles</code>
    td
      :marked
        Updated by `Renderer.setElementStyle`.
        Angular `[style]` bindings call it.
        
        被`Renderer.setElementStyle`更新。
        Angular的 `[style]`绑定调用它。--><p>Here&#39;s an example of <code>Renderer</code> tests from the <live-example plnkr="bag-specs">live &quot;Specs Bag&quot; sample</live-example>.</p>
<p>下面是<live-example plnkr="bag-specs">在线“Specs Bag”例子</live-example>中<code>Renderer</code>测试程序的例子</p>
<div class="code-example"><code-example language="ts" format="">it(&#39;BankAccountComponent should set attributes, styles, classes, and properties&#39;, () =&gt; {
  const fixture = TestBed.createComponent(BankAccountParentComponent);
  fixture.detectChanges();
  const comp = fixture.componentInstance;

  // the only child is debugElement of the BankAccount component
  const el = fixture.debugElement.children[0];
  const childComp = el.componentInstance as BankAccountComponent;
  expect(childComp).toEqual(jasmine.any(BankAccountComponent));

  expect(el.context).toBe(childComp, &#39;context is the child component&#39;);

  expect(el.attributes[&#39;account&#39;]).toBe(childComp.id, &#39;account attribute&#39;);
  expect(el.attributes[&#39;bank&#39;]).toBe(childComp.bank, &#39;bank attribute&#39;);

  expect(el.classes[&#39;closed&#39;]).toBe(true, &#39;closed class&#39;);
  expect(el.classes[&#39;open&#39;]).toBe(false, &#39;open class&#39;);

  expect(el.styles[&#39;color&#39;]).toBe(comp.color, &#39;color style&#39;);
  expect(el.styles[&#39;width&#39;]).toBe(comp.width + &#39;px&#39;, &#39;width style&#39;);
});
</code-example></div><a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">回到顶部</a><div class="l hr"></div><a id="setup-files"></a><h2 id="test-environment-setup-files">Test environment setup files</h2>
<h2 id="-">测试环境的设置文件</h2>
<p>Unit testing requires some configuration and bootstrapping that is captured in <em>setup files</em>.
The setup files for this guide are provided for you when you follow the <a href="setup.html">Setup</a> instructions.
The CLI delivers similar files with the same purpose.</p>
<p>单元测试需要一些配置和启动代码，它们被收集到了这些<em>设置文件</em>中。
当你遵循<a href="setup.html">环境设置</a>中的步骤操作时，就会得到这些设置文件。
CLI工具也会生成类似的文件。</p>
<p>Here&#39;s a brief description of this guide&#39;s setup files:</p>
<p>下面是对本章中这些设置文件的简短说明：</p>
<div class="l-sub-section"><p>The deep details of these files and how to reconfigure them for your needs
is a topic beyond the scope of this guide .</p>
<p>本章不会深入讲解这些文件的详情以及如何根据需要重新配置它们，那超出了本章的范围。</p>
</div><table width="100%"><col width="20%"><col width="80%"><tr><th> <p>File</p><p>文件</p></th><th> <p>Description</p><p>描述</p></th></tr><tr><td style="vertical-align: top"><code>karma.conf.js</code></td><td><p>The karma configuration file that specifies which plug-ins to use,
which application and test files to load, which browser(s) to use,
and how to report test results.</p>
<p>这个karma配置文件指定了要使用那些插件、要加载那些应用文件和测试文件、要使用哪些浏览器以及如何报告测试结果。</p>
<p>It loads three other setup files:</p>
<p>它加载了下列设置文件：</p>
<ul>
<li><code>systemjs.config.js</code></li>
<li><code>systemjs.config.extras.js</code></li>
<li><code>karma-test-shim.js</code></li>
</ul>
</td></tr><tr><td style="vertical-align: top"><code>karma-test-shim.js</code></td><td><p>This shim prepares karma specifically for the Angular test environment
and launches karma itself.
It loads the <code>systemjs.config.js</code> file as part of that process.</p>
<p>这个垫片（shim）文件为karma准备Angular特有的测试环境，并启动karma自身。
这期间，它还加载<code>systemjs.config.js</code>文件。</p>
</td></tr><tr><td style="vertical-align: top"><code>systemjs.config.js</code></td><td><p><a href="https://github.com/systemjs/systemjs/blob/master/README.md">SystemJS</a>
loads the application and test files.
This script tells SystemJS where to find those files and how to load them.
It&#39;s the same version of <code>systemjs.config.js</code> you installed during <a href="#setup">setup</a>.</p>
<p><a href="https://github.com/systemjs/systemjs/blob/master/README.md">SystemJS</a>加载应用文件和测试文件。
这个脚本告诉SystemJS到哪里去找那些文件，以及如何加载它们。
它和你在<a href="#setup">环境设置</a>期间安装的那个<code>systemjs.config.js</code>是同一个版本。</p>
</td></tr><tr><td style="vertical-align: top"><code>systemjs.config.extras.js</code></td><td><p>An optional file that supplements the SystemJS configuration in <code>systemjs.config.js</code> with
configuration for the specific needs of the application itself.</p>
<p>一个可选的文件，它会为<code>systemjs.config.js</code>中提供SystemJS的配置加上应用自身需要的特殊配置。</p>
<p>A stock <code>systemjs.config.js</code> can&#39;t anticipate those needs.
You fill the gaps here.</p>
<p>常规的<code>systemjs.config.js</code>文件无法满足那些需求，我们需要自己填充它。</p>
<p>The sample version for this guide adds the <strong>model barrel</strong>
to the SystemJs <code>packages</code> configuration.</p>
<p>本章的例子中把<em>*模型桶（barrel）</em>添加到了SystemJS的<code>packages</code>配置中。</p>
</td></tr><tr><td colspan="2"><div class="code-example"><header><h4>systemjs.config.extras.js</h4></header><code-example language="js" format="">/** App specific SystemJS configuration */
System.config({
  packages: {
    // barrels
    &#39;app/model&#39;: {main:&#39;index.js&#39;, defaultExtension:&#39;js&#39;},
    &#39;app/model/testing&#39;: {main:&#39;index.js&#39;, defaultExtension:&#39;js&#39;}
  }
});
</code-example></div></td></tr></table><h3 id="npm-packages">npm packages</h3>
<h3 id="npm-">npm包</h3>
<p>The sample tests are written to run in Jasmine and karma.
The two &quot;fast path&quot; setups added the appropriate Jasmine and karma npm packages to the
<code>devDependencies</code> section of the <code>package.json</code>.
They&#39;re installed when you run <code>npm install</code>.</p>
<p>这些范例测试是为在Jasmine和karma而写的。
那两条“捷径”设置会把适当的Jasmine和Karma包添加到<code>package.json</code>的<code>devDependencies</code>区。
当我们运行<code>npm install</code>时，它们就会被安装上。</p>
<a href="#top" class="to-top">Back to top</a><a href="#top" class="to-top">返回顶部</a><div class="l hr"><div id="faq"></div><div class="l-main-section"></div><h2 id="faq-frequently-asked-questions">FAQ: Frequently Asked Questions</h2>
<h2 id="-">常见问题</h2>
</div><!--:marked
  General

  * [When are end-to-end (e2e) tests a good choice?](#q-when-e2e)
  * [When to use the _TestBed_?](#q-why-testbed)
  * [When to write isolated unit tests without the _TestBed_?](#q-when-no-testbed)
  * [When can I skip _TestBed.compileComponents_?](#q-when-no-compile-components)
  * [Why must _TestBed.compileComponents_ be called last?](#q-why-compile-components-is-last)
  * [Why must _inject_ be called last?](#q-why-last-last)
  * [What's the difference between _async_ and _fakeAsync_?](#q-async-vs-fake-async)
  * [What's the difference between _whenStable_ and _tick_?](#q-when-stable-vs-tick)
  * [How do I get something from the component's injector?](#q-component-injector)
  * [Why do feature modules make testing easier?](#q-why-feature-modules)
  * [When should I prefer the _DynamicTestModule_?](#q-dynamic-test-module)
  * [How do I know if an injected service method was called?](#q-spy-on-service)
  * [When must I call _detectChanges_ and why?](#q-detect-changes)
  * [What's the difference between _triggerEventHandler_ and _dispatchEvent_?](#q-trigger-event-handler-vs-dispatch-event)
  * [How do I find an element by directive?](#q-by-directive)
  * [How do I extend Jasmine matchers?](#q-jasmine-matchers)
  * [Why would I add a test folder and how?](#q-test-folder)
  * [Why put specs next to the things they test?](#q-spec-file-location)
  * [When would I put specs in a test folder?](#q-specs-in-test-folder)
  * [How do I use the Jasmine HTML TestRunner in the browser?](#q-jasmine-browser-test-runner)

  Resources

  * [Where can I learn more about unit testing in JavaScript?](#q-js-unit-testing-resources)
  * [Where can I learn more about testing with Jasmine?](#q-jasmine-resources)
  * [Where can I learn more about testing with karma?](#q-karma-resources)
  * [Where can I learn more about e2e testing with protractor?](#q-protractor-resources)

a(href="#top").to-top Back to top

.l-hr
--><div id="q-spec-file-location"></div><h3 id="why-put-specs-next-to-the-things-they-test-">Why put specs next to the things they test?</h3>
<h3 id="-spec-">为何将测试的spec配置文件放置到被测试文件的傍边？</h3>
<p>It&#39;s a good idea to put unit test spec files in the same folder
as the application source code files that they test:</p>
<p>我们推荐将单元测试的spec配置文件放到与应用程序源代码文件所在的同一个文件夹中，因为：</p>
<ul>
<li><p>Such tests are easy to find.</p>
<p>这样的测试程序很容易被找到</p>
</li>
<li><p>You see at a glance if a part of your application lacks tests.</p>
<p>你可以一眼看出应用程序的那些部分缺乏测试程序。</p>
</li>
<li><p>Nearby tests can reveal how a part works in context.</p>
<p>临近的测试程序可以展示代码是如何在上下文中工作的</p>
</li>
<li><p>When you move the source (inevitable), you remember to move the test.</p>
<p>当你移动代码（无可避免）时，你记得一起移动测试程序</p>
</li>
<li><p>When you rename the source file (inevitable), you remember to rename the test file.</p>
<p>当你重命名源代码文件（无可避免），你记得重命名测试程序文件。</p>
</li>
</ul>
<div class="l-hr"></div><div id="q-specs-in-test-folder"></div><h3 id="when-would-i-put-specs-in-a-test-folder-">When would I put specs in a test folder?</h3>
<h3 id="-spec-">什么时候我应该把测试spec文件放到测试目录中？</h3>
<p>Application integration specs can test the interactions of multiple parts
spread across folders and modules.
They don&#39;t really belong to any part in particular, so they don&#39;t have a
natural home next to any one file.</p>
<p>应用程序的整合测试spec文件可以测试横跨多个目录和模块的多个部分之间的互动。
它们不属于任何部分，很自然，没有特别的地方存放它们。</p>
<p>It&#39;s often better to create an appropriate folder for them in the <code>tests</code> directory.</p>
<p>通常，在<code>test</code>目录中为它们创建一个合适的目录比较好。</p>
<p>Of course specs that test the test helpers belong in the <code>test</code> folder,
next to their corresponding helper files.</p>
<p>当然，<strong>测试助手对象</strong>的测试spec文件也属于<code>test</code>目录，与它们对应的助手文件相邻。</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></article><div data-swiftype-index="false" class="main-footer"><nav class="background-midnight grid-fluid"><div class="c3 main-footer-branding"><div class="logo-inverse-large"></div></div><div class="c2"><h3 class="text-headline">RESOURCES</h3><h3 class="text-headline">资源库</h3><ul class="text-body"><!-- TODO: (ericjim) make a libraries page to showcase all angular libraries--><!--li <a href="/libraries.html">Libraries</a>--><li><p><a href="/about/">About</a></p><p><a href="/about/">关于</a></p></li><li><p><a href="/resources/#Education">Books & Training</a></p><p><a href="/resources/#Education">书籍与培训</a></p></li><li><p><a href="/resources/">Tools & Libraries</a></p><p><a href="/resources/">工具与库</a></p></li><li><p><a href="/resources/">Community</a></p><p><a href="/resources/">社区</a></p></li><li><p><a href="/presskit.html">Press Kit</a></p><p><a href="/presskit.html">宣传资料</a></p></li></ul></div><div class="c2"><h3 class="text-headline">HELP</h3><h3 class="text-headline">帮助</h3><ul class="text-body"><li><a href="http://stackoverflow.com/questions/tagged/angular2">Stack Overflow</a></li><li><a href="https://gitter.im/angular/angular">Gitter</a></li><li><a href="https://groups.google.com/forum/#!forum/angular"> Google Group</a></li><li><p><a href="https://github.com/angular/angular/issues"> Report Issues</a></p><p><a href="https://github.com/angular/angular/issues"> 报告问题</a></p></li><li><p><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> Site Feedback</a></p><p><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> 网站反馈</a></p></li></ul></div><div class="c2"><h3 class="text-headline">COMMUNITY</h3><h3 class="text-headline">社区</h3><ul class="text-body"><li><p><a href="/events.html">Events</a></p><p><a href="/events.html">会议</a></p></li><li><a href="http://www.meetup.com/topics/angularjs/">Meetups</a></li><li><a href="https://twitter.com/angular"> Twitter</a></li><li><a href="https://github.com/angular/angular"> GitHub</a></li><li><p><a href="/contribute.html"> Contribute</a></p><p><a href="/contribute.html"> 做贡献</a></p></li></ul></div><div class="c2"><h3 class="text-headline">LANGUAGES</h3><h3 class="text-headline">其它语种</h3><ul class="text-body"><li><a href="https://angular.io/">英文版</a></li></ul></div></nav><footer class="background-midnight"><small class="text-caption">Powered by Google ©2010-2017。代码授权方式：<a href="/license">MIT-style License</a>。文档授权方式：<a href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>。</small><a aria-label="查看风格指南" href="/docs/ts/latest/styleguide.html" title="风格指南" md-button="md-button" class="styleguide-trigger text-snow translated-cn"><span class="icon-favorite"></span></a><p><small class="text-caption">本网站由洛阳永欣维护 &nbsp;<a href="http://www.miitbeian.gov.cn/">豫ICP备16019859号-1</a></small></p></footer></div><!-- VENDORS --><script src="/resources/js/vendor/prettify.js"></script><script src="/resources/js/vendor/lang-basic.js"></script><script src="/resources/js/vendor/lang-dart.js"></script><script src="/resources/js/vendor/lodash.js"></script><script src="/resources/js/vendor/clipboard.min.js"></script><!-- Angular Material Dependencies --><script src="/resources/js/vendor/angular.min.js"></script><script src="/resources/js/vendor/angular-animate.min.js"></script><script src="/resources/js/vendor/angular-aria.min.js"></script><script src="/resources/js/vendor/angular-material.min.js"></script><!-- Firebase -->
<script src="/resources/js/vendor/firebase.js"></script>
<!-- AngularFire -->
<script src="/resources/js/vendor/angularfire.min.js"></script>
<!-- Angular.io Site JS --><script src="/translate/cn/translate.js"></script><script src="/resources/js/site.js"></script><script src="/resources/js/util.js"></script><script src="/resources/js/controllers/app-controller.js"></script><script src="/resources/js/controllers/resources-controller.js"></script><script src="/resources/js/directives/cheatsheet.js"></script><script src="/resources/js/directives/api-list.js"></script><script src="/resources/js/directives/bio.js"></script><script src="/resources/js/directives/bold.js"></script><script src="/resources/js/directives/announcement-bar.js"></script><script src="/resources/js/directives/code.js"></script><script src="/resources/js/directives/copy.js"></script><script src="/resources/js/directives/code-tabs.js"></script><script src="/resources/js/directives/code-pane.js"></script><script src="/resources/js/directives/code-example.js"></script><script src="/resources/js/directives/if-docs.js"></script><script src="/resources/js/directives/live-example.js"></script><script src="/resources/js/directives/scroll-y-offset-element.js"></script><!-- GA --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-80456300-1', 'auto');
ga('send', 'pageview')
</script><!-- SWIFTYPE --><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','VsuU7kH5Hnnj9tfyNvfK','2.0.0');</script></body></html>