<!DOCTYPE html><html lang="en" ng-app="angularIOApp" itemscope itemtype="http://schema.org/Framework"><!-- template: public/docs/_layout--><head><title>服务 - ts - TUTORIAL</title><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="Angular是用于构建移动应用和桌面Web应用的开发平台"/><meta name="keywords" content="Angular, 中文, 中文版, AngularJS, AngularDart, Javscript, Dart, Framework, JavaScript MVC, Google"/><meta name="robots" content="all"/><meta name="referrer" content="origin"/><meta name="viewport" id="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Angular"/><meta property="og:image" content="/resources/images/logos/standard/shield-large.png"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="184"/><meta property="og:image:height" content="200"/><meta property="og:description" content="Angular是用于构建移动应用和桌面Web应用的开发平台"/><meta itemprop="name" content="Angular"/><meta itemprop="description" content="Angular是用于构建移动应用和桌面Web应用的开发平台"/><meta itemprop="image" content="/resources/images/logos/standard/shield-large.png"/><link rel="icon" type="image/x-icon" href="/resources/images/icons/favicon.ico"/><link rel="stylesheet" href="/resources/css/vendor/angular-material.min.css"/><link href="/resources/fonts/vendor/roboto.css" rel="stylesheet" type="text/css"/><link href="/resources/fonts/vendor/material-icons.css" rel="stylesheet"/><link rel="stylesheet" href="/resources/css/vendor/icomoon/style.css"/><link rel="stylesheet" href="/resources/css/vendor/animate.css"/><link rel="stylesheet" href="/resources/css/main.css"/><!-- MOBILE ICONS -->
<link rel="apple-touch-icon" sizes="57x57" href="/resources/images/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/resources/images/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/resources/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/resources/images/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/resources/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/resources/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/resources/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/resources/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/resources/images/favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-194x194.png" sizes="194x194">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/resources/images/favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/resources/images/favicons/manifest.json"></head><body ng-controller="AppCtrl as appCtrl" class="l-offset-nav l-offset-side-nav"><nav data-swiftype-index="false" scroll-y-offset-element="scroll-y-offset-element" class="main-nav l-pinned-top l-layer-5"><h1><a href="/" md-button>Angular <sup>by Google</sup></a></h1><button aria-label="查看菜单" ng-click="appCtrl.toggleMainMenu($event)" md-button="md-button" class="main-nav-button main-nav-mobile-trigger l-right">网站菜单 <span class="icon icon-arrow-drop-down"></span></button><ul ng-class="appCtrl.showMainNav ? 'is-visible' : ''"><li class="l-left"><a class="main-nav-button" href="/features.html" md-button>特性</a></li><li class="l-left"><a class="main-nav-button" href="/docs/ts/latest/" md-button>文档</a></li><li class="l-left"><a class="main-nav-button" href="/events.html" md-button>会议</a></li><li class="l-left"><a href="http://community.angular.cn/" target="_blank" md-button="md-button" class="main-nav-button">社区</a></li><li class="l-left"><a class="main-nav-button" href="/translate/cn/home.html" md-button>关于中文版</a></li><li class="l-right"><a class="main-nav-button" href="/docs/ts/latest/quickstart.html" md-button>立即开始！</a></li><li class="l-right"><a ng-click="appCtrl.toggleSource($event)" href="href" class="main-nav-button md-button ng-cloak"><span>{{appCtrl.sourceVisible?'Hide English':'Show English'}}</span></a></li></ul></nav><!-- Include this file ONLY when current.path[2] is defined--><nav data-swiftype-index="false" ng-class="appCtrl.showDocsNav ? 'is-visible' : ''" class="sidenav l-pinned-left l-layer-4 l-offset-nav"><!-- SEARCH BAR--><header class="sidenav-search st-input-wrapper"><div class="st-input-inner"><label for="search-io" class="is-hidden">搜索文档</label><input type="text" placeholder="搜索文档..." class="st-default-search-input"/></div><button aria-label="View Docs Menu" ng-click="appCtrl.toggleDocsMenu($event)" md-button="md-button" class="mobile-trigger button">文档 <span class="icon icon-arrow-drop-down"></span></button></header><ul class="sidenav-links"><li class="sidenav-section no-border"><a href="/docs/ts/latest/" class="nav-title">文档首页</a></li><!-- CORE DOCUMENTATION--><li class="sidenav-section-divider"><h3>核心文档</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/quickstart.html" title="快速起步" class="nav-title ">快速起步</a></li><li class="sidenav-section"><a href="/docs/ts/latest/cli-quickstart.html" title="使用 CLI 快速构建 Angular 应用" class="nav-title ">CLI 快速起步</a></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/" title="如何阅读本文档" class="nav-title is-parent ">开发指南<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/" title="如何阅读本文档">1. 概览</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/setup.html" title="安装 Angular 《快速起步》种子，更快更有效地在本地开发应用">2. 开发环境</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/learning-angular.html" title="Angular 初学者的推荐学习路径">3. 学习 Angular</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/architecture.html" title="Angular 应用的基本构造块">4. 架构</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/appmodule.html" title="如何在根 &quot;AppModule&quot; 中构建和启动应用。">5. 根模块</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/displaying-data.html" title="属性绑定机制把数据显示到用户界面上。">6. 显示数据</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/user-input.html" title="用户输入触发 DOM 事件。我们通过事件绑定来监听它们，把更新过的数据导入回我们的组件和 model。">7. 用户输入</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/forms.html" title="表单创建一个有机、有效、引人注目的数据输入体验。Angular 表单协调一组数据绑定控件，跟踪变更，验证输入的有效性，并且显示错误信息。">8. 表单</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/dependency-injection.html" title="Angular 的依赖注入系统能够即时地创建和交付所依赖的服务。">9. 依赖注入</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/template-syntax.html" title="学习如何写模板来显示数据，以及在数据绑定的帮助下响应用户事件。">10. 模板语法</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/cheatsheet.html" title="速查表">11. 速查表</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/style-guide.html" title="如何写 Angular 风格的程序">12. 风格指南</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/glossary.html" title="Angular 中最重要的词汇的简要定义">13. 词汇表</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/change-log.html" title="最新文档更新历史记录。">14. 更新记录</a></li></ul></div></li><li class="sidenav-section no-border"><a href="/docs/ts/latest/api/" title="API 参考手册" class="nav-title ">API参考手册</a></li><!-- ADVANCED DOCUMENATION--><li class="sidenav-section-divider"><h3>附加文档</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/tutorial/" title="英雄指南教程带我们一步步使用 TypeScript 创建 Angular 应用。" class="nav-title is-parent is-selected">教程<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists"><ul><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/" title="英雄指南教程带我们一步步使用 TypeScript 创建 Angular 应用。">1. 简介</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt1.html" title="构建一个简单的英雄编辑器">2. 英雄编辑器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt2.html" title="构建一个主从结构的页面，用于展现英雄列表">3. 主从结构</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt3.html" title="把主从结构的页面重构成多个组件">4. 多个组件</a></li><li class="nav-list-item is-selected"><a href="/docs/ts/latest/tutorial/toh-pt4.html" title="创建一个可复用的服务来调用英雄的数据">5. 服务</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt5.html" title="添加 Angular 组件路由，并且学习在视图之间导航">6. 路由</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt6.html" title="把服务和组件改为用 Angular 的 HTTP 服务实现">7. HTTP</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/animations.html" title="Angular 动画系统指南。" class="nav-title is-parent ">高级文档<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/animations.html" title="Angular 动画系统指南。" class="translated-cn">动画</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/attribute-directives.html" title="属性型指令把行为添加到现有元素上。" class="translated-cn">属性型指令</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/browser-support.html" title="浏览器支持与填充 (Polyfill) 指南" class="translated-cn">浏览器支持</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/component-styles.html" title="学习如何给组件应用 CSS 样式。" class="translated-cn">组件样式</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/deployment.html" title="如何部署Angular应用。" class="translated-cn">部署</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/hierarchical-dependency-injection.html" title="Angular 的多级依赖注入系统支持与组件树并行的嵌套式注入器。" class="translated-cn">多级注入器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/reactive-forms.html" title="使用FormBuilder、组合数组创建响应式表单。" class="translated-cn">响应式表单</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/server-communication.html" title="通过 HTTP 客户端与远程服务器对话。" class="translated-cn">HTTP 客户端</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/lifecycle-hooks.html" title="Angular 调用指令和组件的生命周期钩子函数，包括它的创建、变更和销毁时。" class="translated-cn">生命周期钩子</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/ngmodule.html" title="用 @NgModule 定义应用中的模块" class="translated-cn">Angular模块 (NgModule)</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/npm-packages.html" title="推荐的 npm 包以及如何指定所依赖的包" class="translated-cn">npm 包</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/pipes.html" title="管道可以在模板中转换显示的内容。" class="translated-cn">管道</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/router.html" title="揭示如何通过 Angular 路由进行基本的屏幕导航。" class="translated-cn">路由与导航</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/security.html" title="开发内容安全的 Angular 应用。" class="translated-cn">安全</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/setup-systemjs-anatomy.html" title="解析 SystemJS 本地开发环境" class="translated-cn">搭建剖析</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/structural-directives.html" title="Angular 有一个强力的模板引擎，它能让你轻松维护元素的DOM树结构。" class="translated-cn">结构型指令</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/testing.html" title="Angular 应用的测试技术与实践。" class="translated-cn">测试</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/typescript-configuration.html" title="Angular 开发者的 TypeScript 配置" class="translated-cn">TypeScript 配置</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/upgrade.html" title="AngularJS 应用可以逐步升级到 Angular。" class="translated-cn">从 AngularJS 升级</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/webpack.html" title="使用基于 Webpack 的工具创建 Angular 应用" class="translated-cn">Webpack 简介</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/cookbook/" title="一组常见 Angular 应用场景的“烹饪宝典”" class="nav-title is-parent ">烹饪宝典<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/" title="一组常见 Angular 应用场景的“烹饪宝典”" class="translated-cn">概览</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/aot-compiler.html" title="学习如何使用预编译器" class="translated-cn">预 (AoT) 编译器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ajs-quick-reference.html" title="学习如何把 AngularJS 中的概念和技术对应到 Angular 中" class="translated-cn">从 AngularJS 到 Angular</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-communication.html" title="在不同的指令和组件之间共享信息" class="translated-cn">组件通讯</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-relative-paths.html" title="为组件的模板和样式指定相对于组件的路径" class="translated-cn">相对于组件的路径</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dependency-injection.html" title="依赖注入技术" class="translated-cn">依赖注入</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dynamic-component-loader.html" title="如何动态加载组件" class="translated-cn">动态组件加载器</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dynamic-form.html" title="用 FormGroup 渲染动态表单" class="translated-cn">动态表单</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/form-validation.html" title="验证用户在表单中的输入" class="translated-cn">表单验证</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/i18n.html" title="把应用的模板文本翻译成多种语言。" class="translated-cn">国际化 (i18n)</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ngmodule-faq.html" title="对 @NgModule 常见问题的解答" class="translated-cn">Angular 模块常见问题</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/set-document-title.html" title="使用 Title 服务来设置文档标题或窗口标题" class="translated-cn">设置文档标题</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ts-to-js.html" title="把 Angular 的 TypeScript 范例转换为 ES6 和 ES5 JavaScript." class="translated-cn">从 TypeScript 到 JavaScript</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/visual-studio-2015.html" title="使用 Visual Studio 2015 快速起步" class="translated-cn">Visual Studio 2015 快速起步</a></li></ul></div></li></ul><nav class="dropdown"><button aria-label="选择Angular版本" md-button="md-button" ng-click="appCtrl.toggleVersionMenu($event)" class="dropdown-button">Angular for TypeScript  <span class="icon icon-arrow-drop-down"></span></button><div ng-click="appCtrl.toggleVersionMenu($event)" ng-show="appCtrl.showMenu" class="overlay ng-hide"></div><ul ng-class="appCtrl.showMenu ? 'is-visible' : ''" class="dropdown-menu"><li><a href="/docs/ts/latest/tutorial/toh-pt4.html" md-button>Angular for TypeScript </a></li><li><a href="/docs/js/latest/tutorial/toh-pt4.html" md-button>Angular for JavaScript </a></li><li><a href="/docs/dart/latest/tutorial/toh-pt4.html" md-button>Angular for Dart </a></li></ul></nav></nav><script>// Could put in appCtrl but only needed here and clear here
(function scrollToSelectedLink() {
  var sideNav = document.getElementsByClassName('sidenav')[0];
  var link = sideNav.getElementsByClassName('is-selected')[0];
  if (link && link.offsetTop > window.innerHeight) {
    sideNav.scrollTop = link.offsetTop - (window.innerHeight / 2);
    //alert("offsetTop: " + link.offsetTop + " side-nav top is " + sideNav.scrollTop);
  }
})()</script><header class="hero background-sky"><h1 class="hero-title ">服务 </h1><div class="clear"></div></header><div class="banner"><p class="text-body translated-cn">创建一个可复用的服务来调用英雄的数据</p></div><article class="l-content-small grid-fluid docs-content"><script>function why(id, backTo) {
  var id = "#"+id;
  var el = document.querySelector(id);
  el.hidden=el.hidden=!el.hidden;

  if (el.hidden && backTo){
    // the next line is required to work around a bug in WebKit (Chrome / Safari)
    location.href = "#";
    location.href =  "#" + backTo;
  }
}</script><script>function verbose(isVerbose) {
  isVerbose = !! isVerbose;
  var el = document.querySelector('button.verbose.off');
  el.style.display = isVerbose ? 'block' : 'none';
  var el = document.querySelector('button.verbose.on');
  el.style.display = isVerbose ? 'none' : 'block';

  CCSStylesheetRuleStyle('main','.l-verbose-section', 'display',
    isVerbose ? 'block' : 'none');
}
</script><script>function CCSStylesheetRuleStyle(stylesheet, selectorText, style, value){
  /* returns the value of the element style of the rule in the stylesheet
  *  If no value is given, reads the value
  *  If value is given, the value is changed and returned
  *  If '' (empty string) is given, erases the value.
  *  The browser will apply the default one
  *
  * string stylesheet: part of the .css name to be recognized, e.g. 'default'
  * string selectorText: css selector, e.g. '#myId', '.myClass', 'thead td'
  * string style: camelCase element style, e.g. 'fontSize'
  * string value optional : the new value
  */
  var CCSstyle = undefined, rules, sheet;
  for(var m in document.styleSheets){
    sheet = document.styleSheets[m];
    if(sheet.href && sheet.href.indexOf(stylesheet) != -1){
    rules = sheet[document.all ? 'rules' : 'cssRules'];
    for(var n in rules){
      console.log(rules[n].selectorText);
      if(rules[n].selectorText == selectorText){
        CCSstyle = rules[n].style;
        break;
      }
    }
    break;
    }
  }
  if(value == undefined)
    return CCSstyle[style]
  else
    return CCSstyle[style] = value
}
</script><p>As the Tour of Heroes app evolves, you&#39;ll add more components that need access to hero data.</p>
<p>随着《英雄指南》的成长，我们要添加更多需要访问英雄数据的组件。</p>
<p>Instead of copying and pasting the same code over and over,
you&#39;ll create a single reusable data service and
inject it into the components that need it.
Using a separate service keeps components lean and focused on supporting the view,
and makes it easy to unit-test components with a mock service.</p>
<p>为了不再把相同的代码复制一遍又一遍，我们要创建一个单一的可复用的数据服务，并且把它注入到需要它的那些组件中。
使用单独的服务可以保持组件精简，使其集中精力为视图提供支持，并且，借助模拟（Mock）服务，可以更容易的对组件进行单元测试。</p>
<p>Because data services are invariably asynchronous,
you&#39;ll finish the page with a <em>Promise</em>-based version of the data service.</p>
<p>由于数据服务总是异步的，因此我们最终会提供一个基于承诺（Promise）的数据服务。</p>
<p>When you&#39;re done with this page, the app should look like this <live-example></live-example>.</p>
<p>当我们完成本章的内容是，本应用会变成这样：<live-example></live-example>。</p>
<div class="l-main-section"></div><h2 id="where-you-left-off">Where you left off</h2>
<h2 id="-">延续上一步教程</h2>
<p>Before continuing with the Tour of Heroes, verify that you have the following structure.
If not, go back to the previous pages.</p>
<p>在继续《英雄指南》之前，先检查一下，是否已经有如下目录结构。如果没有，回上一章，看看错过了哪里。</p>
<div class="filetree"><div class="file">angular-tour-of-heroes</div><div class="children"><div class="file">src</div><div class="children"><div class="file">app</div><div class="children"><div class="file">app.component.ts</div><div class="file">app.module.ts</div><div class="file">hero.ts</div><div class="file">hero-detail.component.ts</div></div><div class="file">main.ts</div><div class="file">index.html</div><div class="file">styles.css</div><div class="file">systemjs.config.js</div><div class="file">tsconfig.json</div></div><div class="file">node_modules ...</div><div class="file">package.json</div></div></div><h2 id="keep-the-app-transpiling-and-running">Keep the app transpiling and running</h2>
<h2 id="-">让应用代码保持转译和运行</h2>
<p>Enter the following command in the terminal window:</p>
<p>在终端窗口中输入如下命令：</p>
<code-example language="sh" class="code-shell">npm start
</code-example><p>This command runs the TypeScript compiler in &quot;watch mode&quot;, recompiling automatically when the code changes.
The command simultaneously launches the app in a browser and refreshes the browser when the code changes.</p>
<p>这个命令会在“监听”模式下运行TypeScript编译器，当代码变化时，它会自动重新编译。
  同时，该命令还会在浏览器中启动该应用，并且当代码变化时刷新浏览器。</p>
<p>You can keep building the Tour of Heroes without pausing to recompile or refresh the browser.</p>
<p>在后续构建《英雄指南》过程中，应用能持续运行，而不用中断服务来编译或刷新浏览器。</p>
<h2 id="creating-a-hero-service">Creating a hero service</h2>
<h2 id="-">创建英雄服务</h2>
<p>The stakeholders want to show the heroes in various ways on different pages.
Users can already select a hero from a list.
Soon you&#39;ll add a dashboard with the top performing heroes and create a separate view for editing hero details.
All three views need hero data.</p>
<p>客户向我们描绘了本应用更大的目标：想要在不同的页面中用多种方式显示英雄。
  现在我们已经能从列表中选择一个英雄了，但这还不够。
  很快，我们将添加一个仪表盘来显示表现最好的英雄，并创建一个独立视图来编辑英雄的详情。
  所有这些视图都需要英雄数据。</p>
<p>At the moment, the <code>AppComponent</code> defines mock heroes for display.
However, defining heroes is not the component&#39;s job,
and you can&#39;t easily share the list of heroes with other components and views.
In this page, you&#39;ll move the hero data acquisition business to a single service that provides the data and
share that service with all components that need the data.</p>
<p>目前，<code>AppComponent</code>显示的是模拟数据。
不过，定义这些英雄并非组件的任务，否则我们没法与其它组件和视图共享这些英雄列表数据。
在这一章，我们将把获取英雄数据的任务重构为一个单独的服务，它将提供英雄数据，并把服务在所有需要英雄数据的组件间共享。</p>
<h3 id="create-the-heroservice">Create the HeroService</h3>
<h3 id="-heroservice">创建 HeroService</h3>
<p>Create a file in the <code>app</code> folder called <code>hero.service.ts</code>. </p>
<p>在<code>app</code>目录下创建一个名叫<code>hero.service.ts</code>的文件。</p>
<div class="l-sub-section"><p>The naming convention for service files is the service name in lowercase followed by <code>.service</code>.
For a multi-word service name, use lower <a href="../guide/glossary.html#!#dash-case">dash-case</a>.
For example, the filename for <code>SpecialSuperHeroService</code> is <code>special-super-hero.service.ts</code>.</p>
<p>我们遵循的文件命名约定是：服务名称的小写形式（基本名），加上<code>.service</code>后缀。
如果服务名称包含多个单词，我们就把基本名部分写成中线形式 (<a href="../guide/glossary.html#dash-case">dash-case</a>)。
例如，<code>SpecialSuperHeroService</code>服务应该被定义在<code>special-super-hero.service.ts</code>文件中。</p>
</div><p>Name the class <code>HeroService</code> and export it for others to import.</p>
<p>我们把这个类命名为<code>HeroService</code>，并导出它，以供别人使用。</p>
<div class="code-example"><header><h4>src/app/hero.service.ts (starting point)</h4></header><code-example language="ts" format="">import { Injectable } from &#39;@angular/core&#39;;

@Injectable()
export class HeroService {
}
</code-example></div><h3 id="injectable-services">Injectable services</h3>
<h3 id="-">可注入的服务</h3>
<p>Notice that you imported the Angular <code>Injectable</code> function and applied that function as an <code>@Injectable()</code> decorator.</p>
<p>注意，我们导入了 Angular 的<code>Injectable</code>函数，并作为<code>@Injectable()</code>装饰器使用这个函数。</p>
<div class="callout is-helpful"><p>Don&#39;t forget the parentheses. Omitting them leads to an error that&#39;s difficult to diagnose.</p>
<p><strong>不要忘了写圆括号！</strong>如果忘了写，就会导致一个很难诊断的错误。</p>
</div><p>The <code>@Injectable()</code> decorator tells TypeScript to emit metadata about the service.
The metadata specifies that Angular may need to inject other dependencies into this service.</p>
<p>当 TypeScript 看到<code>@Injectable()</code>装饰器时，就会记下本服务的元数据。
  如果 Angular 需要往这个服务中注入其它依赖，就会使用这些元数据。</p>
<p>Although the <code>HeroService</code> doesn&#39;t have any dependencies at the moment,
applying the <code>@Injectable()</code> decorator ​from the start ensures
consistency and future-proofing.</p>
<p>虽然<em>此时</em><code>HeroService</code>还没有任何依赖，但我们还是得加上这个装饰器。
作为一项最佳实践，无论是出于提高统一性还是减少变更的目的，
都应该从一开始就加上<code>@Injectable()</code>装饰器。</p>
<h3 id="getting-hero-data">Getting hero data</h3>
<h3 id="-">获取英雄数据</h3>
<p>Add a <code>getHeroes()</code> method stub.</p>
<p>添加一个名叫<code>getHeros</code>的桩方法。</p>
<div class="code-example"><header><h4>src/app/hero.service.ts (getHeroes stub)</h4></header><code-example language="ts" format="">@Injectable()
export class HeroService {
  getHeroes(): void {} // stub
}
</code-example></div><p>The <code>HeroService</code> could get <code>Hero</code> data from anywhere&mdash;a
web service, local storage, or a mock data source.
Removing data access from the component means
you can change your mind about the implementation anytime,
without touching the components that need hero data.</p>
<p><code>HeroService</code>可以从任何地方获取<code>Hero</code>数据 —— Web服务、本地存储或模拟数据源。
从组件中移除数据访问逻辑意味着你可以随时更改这些实现方式，而不影响需要这些英雄数据的组件。</p>
<h3 id="move-the-mock-hero-data">Move the mock hero data</h3>
<h3 id="-">移动模拟的英雄数据</h3>
<p>Cut the <code>HEROES</code> array from <code>app.component.ts</code> and paste it to a new file in the <code>app</code> folder named <code>mock-heroes.ts</code>.
Additionally, copy the <code>import {Hero} ...</code> statement because the heroes array uses the <code>Hero</code> class.</p>
<p>从<code>app.component.ts</code>文件中剪切<code>HEROS</code>数组，把它粘贴到<code>app</code>目录下一个名叫<code>mock-heroes.ts</code>的文件中。
还要复制<code>import {Hero}...</code>语句，因为我们的英雄数组用到了<code>Hero</code>类。</p>
<div class="code-example"><header><h4>src/app/mock-heroes.ts</h4></header><code-example language="ts" format="linenums">import { Hero } from &#39;./hero&#39;;

export const HEROES: Hero[] = [
  {id: 11, name: &#39;Mr. Nice&#39;},
  {id: 12, name: &#39;Narco&#39;},
  {id: 13, name: &#39;Bombasto&#39;},
  {id: 14, name: &#39;Celeritas&#39;},
  {id: 15, name: &#39;Magneta&#39;},
  {id: 16, name: &#39;RubberMan&#39;},
  {id: 17, name: &#39;Dynama&#39;},
  {id: 18, name: &#39;Dr IQ&#39;},
  {id: 19, name: &#39;Magma&#39;},
  {id: 20, name: &#39;Tornado&#39;}
];
</code-example></div><p>The <code>HEROES</code> constant is exported so it can be imported elsewhere, such as the <code>HeroService</code>.</p>
<p>我们导出了<code>HEROES</code>常量，以便可以在其它地方导入它 &mdash; 例如<code>HeroService</code>服务。</p>
<p>In <code>app.component.ts</code>, where you cut the <code>HEROES</code> array,
add an uninitialized <code>heroes</code> property:</p>
<p>在刚刚剪切出<code>HEROES</code>数组的<code>app.component.ts</code>文件中，添加一个尚未初始化的<code>heroes</code>属性：</p>
<div class="code-example"><header><h4>src/app/app.component.ts (heroes property)</h4></header><code-example language="ts" format="">heroes: Hero[];
</code-example></div><h3 id="return-mocked-hero-data">Return mocked hero data</h3>
<h3 id="-">返回模拟的英雄数据</h3>
<p>Back in the <code>HeroService</code>, import the mock <code>HEROES</code> and return it from the <code>getHeroes()</code> method.
The <code>HeroService</code> looks like this:</p>
<p>回到<code>HeroService</code>，我们导入<code>HEROES</code>常量，并在<code>getHeroes</code>方法中返回它。
我们的<code>HeroService</code>服务现在是这样的：</p>
<div class="code-example"><header><h4>src/app/hero.service.ts</h4></header><code-example language="ts" format="">import { Injectable } from &#39;@angular/core&#39;;

import { Hero } from &#39;./hero&#39;;
import { HEROES } from &#39;./mock-heroes&#39;;

@Injectable()
export class HeroService {
  getHeroes(): Hero[] {
    return HEROES;
  }
}
</code-example></div><h3 id="import-the-hero-service">Import the hero service</h3>
<h3 id="-heroservice">导入HeroService</h3>
<p>You&#39;re ready to use the <code>HeroService</code> in other components, starting with <code>AppComponent</code>.</p>
<p>我们可以在多个组件中使用 HeroService 服务了，先从 AppComponent 开始。</p>
<p>Import the <code>HeroService</code> so that you can reference it in the code.</p>
<p>先导入<code>HeroService</code>，以便我们可以在代码中引用它。</p>
<div class="code-example"><header><h4>src/app/app.component.ts (hero-service-import)</h4></header><code-example language="ts" format="">import { HeroService } from &#39;./hero.service&#39;;
</code-example></div><h3 id="don-t-use-new-with-the-heroservice-">Don&#39;t use <em>new</em> with the <em>HeroService</em></h3>
<h3 id="-new-heroservice-">不要<code>new</code>出<code>HeroService</code></h3>
<p>How should the <code>AppComponent</code> acquire a runtime concrete <code>HeroService</code> instance?</p>
<p>该如何在运行中获得一个具体的<code>HeroService</code>实例呢？</p>
<p>You could create a new instance of the <code>HeroService</code> with <code>new</code> like this:</p>
<p>你可能想用<code>new</code>来创建<code>HeroService</code>的实例，就像这样：</p>
<div class="code-example"><code-example language="ts" format="">heroService = new HeroService(); // don&#39;t do this
</code-example></div><p>However, this option isn&#39;t ideal for the following reasons:</p>
<p>但这不是个好主意，有很多理由，例如：</p>
<ul>
<li><p>The component has to know how to create a <code>HeroService</code>.
If you change the <code>HeroService</code> constructor,
you must find and update every place you created the service.
Patching code in multiple places is error prone and adds to the test burden.</p>
<p>我们的组件得弄清楚该如何创建<code>HeroService</code>。
  如果有一天我们修改了<code>HeroService</code>的构造函数，我们不得不找出创建过此服务的每一处代码，并修改它。
  围着补丁代码转圈很容易导致错误，还会增加测试负担。</p>
</li>
<li><p>You create a service each time you use <code>new</code>.
What if the service caches heroes and shares that cache with others?
You couldn&#39;t do that.</p>
<p>我们每次使用<code>new</code>都会创建一个新的服务实例。
  如果这个服务需要缓存英雄列表，并把这个缓存共享给别人呢？怎么办？
  没办法，做不到。</p>
</li>
<li><p>With the <code>AppComponent</code> locked into a specific implementation of the <code>HeroService</code>,
switching implementations for different scenarios, such as operating offline or using
different mocked versions for testing, would be difficult.</p>
<p>我们把<code>AppComponent</code>锁定到<code>HeroService</code>的一个特定实现。
  我们很难在不同的场景中切换实现。
  例如，能离线操作吗？能在测试时使用不同的模拟版本吗？这可不容易。</p>
</li>
</ul>
<h3 id="inject-the-heroservice-">Inject the <em>HeroService</em></h3>
<h3 id="-heroservice-">注入 <em>HeroService</em></h3>
<p>Instead of using the <em>new</em> line, you&#39;ll add two lines.</p>
<p>你可以用两行代码代替用<code>new</code>时的一行：</p>
<ul>
<li><p>Add a constructor that also defines a private property.</p>
<p>添加一个构造函数，并定义一个私有属性。</p>
</li>
<li><p>Add to the component&#39;s <code>providers</code> metadata.</p>
<p>添加组件的<code>providers</code>元数据。</p>
</li>
</ul>
<p>Add the constructor:</p>
<p>添加构造函数：</p>
<div class="code-example"><header><h4>src/app/app.component.ts (constructor)</h4></header><code-example language="ts" format="">constructor(private heroService: HeroService) { }
</code-example></div><p>The constructor itself does nothing. The parameter simultaneously
defines a private <code>heroService</code> property and identifies it as a <code>HeroService</code> injection site.</p>
<p>构造函数自己什么也不用做，它在参数中定义了一个私有的<code>heroService</code>属性，并把它标记为注入<code>HeroService</code>的靶点。</p>
<p>Now Angular knows to supply an instance of the <code>HeroService</code> when it creates an <code>AppComponent</code>.</p>
<p>现在，当创建<code>AppComponent</code>实例时，Angular 知道需要先提供一个<code>HeroService</code>的实例。</p>
<div class="l-sub-section"><p>Read more about dependency injection in the <a href="../guide/dependency-injection.html">Dependency Injection</a> page.</p>
<p>更多依赖注入的信息，见<a href="../guide/dependency-injection.html">依赖注入</a>。</p>
</div><p>The <em>injector</em> doesn&#39;t know yet how to create a <code>HeroService</code>.
If you ran the code now, Angular would fail with this error:</p>
<p><em>注入器</em>还不知道该如何创建<code>HeroService</code>。
如果现在运行我们的代码，Angular 就会失败，并报错：</p>
<code-example format="nocode">EXCEPTION: No provider for HeroService! (AppComponent -> HeroService)
(异常：没有 HeroService 的提供商！(AppComponent -> HeroService))
</code-example><p>To teach the injector how to make a <code>HeroService</code>,
add the following <code>providers</code> array property to the bottom of the component metadata
in the <code>@Component</code> call.</p>
<p>我们还得注册一个<code>HeroService</code><strong>提供商</strong>，来告诉<em>注入器</em>如何创建<code>HeroService</code>。
要做到这一点，我们在<code>@Component</code>组件的元数据底部添加<code>providers</code>数组属性如下：</p>
<div class="code-example"><header><h4>src/app/app.component.ts (providers)</h4></header><code-example language="ts" format="">providers: [HeroService]
</code-example></div><p>The <code>providers</code> array  tells Angular to create a fresh instance of the <code>HeroService</code> when it creates an <code>AppComponent</code>.
The <code>AppComponent</code>, as well as its child components, can use that service to get hero data.</p>
<p><code>providers</code>数组告诉 Angular，当它创建新的<code>AppComponent</code>组件时，也要创建一个<code>HeroService</code>的新实例。
<code>AppComponent</code>会使用那个服务来获取英雄列表，在它组件树中的每一个子组件也同样如此。</p>
<a id="child-component"></a><h3 id="-getheroes-in-the-appcomponent-"><em>getHeroes()</em> in the <em>AppComponent</em></h3>
<h3 id="-appcomponent-getheroes-"><em>AppComponent</em> 中的 <em>getHeroes()</em></h3>
<p>The service is in a <code>heroService</code> private variable.</p>
<p>该服务被存入了一个私有变量<code>heroService</code>中。</p>
<p>You could call the service and get the data in one line.</p>
<p>我们可以在同一行内调用此服务，并获得数据。</p>
<div class="code-example"><code-example language="ts" format="">this.heroes = this.heroService.getHeroes();
</code-example></div><p>You don&#39;t really need a dedicated method to wrap one line.  Write it anyway:</p>
<p>在真实的世界中，我们并不需要把一行代码包装成一个专门的方法，但无论如何，我们在演示代码中先这么写：</p>
<div class="code-example"><header><h4>src/app/app.component.ts (getHeroes)</h4></header><code-example language="ts" format="">  getHeroes(): void {
    this.heroes = this.heroService.getHeroes();
  }
</code-example></div><a id="oninit"></a><h3 id="the-ngoninit-lifecycle-hook">The <em>ngOnInit</em> lifecycle hook</h3>
<h3 id="-ngoninit-"><em>ngOnInit</em> 生命周期钩子</h3>
<p><code>AppComponent</code> should fetch and display hero data with no issues.</p>
<p>毫无疑问，<code>AppComponent</code>应该获取英雄数据并显示它。</p>
<p> You might be tempted to call the <code>getHeroes()</code> method in a constructor, but
a constructor should not contain complex logic,
especially a constructor that calls a server, such as as a data access method.
The constructor is for simple initializations, like wiring constructor parameters to properties.</p>
<p>你可能想在构造函数中调用<code>getHeroes()</code>方法，但构造函数不应该包含复杂的逻辑，特别是那些需要从服务器获取数据的逻辑更是如此。构造函数是为了简单的初始化工作而设计的，例如把构造函数的参数赋值给属性。</p>
<p>To have Angular call <code>getHeroes()</code>, you can implement the Angular <em>ngOnInit lifecycle hook</em>.
Angular offers interfaces for tapping into critical moments in the component lifecycle:
at creation, after each change, and at its eventual destruction.</p>
<p>只要我们实现了 Angular 的 <strong>ngOnInit</strong> <em>生命周期钩子</em>，Angular 就会主动调用这个钩子。
Angular提供了一些接口，用来介入组件生命周期的几个关键时间点：刚创建时、每次变化时，以及最终被销毁时。</p>
<p>Each interface has a single method. When the component implements that method, Angular calls it at the appropriate time.</p>
<p>每个接口都有唯一的一个方法。只要组件实现了这个方法，Angular 就会在合适的时机调用它。</p>
<div class="l-sub-section"><p>Read more about lifecycle hooks in the <a href="../guide/lifecycle-hooks.html">Lifecycle Hooks</a> page.</p>
<p>更多生命周期钩子信息，见<a href="../guide/lifecycle-hooks.html">生命周期钩子</a>。</p>
</div><p>Here&#39;s the essential outline for the <code>OnInit</code> interface (don&#39;t copy this into your code):</p>
<p>这是<code>OnInit</code>接口的基本轮廓（但不要拷贝到你自己的代码中）：</p>
<div class="code-example"><code-example language="ts" format="">import { OnInit } from &#39;@angular/core&#39;;

export class AppComponent implements OnInit {
  ngOnInit(): void {
  }
}
</code-example></div><p>Add the implementation for the <code>OnInit</code> interface to your export statement:</p>
<p>往export语句中添加<code>OnInit</code>接口的实现：</p>
<code-example format="nocode">export class AppComponent implements OnInit {}
</code-example><p>Write an <code>ngOnInit</code> method with the initialization logic inside. Angular will call it
at the right time. In this case, initialize by calling <code>getHeroes()</code>.</p>
<p>我们写了一个带有初始化逻辑的<code>ngOnInit</code>方法，Angular会在适当的时候调用它。
  在这个例子中，我们通过调用<code>getHeroes()</code>来完成初始化。</p>
<div class="code-example"><header><h4>app/app.component.ts (ng-on-init)</h4></header><code-example language="ts" format="">  ngOnInit(): void {
    this.getHeroes();
  }
</code-example></div><p>The app should run as expected, showing a list of heroes and a hero detail view
when you click on a hero name.</p>
<p>我们的应用将会像期望的那样运行，显示英雄列表，并且在我们点击英雄的名字时，显示英雄的详情。</p>
<a id="async"></a><h2 id="async-services-and-promises">Async services and Promises</h2>
<h2 id="-">异步服务与承诺</h2>
<p>The <code>HeroService</code> returns a list of mock heroes immediately;
its <code>getHeroes()</code> signature is synchronous.</p>
<p>我们的<code>HeroService</code>立即返回一个模拟的英雄列表，它的<code>getHeroes()</code>函数签名是同步的。</p>
<div class="code-example"><code-example language="ts" format="">this.heroes = this.heroService.getHeroes();
</code-example></div><p>Eventually, the hero data will come from a remote server.
When using a remote server, users don&#39;t have to wait for the server to respond;
additionally, you aren&#39;t able to block the UI during the wait.</p>
<p>但最终，英雄的数据会从远端服务器获取。当使用远端服务器时，用户不会等待服务器的响应。换句话说，你没法在等待期间阻塞浏览器界面。</p>
<p>To coordinate the view with the response, 
you can use <em>Promises</em>, which is an asynchronous 
technique that changes the signature of the <code>getHeroes()</code> method.</p>
<p>为了协调视图与响应，我们可以使用<em>承诺（Promise）</em>，它是一种异步技术，它会改变<code>getHeroes()</code>方法的签名。</p>
<h3 id="the-hero-service-makes-a-promise">The hero service makes a Promise</h3>
<h3 id="-heroservice-"><code>HeroService</code>会生成一个承诺</h3>
<p>A <em>Promise</em> essentially promises to call back when the results are ready.
You ask an asynchronous service to do some work and give it a callback function.
The service does that work and eventually calls the function with the results or an error.</p>
<p><strong>承诺</strong> 就是 …… 好吧，它就是一个承诺，在有了结果时，它承诺会回调我们。
我们请求一个异步服务去做点什么，并且给它一个回调函数。
它会去做（在某个地方），一旦完成，它就会调用我们的回调函数，并通过参数把工作结果或者错误信息传给我们。</p>
<div class="l-sub-section"><p>This is a simplified explanation. Read more about ES2015 Promises in the
<a href="http://exploringjs.com/es6/ch_promises.html">Promises for asynchronous programming</a> page of
<a href="http://http://exploringjs.com/es6.html">Exploring ES6</a>.</p>
<p>这里只是粗略说说，要了解更多 ES2015 Promise 的信息，见<a href="http://http://exploringjs.com/es6.html">ES6概览</a>中的<a href="http://exploringjs.com/es6/ch_promises.html">承诺与异步编程</a>。</p>
</div><p>Update the <code>HeroService</code> with this Promise-returning <code>getHeroes()</code> method:</p>
<p>把<code>HeroService</code>的<code>getHeroes</code>方法改写为返回承诺的形式：</p>
<div class="code-example"><header><h4>src/app/hero.service.ts (excerpt)</h4></header><code-example language="ts" format="">getHeroes(): Promise&lt;Hero[]&gt; {
  return Promise.resolve(HEROES);
}
</code-example></div><p>You&#39;re still mocking the data. You&#39;re simulating the behavior of an ultra-fast, zero-latency server,
by returning an <em>immediately resolved Promise</em> with the mock heroes as the result.</p>
<p>我们继续使用模拟数据。我们通过返回一个 <em>立即解决的承诺</em> 的方式，模拟了一个超快、零延迟的超级服务器。</p>
<h3 id="act-on-the-promise">Act on the Promise</h3>
<h3 id="-">基于承诺的行动</h3>
<p>As a result of the change to <code>HeroService</code>, <code>this.heroes</code> is now set to a <code>Promise</code> rather than an array of heroes.</p>
<p>修改<code>HeroService</code>之后，<code>this.heroes</code>会被赋值为一个<code>Promise</code>而不再是英雄数组。</p>
<div class="code-example"><header><h4>src/app/app.component.ts (getHeroes - old)</h4></header><code-example language="ts" format="">  getHeroes(): void {
    this.heroes = this.heroService.getHeroes();
  }
</code-example></div><p>You have to change the implementation to <em>act on the <code>Promise</code> when it resolves</em>.
When the <code>Promise</code> resolves successfully, you&#39;ll have heroes to display.</p>
<p>我们得修改这个实现，把它变成<em>基于承诺</em>的，并在承诺的事情被解决时再行动。
  一旦承诺的事情被成功解决（Resolve），我们就会显示英雄数据。</p>
<p>Pass the callback function as an argument to the Promise&#39;s <code>then()</code> method:</p>
<p>我们把回调函数作为参数传给承诺对象的<strong>then</strong>方法：</p>
<div class="code-example"><header><h4>src/app/app.component.ts (getHeroes - revised)</h4></header><code-example language="ts" format="">getHeroes(): void {
  this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);
}
</code-example></div><div class="l-sub-section"><p>As described in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow functions</a>,
the ES2015 arrow function
in the callback is more succinct than the equivalent function expression and gracefully handles <code>this</code>.</p>
<p>回调中所用的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">ES2015 箭头函数</a>
比等价的函数表达式更加简洁，能优雅的处理 <em>this</em> 指针。</p>
</div><p>The callback sets the component&#39;s <code>heroes</code> property to the array of heroes returned by the service.</p>
<p>在回调函数中，我们把服务返回的英雄数组赋值给组件的<code>heroes</code>属性。</p>
<p>The app is still running, showing a list of heroes, and
responding to a name selection with a detail view.</p>
<p>我们的程序仍在运行，仍在显示英雄列表，在选择英雄时，仍然会把它/她显示在详情页面中。</p>
<div class="l-sub-section"><p>At the end of this page, <a href="#slow">Appendix: take it slow</a> describes what the app might be like with a poor connection.</p>
<p>查看附录中的“<a href="#slow">慢！</a>”，来了解在较差的网络连接中这个应用会是什么样的。</p>
</div><h2 id="review-the-app-structure">Review the app structure</h2>
<h2 id="-">回顾本应用的结构</h2>
<p>Verify that you have the following structure after all of your refactoring:</p>
<p>再检查下，经历了本章的所有重构之后，应该有了下列文件结构：</p>
<div class="filetree"><div class="file">angular-tour-of-heroes</div><div class="children"><div class="file">src</div><div class="children"><div class="file">app</div><div class="children"><div class="file">app.component.ts</div><div class="file">app.module.ts</div><div class="file">hero.ts</div><div class="file">hero-detail.component.ts</div><div class="file">hero.service.ts</div><div class="file">mock-heroes.ts</div></div><div class="file">main.ts</div><div class="file">index.html</div><div class="file">styles.css</div><div class="file">systemjs.config.js</div><div class="file">tsconfig.json</div></div><div class="file">node_modules ...</div><div class="file">package.json</div></div></div><p>Here are the code files discussed in this page.</p>
<p>下面是本章讨论过的代码文件：</p>
<code-tabs><code-pane language="ts" name="src/app/hero.service.ts" format="linenums">import { Injectable } from &#39;@angular/core&#39;;

import { Hero } from &#39;./hero&#39;;
import { HEROES } from &#39;./mock-heroes&#39;;

@Injectable()
export class HeroService {
  getHeroes(): Promise&lt;Hero[]&gt; {
    return Promise.resolve(HEROES);
  }
}
</code-pane><code-pane language="ts" name="src/app/app.component.ts" format="linenums">import { Component, OnInit } from &#39;@angular/core&#39;;

import { Hero } from &#39;./hero&#39;;
import { HeroService } from &#39;./hero.service&#39;;

@Component({
  selector: &#39;my-app&#39;,
  template: `
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;h2&gt;My Heroes&lt;/h2&gt;
    &lt;ul class=&quot;heroes&quot;&gt;
      &lt;li *ngFor=&quot;let hero of heroes&quot;
        [class.selected]=&quot;hero === selectedHero&quot;
        (click)=&quot;onSelect(hero)&quot;&gt;
        &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/hero-detail&gt;
  `,
  styles: [`
    .selected {
      background-color: #CFD8DC !important;
      color: white;
    }
    .heroes {
      margin: 0 0 2em 0;
      list-style-type: none;
      padding: 0;
      width: 15em;
    }
    .heroes li {
      cursor: pointer;
      position: relative;
      left: 0;
      background-color: #EEE;
      margin: .5em;
      padding: .3em 0;
      height: 1.6em;
      border-radius: 4px;
    }
    .heroes li.selected:hover {
      background-color: #BBD8DC !important;
      color: white;
    }
    .heroes li:hover {
      color: #607D8B;
      background-color: #DDD;
      left: .1em;
    }
    .heroes .text {
      position: relative;
      top: -3px;
    }
    .heroes .badge {
      display: inline-block;
      font-size: small;
      color: white;
      padding: 0.8em 0.7em 0 0.7em;
      background-color: #607D8B;
      line-height: 1em;
      position: relative;
      left: -1px;
      top: -4px;
      height: 1.8em;
      margin-right: .8em;
      border-radius: 4px 0 0 4px;
    }
  `],
  providers: [HeroService]
})
export class AppComponent implements OnInit {
  title = &#39;Tour of Heroes&#39;;
  heroes: Hero[];
  selectedHero: Hero;

  constructor(private heroService: HeroService) { }

  getHeroes(): void {
    this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);
  }

  ngOnInit(): void {
    this.getHeroes();
  }

  onSelect(hero: Hero): void {
    this.selectedHero = hero;
  }
}
</code-pane><code-pane language="ts
  " name="src/app/mock-heroes.ts" format="linenums">import { Hero } from &#39;./hero&#39;;

export const HEROES: Hero[] = [
  {id: 11, name: &#39;Mr. Nice&#39;},
  {id: 12, name: &#39;Narco&#39;},
  {id: 13, name: &#39;Bombasto&#39;},
  {id: 14, name: &#39;Celeritas&#39;},
  {id: 15, name: &#39;Magneta&#39;},
  {id: 16, name: &#39;RubberMan&#39;},
  {id: 17, name: &#39;Dynama&#39;},
  {id: 18, name: &#39;Dr IQ&#39;},
  {id: 19, name: &#39;Magma&#39;},
  {id: 20, name: &#39;Tornado&#39;}
];
</code-pane></code-tabs><h2 id="the-road-you-ve-travelled">The road you&#39;ve travelled</h2>
<h2 id="-">走过的路</h2>
<p>Here&#39;s what you achieved in this page:</p>
<p>来盘点一下我们完成了什么。</p>
<ul>
<li><p>You created a service class that can be shared by many components.</p>
<p>我们创建了一个能被多个组件共享的服务类。</p>
</li>
<li><p>You used the <code>ngOnInit</code> lifecycle hook to get the hero data when the <code>AppComponent</code> activates.</p>
<p>我们使用了<code>ngOnInit</code>生命周期钩子，以便在<code>AppComponent</code>激活时获取英雄数据。</p>
</li>
<li><p>You defined the <code>HeroService</code> as a provider for the <code>AppComponent</code>.</p>
<p>我们把<code>HeroService</code>定义为<code>AppComponent</code>的一个提供商。</p>
</li>
<li><p>You created mock hero data and imported them into the service.</p>
<p>我们创建了模拟的英雄数据，并把它导入我们的服务中。</p>
</li>
<li><p>You designed the service to return a Promise and the component to get the data from the Promise.</p>
<p>我们把服务设计为返回承诺，组件从承诺中获取数据。</p>
</li>
</ul>
<p>Your app should look like this <live-example></live-example>.</p>
<p>现在应用变成了这样：<live-example></live-example>。</p>
<h2 id="the-road-ahead">The road ahead</h2>
<h2 id="-">前方的路</h2>
<p>The Tour of Heroes has become more reusable using shared components and services.
The next goal is to create a dashboard, add menu links that route between the views, and format data in a template.
As the app evolves, you&#39;ll discover how to design it to make it easier to grow and maintain.</p>
<p>通过使用共享组件和服务，我们的《英雄指南》更有复用性了。
  我们还要创建一个仪表盘，要添加在视图间路由的菜单链接，还要在模板中格式化数据。
  随着我们应用的进化，我们还会学到如何进行设计，让它更易于扩展和维护。</p>
<p>Read about the Angular component router and navigation among the views in the <a href="toh-pt5.html">next tutorial</a> page.</p>
<p>我们将在<a href="toh-pt5.html">下一章</a>学习 Angular 组件路由，以及在视图间导航的知识。</p>
<div class="l-main-section"></div><a id="slow"></a><h2 id="appendix-take-it-slow">Appendix: Take it slow</h2>
<h2 id="-">附件：慢</h2>
<p>To simulate a slow connection,
import the <code>Hero</code> symbol and add the following <code>getHeroesSlowly()</code> method to the <code>HeroService</code>.</p>
<p>我们可以模拟慢速连接。导入<code>Hero</code>类，并且在<code>HeroService</code>中添加如下的<code>getHeroesSlowly()</code>方法：</p>
<div class="code-example"><header><h4>app/hero.service.ts (getHeroesSlowly)</h4></header><code-example language="ts" format="">getHeroesSlowly(): Promise&lt;Hero[]&gt; {
  return new Promise(resolve =&gt; {
    // Simulate server latency with 2 second delay
    setTimeout(() =&gt; resolve(this.getHeroes()), 2000);
  });
}
</code-example></div><p>Like <code>getHeroes()</code>, it also returns a <code>Promise</code>.
But this Promise waits two seconds before resolving the Promise with mock heroes.</p>
<p>像<code>getHeroes()</code>一样，它也返回一个承诺。
但是，这个承诺会在提供模拟数据之前等待两秒钟。</p>
<p>Back in the <code>AppComponent</code>, replace <code>getHeroes()</code> with <code>getHeroesSlowly()</code>
and see how the app behaves.</p>
<p>回到<code>AppComponent</code>，用<code>heroService.getHeroesSlowly()</code>替换<code>heroService.getHeroes()</code>，并观察应用的行为。</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><div class="l-sub-section"><h3>下一步</h3><a href="/docs/ts/latest/tutorial/toh-pt5.html" class="translated-cn">路由</a></div><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></article><div data-swiftype-index="false" class="main-footer"><nav class="background-midnight grid-fluid"><div class="c3 main-footer-branding"><div class="logo-inverse-large"></div></div><div class="c2"><h3 class="text-headline">RESOURCES</h3><h3 class="text-headline">资源库</h3><ul class="text-body"><!-- TODO: (ericjim) make a libraries page to showcase all angular libraries--><!--li <a href="/libraries.html">Libraries</a>--><li><p><a href="/about/">About</a></p><p><a href="/about/">关于</a></p></li><li><p><a href="/resources/#Education">Books & Training</a></p><p><a href="/resources/#Education">书籍与培训</a></p></li><li><p><a href="/resources/">Tools & Libraries</a></p><p><a href="/resources/">工具与库</a></p></li><li><p><a href="/resources/">Community</a></p><p><a href="/resources/">社区</a></p></li><li><p><a href="/presskit.html">Press Kit</a></p><p><a href="/presskit.html">宣传资料</a></p></li></ul></div><div class="c2"><h3 class="text-headline">HELP</h3><h3 class="text-headline">帮助</h3><ul class="text-body"><li><a href="http://stackoverflow.com/questions/tagged/angular2">Stack Overflow</a></li><li><a href="https://gitter.im/angular/angular">Gitter</a></li><li><a href="https://groups.google.com/forum/#!forum/angular"> Google Group</a></li><li><p><a href="https://github.com/angular/angular/issues"> Report Issues</a></p><p><a href="https://github.com/angular/angular/issues"> 报告问题</a></p></li><li><p><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> Site Feedback</a></p><p><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> 网站反馈</a></p></li></ul></div><div class="c2"><h3 class="text-headline">COMMUNITY</h3><h3 class="text-headline">社区</h3><ul class="text-body"><li><p><a href="/events.html">Events</a></p><p><a href="/events.html">会议</a></p></li><li><a href="http://www.meetup.com/topics/angularjs/">Meetups</a></li><li><a href="https://twitter.com/angular"> Twitter</a></li><li><a href="https://github.com/angular/angular"> GitHub</a></li><li><p><a href="/contribute.html"> Contribute</a></p><p><a href="/contribute.html"> 做贡献</a></p></li></ul></div><div class="c2"><h3 class="text-headline">LANGUAGES</h3><h3 class="text-headline">其它语种</h3><ul class="text-body"><li><a href="https://angular.io/">英文版</a></li></ul></div></nav><footer class="background-midnight"><small class="text-caption">Powered by Google ©2010-2017。代码授权方式：<a href="/license">MIT-style License</a>。文档授权方式：<a href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>。</small><a aria-label="查看风格指南" href="/docs/ts/latest/styleguide.html" title="风格指南" md-button="md-button" class="styleguide-trigger text-snow translated-cn"><span class="icon-favorite"></span></a><p><small class="text-caption">本网站由洛阳永欣维护 &nbsp;<a href="http://www.miitbeian.gov.cn/">豫ICP备16019859号-1</a></small></p></footer></div><!-- VENDORS --><script src="/resources/js/vendor/prettify.js"></script><script src="/resources/js/vendor/lang-basic.js"></script><script src="/resources/js/vendor/lang-dart.js"></script><script src="/resources/js/vendor/lodash.js"></script><script src="/resources/js/vendor/clipboard.min.js"></script><!-- Angular Material Dependencies --><script src="/resources/js/vendor/angular.min.js"></script><script src="/resources/js/vendor/angular-animate.min.js"></script><script src="/resources/js/vendor/angular-aria.min.js"></script><script src="/resources/js/vendor/angular-material.min.js"></script><!-- Firebase -->
<script src="/resources/js/vendor/firebase.js"></script>
<!-- AngularFire -->
<script src="/resources/js/vendor/angularfire.min.js"></script>
<!-- Angular.io Site JS --><script src="/translate/cn/translate.js"></script><script src="/resources/js/site.js"></script><script src="/resources/js/util.js"></script><script src="/resources/js/controllers/app-controller.js"></script><script src="/resources/js/controllers/resources-controller.js"></script><script src="/resources/js/directives/cheatsheet.js"></script><script src="/resources/js/directives/api-list.js"></script><script src="/resources/js/directives/bio.js"></script><script src="/resources/js/directives/bold.js"></script><script src="/resources/js/directives/announcement-bar.js"></script><script src="/resources/js/directives/code.js"></script><script src="/resources/js/directives/copy.js"></script><script src="/resources/js/directives/code-tabs.js"></script><script src="/resources/js/directives/code-pane.js"></script><script src="/resources/js/directives/code-example.js"></script><script src="/resources/js/directives/if-docs.js"></script><script src="/resources/js/directives/live-example.js"></script><script src="/resources/js/directives/scroll-y-offset-element.js"></script><!-- GA --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-80456300-1', 'auto');
ga('send', 'pageview')
</script><!-- SWIFTYPE --><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','VsuU7kH5Hnnj9tfyNvfK','2.0.0');</script></body></html>